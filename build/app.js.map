{"version":3,"file":"app.js","mappings":"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","sources":["webpack://retro-2d-game-engine/./src/app/audio/AudioBufferLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioContext.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/Mixer.ts","webpack://retro-2d-game-engine/./src/app/audio/SoundFX.ts","webpack://retro-2d-game-engine/./src/app/domain/Creature.ts","webpack://retro-2d-game-engine/./src/app/domain/CreatureState.ts","webpack://retro-2d-game-engine/./src/app/domain/Grid.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/Enemy.ts","webpack://retro-2d-game-engine/./src/app/domain/map/Map.ts","webpack://retro-2d-game-engine/./src/app/domain/map/MapKeys.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/GameObject.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/GameObjectFactory.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/box/Box.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/box/BoxFactory.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Crosshair.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Player.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Projectile.ts","webpack://retro-2d-game-engine/./src/app/graphics/GraphicsLoader.ts","webpack://retro-2d-game-engine/./src/app/graphics/Sprites.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/CreatureSprite.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/SpriteZerg.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Canvas.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/CollisionBox.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Directions.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/FrameRate.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/GameAssets.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Pathfinding.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Raycaster.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/Game.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStates.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/geometry/Point.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Gamepads.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Keyboard.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Mouse.ts","webpack://retro-2d-game-engine/./src/app/peripherals/constants/KeyCodes.ts","webpack://retro-2d-game-engine/webpack/bootstrap","webpack://retro-2d-game-engine/./src/main.ts"],"sourcesContent":["import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/enemy_hit_1.mp3'),\n      load('./audio/enemy_hit_2.mp3'),\n      load('./audio/enemy_hit_3.mp3'),\n      load('./audio/enemy_hit_4.mp3'),\n      load('./audio/enemy_hit_5.mp3'),\n\n      load('./audio/enemy_die_1.mp3'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.SMG[0] = soundFxFiles[0]\n    this.SMG[1] = soundFxFiles[1]\n    this.SMG[2] = soundFxFiles[2]\n    this.SMG[3] = soundFxFiles[3]\n    this.SMG[4] = soundFxFiles[4]\n\n    this.CRATE_HIT[0] = soundFxFiles[5]\n\n    this.ENEMY_HIT[0] = soundFxFiles[6]\n    this.ENEMY_HIT[1] = soundFxFiles[7]\n    this.ENEMY_HIT[2] = soundFxFiles[8]\n    this.ENEMY_HIT[3] = soundFxFiles[9]\n    this.ENEMY_HIT[4] = soundFxFiles[10]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[11]\n    setLoadedPercentage(1.0)\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playCrateHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox, { collisionBoxesIntersect, ICollidable } from '@app/infrastructure/CollisionBox'\n\nimport CreatureState from '@app/domain/CreatureState'\nimport { gameObjects } from '@app/domain/map/Map'\nimport { Directions } from '@app/infrastructure/Directions'\n\nexport default abstract class Creature {\n  public prevX: number[] = [] // TODO: Make private?\n  public prevY: number[] = [] // TODO: Make private?\n  public x: number\n  public y: number\n  public nextX: number\n  public nextY: number\n  public row: number\n  public col: number\n  public maxHealth = 100\n  public health: number\n\n  public maxSpeed: number\n  public maxSpeedDiagonal: number\n\n  public state: CreatureState = CreatureState.Idling\n  public previousState: CreatureState = CreatureState.Idling // TODO: Use `previousState` for something? (Currently it's unused)\n\n  public animationPosition: number = 0\n\n  public direction: Directions\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public blocked = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  protected resetMoving(): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n  }\n\n  protected resetBlocked(): void {\n    this.blocked.up    = false\n    this.blocked.down  = false\n    this.blocked.left  = false\n    this.blocked.right = false\n  }\n\n  protected calculateNextCoordinates(): void {\n    this.nextX = this.x\n    this.nextY = this.y\n\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX -= this.maxSpeedDiagonal\n      } else {\n        this.nextX -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX += this.maxSpeedDiagonal\n      } else {\n        this.nextX += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY -= this.maxSpeedDiagonal\n      } else {\n        this.nextY -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY += this.maxSpeedDiagonal\n      } else {\n        this.nextY += this.maxSpeed\n      }\n    }\n  }\n\n  protected checkIfBlockedByCreature(c: Creature, nextCreatureState: ICollidable) {\n    if (collisionBoxesIntersect(nextCreatureState, c)) {\n      let intersectionX: number\n      let intersectionY: number\n      if (nextCreatureState.x < c.x) {\n        intersectionX = (nextCreatureState.x + nextCreatureState.collisionBox.halfWidth) - (c.x - c.collisionBox.halfWidth)\n      } else if (nextCreatureState.x > c.x) {\n        intersectionX = (c.x + c.collisionBox.halfWidth) - (nextCreatureState.x - nextCreatureState.collisionBox.halfWidth)\n      }\n      if (nextCreatureState.y < c.y) {\n        intersectionY = (nextCreatureState.y + nextCreatureState.collisionBox.halfHeight) - (c.y - c.collisionBox.halfHeight)\n      } else if (nextCreatureState.y > c.y) {\n        intersectionY = (c.y + c.collisionBox.halfHeight) - (nextCreatureState.y - nextCreatureState.collisionBox.halfHeight)\n      }\n      if (!intersectionX || intersectionX >= intersectionY) {\n        if (nextCreatureState.y < c.y) {\n          this.blocked.down = true\n        } else {\n          this.blocked.up = true\n        }\n      } else if (!intersectionY || intersectionX < intersectionY) {\n        if (nextCreatureState.x < c.x) {\n          this.blocked.right = true\n        } else {\n          this.blocked.left = true\n        }\n      }\n    }\n  }\n\n  protected adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow && SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow && NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol && NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol && NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol && SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol && SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  protected updatePreviousCoordinates(): void {\n    this.prevX.push(this.x)\n    if (this.prevX.length > 5) { this.prevX.shift() }\n\n    this.prevY.push(this.y)\n    if (this.prevY.length > 5) { this.prevY.shift() }\n  }\n\n  protected updateDirection(): void {\n    const direction: string[] = []\n\n    const dx = this.prevX[this.prevX.length - 1] - this.prevX[this.prevX.length - 2]\n    const dy = this.prevY[this.prevY.length - 1] - this.prevY[this.prevY.length - 2]\n\n    if (dy > 0) {\n      direction.push(Directions.S)\n    }\n    else if (dy < 0) {\n      direction.push(Directions.N)\n    }\n\n    if (dx > 0) {\n      direction.push(Directions.E)\n    }\n    else if (dx < 0) {\n      direction.push(Directions.W)\n    }\n\n    const directionString = direction.join('') || this.direction || 'S'\n\n    this.direction = Directions[directionString as keyof typeof Directions]\n  }\n\n  protected checkIfMoving(): boolean {\n    const xUnchanged = this.prevX[this.prevX.length - 1] === this.prevX[this.prevX.length - 2]\n    const yUnchanged = this.prevY[this.prevY.length - 1] === this.prevY[this.prevY.length - 2]\n    if (xUnchanged && yUnchanged) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  protected initializeHealth(healthPercentage: number = 1.0): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n\n  // TODO: The color strings can be moved to a single hash map in order to optimize & localize the color searches\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.1) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.2) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.3) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.4) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.5) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.6) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.7) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.8) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.9) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n\n  protected resetAnimation() {\n    this.animationPosition = 0\n  }\n\n  public setState(newState: CreatureState) {\n    this.previousState = this.state\n    this.state = newState\n    this.resetAnimation()\n  }\n}\n","enum CreatureState {\n  Idling,\n  Moving,\n  Attacking,\n  Dying,\n  Decaying,\n}\n\nexport default CreatureState\n","import * as CONFIG from '@app/configuration/config.json'\n\n// TODO: This class is useless?\nexport default class Grid {\n  public rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  public cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n\nexport interface NeighbourTiles {\n    N  : (any | null)\n    NE : (any | null)\n    E  : (any | null)\n    SE : (any | null)\n    S  : (any | null)\n    SW : (any | null)\n    W  : (any | null)\n    NW : (any | null)\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, findShortestPath, drawPathNodes, drawNode } from '@app/infrastructure/Pathfinding'\n\nimport CreatureState from '@app/domain/CreatureState'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport Sprites from '@app/graphics/Sprites'\n\nexport default class ConcreteEnemy extends Enemy {\n  protected sprite: CreatureSprite = Sprites.Zerg\n  protected target: Point\n\n  protected attackSpeed = 32\n\n  constructor(\n    x: number,\n    y: number,\n    healthPercentage: number,\n    protected pathfindingInterval: number\n  ) {\n    super(x, y, new CollisionBox(14, 14), 1, healthPercentage)\n    this.updateMapPosition()\n  }\n\n  public update(player: Player, enemies: Enemy[]): void {\n    if (this.state === CreatureState.Dying) {\n      return\n    }\n    if (this.state === CreatureState.Decaying) {\n      return\n    }\n\n    if (!this.target) {\n      this.target = player\n    }\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n    this.updatePreviousCoordinates()\n\n    this.stuck = this.checkIfStuck() // TODO: Extract to state\n\n    if (\n      this.state !== CreatureState.Idling &&\n      this.state !== CreatureState.Attacking &&\n      this.checkIfMoving() === false\n    ) {\n      this.setState(CreatureState.Idling)\n    }\n\n    this.adjustCollisionWithGameObjects()\n    this.checkForCollisionWithPlayer(player)\n    this.checkForCollisionWithOtherEnemies(player)\n    this.distanceFromTarget = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   },\n    )\n\n    const targetIsInRange = this.targetInRange(player)\n    if (this.state !== CreatureState.Attacking && targetIsInRange) {\n      this.resetAttackCooldown()\n      this.setState(CreatureState.Attacking)\n    }\n\n    if (this.state === CreatureState.Attacking) {\n      if (targetIsInRange) {\n        this.attack(player)\n      } else {\n        this.setState(CreatureState.Moving)\n      }\n    }\n\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy =\n      Raycaster.determineIfThereAreObstaclesBetweenTwoPathNodes(this, player)\n\n    if ( // TODO: Clean this if statement up, if possible?\n      this.state === CreatureState.Idling ||\n      this.state === CreatureState.Moving\n    ) {\n      this.findPathToPlayer(player, this.thereAreObstaclesBetweenPlayerAndThisEnemy)\n\n      if (\n        this.state !== CreatureState.Moving &&\n        (\n          this.thereAreObstaclesBetweenPlayerAndThisEnemy === false ||\n          this.shortestPath.length > 0\n        )\n      ) {\n        this.setState(CreatureState.Moving)\n      }\n    }\n\n    if (this.state === CreatureState.Moving) {\n      this.move()\n    }\n\n    this.updateDirection() // TODO: This is based on movement, which is incorrect - fix it\n    this.updateTileDeltas()\n\n    if (Game.stateManager.getState() === GAME_STATES.PLAYING) {\n      this.advanceAnimation()\n    }\n  }\n\n  public draw(player: Player): void {\n    if (CONFIG.DEBUG.ENEMY_COLLISION_BOX) {\n      this.drawCollisionBox(player)\n    }\n    if (CONFIG.DEBUG.ENEMY_STATE) {\n      this.drawStateDebug(player)\n    }\n    if (CONFIG.DEBUG.RAY_TO_PLAYER) {\n      this.drawRayToPlayer(player)\n    }\n    if (CONFIG.DEBUG.PATHFINDING_NODES) {\n      drawPathNodes(this.pathfindingNodes, player, this.getHealthColor())\n    }\n\n    if (CONFIG.DEBUG.SHORTEST_PATH_TO_PLAYER) {\n      this.drawShortestPathToPlayer(player)\n    }\n    this.sprite.draw(this, { x: player.x, y: player.y })\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.setState(CreatureState.Decaying)\n  }\n\n  protected advanceAnimation(): void {\n    if (this.state === CreatureState.Attacking) {\n      this.animationPosition = (this.animationPosition + 0.15) % this.sprite.numberOfSpritesInAnimation.attacking\n    } else if (this.state === CreatureState.Moving) {\n     this.animationPosition = (this.animationPosition + 0.25) % this.sprite.numberOfSpritesInAnimation.walking\n    }\n  }\n\n  private findPathToPlayer(player: Player, thereAreObstaclesBetweenPlayerAndThisEnemy: boolean) {\n    if (thereAreObstaclesBetweenPlayerAndThisEnemy) { // TODO: || this.isStuck()\n      if (this.pathfindingInterval === 0) {\n        this.pathfindingNodes = generatePathNodes(\n          Math.round(Math.abs(player.row + this.row) / 2),\n          Math.round(Math.abs(player.col + this.col) / 2),\n          this.collisionBox,\n        )\n        this.shortestPath = findShortestPath(this, player, this.pathfindingNodes)\n      }\n\n      this.pathfindingInterval = (this.pathfindingInterval + 1) % this.pathfindingPeriod\n\n      if (this.shortestPath.length > 0) {\n        this.followTheShortestPath()\n      }\n    }\n    else { // Target is in line of sight\n      if (this.pathfindingNodes) {\n        this.pathfindingNodes = null\n      }\n      if (this.shortestPath) {\n        this.shortestPath = []\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private followTheShortestPath(): void {\n    // If the enemy is close to the path node, pop that node and move to the next one\n    let nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n    let nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    if (\n      this.shortestPath.length > 1 &&\n      Math.abs(nextNodeX - this.x) < 3 &&\n      Math.abs(nextNodeY - this.y) < 3\n    ) {\n      this.shortestPath.pop()\n      nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n      nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    }\n    this.moveTowards(nextNodeX, nextNodeY)\n  }\n\n  private moveTowardsPlayer(player: Point): void {\n    if (this.distanceFromTarget > this.collisionBox.width) {\n      this.moveTowards(player.x, player.y)\n    }\n    else {\n      this.resetMoving()\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.resetMoving()\n\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.2\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  private drawStateDebug(player: Player) {\n    context.beginPath()\n      context.font = '8px Monospace'\n      context.fillText(\n        this.state.toString(),\n        Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,\n        Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight\n      )\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawShortestPathToPlayer(p: Player) {\n    this.shortestPath\n      .forEach((n, i) => {\n        drawNode(n, p, n.visited ? '#FF0000' : '#FF00FF')\n      })\n    if (this.shortestPath.length > 0) {\n      this.shortestPath.forEach((node, i) => {\n        this.drawRayFromPointToPoint(node, this.shortestPath[i - 1] || p, p)\n      })\n    }\n  }\n\n  // TODO: Just for debugging\n  private drawRayFromPointToPoint(p1: Point, p2: Point, player: Player) {\n    context.strokeStyle = '#FF00FF'\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (p2.x - player.x), Canvas.center.y + (p2.y - player.y))\n      context.lineTo(Canvas.center.x + (p1.x - player.x), Canvas.center.y + (p1.y - player.y))\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Creature from '@app/domain/Creature'\nimport Player from '@app/domain/player/Player'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport { PathNode } from '@app/infrastructure/Pathfinding'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport SoundFX from '@app/audio/SoundFX'\n\nimport { getEnemiesOnScreen } from '../map/Map'\n\nexport default abstract class Enemy extends Creature {\n  protected stuck: boolean // TODO: Use stuck for something?\n\n  protected distanceFromTarget: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathfindingInterval: number = 0\n  protected pathfindingPeriod: number = 30\n  protected pathfindingNodes: PathNode[]\n  protected shortestPath: PathNode[] = []\n\n  protected sprite: CreatureSprite\n\n  protected readonly attackSpeed: number // Frames\n  protected attackCooldown: number\n\n  constructor(\n    public x: number,\n    public y: number,\n    collisionBox: CollisionBox,\n    maxSpeed: number,\n    healthPercentage: number,\n  ) {\n    super()\n    this.initializeHealth(healthPercentage)\n\n    this.maxSpeed = maxSpeed\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed)\n\n    this.collisionBox = collisionBox\n\n    this.attackCooldown = this.attackSpeed // TODO: Extract to initializeAttackParameters() or somehting...\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player, enemies: Enemy[]): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    const offScreenOffset = CONFIG.TILE_SIZE * 2\n    return (\n      Math.abs(this.x - playerX) < CONFIG.CANVAS_WIDTH / 2 + offScreenOffset &&\n      Math.abs(this.y - playerY) < CONFIG.CANVAS_HEIGHT / 2 + offScreenOffset\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n  protected abstract advanceAnimation(): void\n\n  protected checkForCollisionWithPlayer(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    this.checkIfBlockedByCreature(player, nextEnemyState)\n  }\n\n  protected checkForCollisionWithOtherEnemies(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesInScreenRangeFromThis = getEnemiesOnScreen(this.x, this.y)\n\n    enemiesInScreenRangeFromThis.forEach((e) => {\n      if (this !== e) {\n        this.checkIfBlockedByCreature(e, nextEnemyState)\n      }\n    })\n  }\n\n  protected targetInRange(target: Creature) {\n    const sumOfCollisionBoxHalfDiagonals = (target.collisionBox.halfWidth + this.collisionBox.halfWidth) * Math.sqrt(2)\n    return this.distanceFromTarget < sumOfCollisionBoxHalfDiagonals\n  }\n  \n  protected resetAttackCooldown() {\n    this.attackCooldown = this.attackSpeed\n  }\n\n  protected checkIfStuck(): boolean {\n    const xIsStatic = this.prevX.every((x) => x === this.prevX[0])\n    const yIsStatic = this.prevY.every((y) => y === this.prevY[0])\n    if (xIsStatic && yIsStatic) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  protected attack(p: Player): void {\n    if (this.attackCooldown <= 0) {\n      this.resetAttackCooldown()\n\n      SoundFX.playSMG() // TODO: Change the SFX\n      this.dealDamage(p)\n    } else {\n      --this.attackCooldown\n    }\n  }\n\n  protected dealDamage(p: Player) {\n    p.takeDamage(this.getDamage())\n  }\n\n  // TODO: Implement damage range\n  protected getDamage() {\n    return 10\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport CreatureState from '@app/domain/CreatureState'\nimport ConcreteEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport IMap from './IMap'\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\nexport const enemies: Enemy[] = []\n\nexport function getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n  return enemies.filter(e => e.isOnScreen(playerX, playerY))\n}\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public update(): void {\n    enemies.forEach((e, i) => {\n      e.update(this.player, enemies)\n      if (e.state === CreatureState.Decaying) {\n        enemies.splice(i, 1) // Remove the enemy\n      }\n    })\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map.gameObjects[row][col])\n      }\n    }\n\n    map.enemies.forEach((e, i) => {\n      enemies.push(new ConcreteEnemy(e.x, e.y, e.healthPercentage, i))\n    })\n  }\n}\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playCrateHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox, {\n  collisionBoxesIntersect,\n} from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport Creature from '@app/domain/Creature'\nimport { getEnemiesOnScreen } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player extends Creature {\n  public alive: boolean = true\n  public rotation: number = 0\n  public sightLineLength = 10\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(public x: number, public y: number) {\n    super()\n    this.initializeHealth()\n\n    this.maxSpeed = 2\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed) // TODO: Extract function\n\n    this.collisionBox = new CollisionBox(12, 12)\n\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n\n    this.checkForCollisionWithEnemies()\n    this.move()\n    this.adjustCollisionWithGameObjects()\n    this.updateMapPosition()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    if (CONFIG.DEBUG.PLAYER_VISION_RAY_SHOTGUN) {\n      this.drawPlayerVisionRay(theta - 0.45)\n      this.drawPlayerVisionRay(theta - 0.4)\n      this.drawPlayerVisionRay(theta - 0.35)\n      this.drawPlayerVisionRay(theta - 0.3)\n      this.drawPlayerVisionRay(theta - 0.25)\n      this.drawPlayerVisionRay(theta - 0.2)\n      this.drawPlayerVisionRay(theta - 0.15)\n      this.drawPlayerVisionRay(theta - 0.1)\n      this.drawPlayerVisionRay(theta - 0.05)\n      this.drawPlayerVisionRay(theta + 0.05)\n      this.drawPlayerVisionRay(theta + 0.1)\n      this.drawPlayerVisionRay(theta + 0.15)\n      this.drawPlayerVisionRay(theta + 0.2)\n      this.drawPlayerVisionRay(theta + 0.25)\n      this.drawPlayerVisionRay(theta + 0.3)\n      this.drawPlayerVisionRay(theta + 0.35)\n      this.drawPlayerVisionRay(theta + 0.4)\n      this.drawPlayerVisionRay(theta + 0.45)\n    }\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = Canvas.mousePosition.x - Canvas.center.x\n      const dy = Canvas.mousePosition.y - Canvas.center.y\n      let xVel = dx / (Math.abs(dx) + Math.abs(dy))\n      let yVel = dy / (Math.abs(dx) + Math.abs(dy))\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      if (CONFIG.FEATURES.SCATTER_PROJECTILES) {\n        const randomFactorX = Math.random() * 0.1 - 0.05\n        const randomFactorY = Math.random() * 0.1 - 0.05\n        xVel += randomFactorX\n        yVel += randomFactorY\n      }\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public takeDamage(damageAmount: number): void {\n    this.health = this.health - damageAmount\n    if (this.health <= 0) {\n      // TODO: Implement lose condition\n    }\n  }\n\n  private move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n    context.fillStyle = '#00AA00'\n    context.font = '10px Monospace'\n\n    context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n    context.strokeStyle = '#523DA5'\n    context.lineWidth = 2\n    context.moveTo(Canvas.center.x, Canvas.center.y)\n    context.lineTo(\n      Canvas.center.x + this.sightLineLength * Math.cos(theta),\n      Canvas.center.y + this.sightLineLength * Math.sin(theta),\n    )\n    context.stroke()\n\n    if (CONFIG.DEBUG.PLAYER_COLLISION_BOX) {\n      this.drawCollisionBox()\n    }\n  }\n\n  private drawCollisionBox() {\n    context.strokeStyle = this.getHealthColor()\n\n    context.lineWidth = 0.5\n    context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // cache the vertex calculations.\n    context.moveTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach((p) => p.draw(this.x, this.y))\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  private checkForCollisionWithEnemies(): void {\n    const nextPlayerState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesOnScreen = getEnemiesOnScreen(this.x, this.y)\n\n    if (\n      enemiesOnScreen.some((e) => collisionBoxesIntersect(e, nextPlayerState))\n    ) {\n      enemiesOnScreen.forEach((e) => {\n        this.checkIfBlockedByCreature(e, nextPlayerState)\n      })\n    }\n  }\n\n  private die(): void {\n    this.alive = false\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { gameObjects, enemies } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        o.takeDamage(this.getDamage())\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import Sprites from './Sprites'\n\nexport default class GraphicsLoader {\n  public static async load(setLoadedPercentage: (percentage: number) => void) {\n    Sprites.load(setLoadedPercentage)\n  }\n}","import CreatureSprite from './sprites/CreatureSprite'\nimport SpriteZerg from './sprites/SpriteZerg'\n\nexport default class Sprites {\n  public static Zerg: CreatureSprite = new SpriteZerg()\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    await Sprites.Zerg.load(() => setLoadedPercentage(1.0))\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default abstract class CreatureSprite {\n  public spriteSheet: HTMLImageElement\n\n  public abstract numberOfSpritesInAnimation: { [animation: string]: number }\n\n  protected abstract url: string\n  public abstract draw(e: Enemy, playerCoordinates: Point): void\n\n  public load(callback: () => void): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      this.spriteSheet = new Image()\n      this.spriteSheet.src = this.url\n      this.spriteSheet.onload = () => {\n        callback()\n        resolve()\n      }\n    })\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport CreatureState from '@app/domain/CreatureState'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nimport CreatureSprite from './CreatureSprite'\n\nexport default class SpriteZerg extends CreatureSprite {\n  public url: string = './graphics/spritesheets/zergling.png'\n\n  public numberOfSpritesInAnimation = {\n    walking: 7,\n    attacking: 5,\n  }\n\n  private spriteLocations: { [key: string]: { col: number, flip: boolean } } = {\n    N : { col: 0, flip: false },\n    NE: { col: 2, flip: false },\n    E : { col: 4, flip: false },\n    SE: { col: 6, flip: false },\n    S : { col: 8, flip: false },\n    SW: { col: 6, flip: true  },\n    W : { col: 4, flip: true  },\n    NW: { col: 2, flip: true  },\n  }\n  private spriteSize = 32\n  private spriteStep: Point\n\n  constructor() {\n    super()\n    this.spriteStep = { x: this.spriteSize + 11, y: this.spriteSize + 10 }\n  }\n\n  public draw(enemy: Enemy, playerCoordinates: Point) {\n    const spriteOffsets: Point = this.getSpriteOffsets(enemy.state, this.spriteStep)\n\n    const spriteLocation = this.spriteLocations[enemy.direction]\n\n    this.drawSprite(enemy, playerCoordinates, spriteOffsets, spriteLocation)\n  }\n\n  private getSpriteOffsets(enemyState: CreatureState, SPRITE_STEP: Point) {\n    switch (enemyState) {\n      case CreatureState.Moving:\n      case CreatureState.Idling:\n        return {\n          x: 7,\n          y: 5\n        }\n      case CreatureState.Attacking:\n        const ATTACK_SPRITES_ROW = 7\n        return {\n          x: 7,\n          y: 5 + (ATTACK_SPRITES_ROW * SPRITE_STEP.y)\n        }\n    }\n  }\n\n  private drawSprite(\n    enemy: Enemy,\n    playerCoordinates: Point,\n    spriteOffsets: Point,\n    spriteLocation: { col: number, flip: boolean },\n  ) {\n\n    const { x, y, collisionBox: cBox } = enemy\n    const { x: px, y: py } = playerCoordinates\n\n    if (spriteLocation.flip) {\n      context.save()\n      context.translate(\n        Canvas.center.x + (x - px - cBox.halfWidth),\n        Canvas.center.y + (y - py - cBox.halfHeight),\n      )\n      context.scale(-1, 1)\n    }\n\n    context.drawImage(\n      this.spriteSheet,\n      spriteOffsets.x + this.spriteStep.x * spriteLocation.col,\n      spriteOffsets.y + this.spriteStep.y * Math.floor(enemy.animationPosition),\n      this.spriteSize,\n      this.spriteSize,\n      spriteLocation.flip ? 0 - this.spriteSize / 2 : Canvas.center.x + (x - px - cBox.halfWidth),  // Canvas Desination X\n      spriteLocation.flip ? 0                       : Canvas.center.y + (y - py - cBox.halfHeight), // Canvas Desination Y\n      enemy.collisionBox.width  + 2, // Draw width\n      enemy.collisionBox.height + 2, // Draw height\n    )\n\n    if (spriteLocation.flip) {\n      context.restore()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    // TODO: Just a development warning, remove this in production\n    if (CONFIG.THROW_DEVELOPMENT_ERRORS) {\n      if (width % 2 !== 0 || height % 2 !== 0) {\n        throw new Error('Always use even numbers for collision box dimensions!')\n      }\n    }\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n\nexport interface ICollidable {\n  x: number\n  y: number\n  collisionBox: CollisionBox\n}\n\nexport function collisionBoxesIntersect(a: ICollidable, b: ICollidable): boolean {\n  return (\n    a.x - a.collisionBox.halfWidth  < b.x + b.collisionBox.halfWidth  &&\n    a.x + a.collisionBox.halfWidth  > b.x - b.collisionBox.halfWidth  &&\n    a.y - a.collisionBox.halfHeight < b.y + b.collisionBox.halfHeight &&\n    a.y + a.collisionBox.halfHeight > b.y - b.collisionBox.halfHeight\n  )\n}","export enum Directions {\n  N  = 'N',\n  NE = 'NE',\n  E  = 'E',\n  SE = 'SE',\n  S  = 'S',\n  SW = 'SW',\n  W  = 'W',\n  NW = 'NW',\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nlet lastFrameTime: number\nlet frameElapsedTime: number\n\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\n\nexport default class FrameRate {\n\n  public static restart() {\n    lastFrameTime = null\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(): void {\n    if (!lastFrameTime) {\n      lastFrameTime = performance.now()\n      FPS = 0\n    } else {\n      const now = performance.now()\n      frameElapsedTime = (now - lastFrameTime)\n\n      FPS_ARR.unshift(1000 / frameElapsedTime)\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n\n      lastFrameTime = now\n    }\n  }\n\n  public static drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","\nenum GameAssets {\n  Graphics,\n  Audio,\n}\n\nexport default GameAssets","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox, { collisionBoxesIntersect } from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport RaycastablePoint from './geometry/RaycastablePoint'\n\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): PathNode[] {\n  const path: PathNode[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!gameObjects[row] || !gameObjects[row][col]) {\n        if (col > 0 && row > 0) {\n          path.push(new PathNode({\n            x: col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n            y: row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n          }, cBox))\n        }\n      }\n    }\n  }\n\n  return path\n}\n\nexport function drawPathNodes(path: PathNode[], player: Player, color: string): void {\n  if (path) {\n    path.forEach(node => drawNode(node, player, color))\n  }\n}\n\nexport function drawNode(node: PathNode, player: Player, color: string): void {\n  context.strokeStyle = color\n  context.lineWidth = 0.1\n  context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // optimize/cache the vertex calculations.\n    context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n  context.stroke()\n\n  context.beginPath()\n    context.arc(\n      Canvas.center.x + (node.x - player.x),\n      Canvas.center.y + (node.y - player.y),\n      1,\n      0,\n      (2 * Math.PI)\n    )\n  context.stroke()\n}\n\nexport function findShortestPath(enemy: Enemy, player: Player, pathfindingNodes: PathNode[]): PathNode[] {\n  const nodeGoal  = new PathNode(player, player.collisionBox)\n  const nodeStart = new PathNode(enemy,  enemy.collisionBox)\n\n  pathfindingNodes.push(nodeGoal)\n\n  nodeStart.f = 0\n  nodeStart.g = nodeStart.heuristic(nodeGoal)\n\n  const nodesNotTested: PathNode[] = [ nodeStart ]\n\n  let nodeCurrent: PathNode\n\n  while (nodesNotTested.length > 0 || nodeCurrent === nodeGoal) {\n    nodesNotTested.sort((a: PathNode, b: PathNode) => a.g - b.g)\n\n    while (nodesNotTested.length > 0 && nodesNotTested[0].visited === true) {\n      nodesNotTested.shift()\n    }\n\n    if (nodesNotTested.length <= 0) {\n      break\n    }\n\n    nodeCurrent = nodesNotTested.shift()\n    nodeCurrent.visited = true\n\n    // Get neighbour nodes.\n    nodeCurrent.neighbourNodes = [ ...pathfindingNodes ]\n      .filter(node => {\n        return (\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row    ) || // Center\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row - 1) || // N\n          (node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row    ) || // E\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row + 1) || // S\n          (node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row    ) || // W\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row - 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col + 1] === null ||\n              !gameObjects[node.row + 1] || gameObjects[node.row + 1][node.col    ] === null\n            )\n          ) || // NW\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row - 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col - 1] === null ||\n              !gameObjects[node.row + 1] || gameObjects[node.row + 1][node.col    ] === null\n            )\n          ) || // NE\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row + 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col - 1] === null ||\n              !gameObjects[node.row - 1] || gameObjects[node.row - 1][node.col    ] === null\n            )\n          ) || // SE\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row + 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col + 1] === null ||\n              !gameObjects[node.row - 1] || gameObjects[node.row - 1][node.col    ] === null\n            )\n          ) // SW\n        )\n      })\n\n    nodeCurrent.neighbourNodes\n      .map(node => {\n        if (node.visited === false) {\n          nodesNotTested.push(node)\n        }\n\n        // Calculate local goal\n        const possiblyLowerLocalGoal = nodeCurrent.f + pointToPointDistance(nodeCurrent, node)\n\n        if (possiblyLowerLocalGoal < node.f) {\n          node.parent = nodeCurrent\n          node.f = possiblyLowerLocalGoal\n          node.g = node.f + node.heuristic(nodeGoal)\n        }\n\n        return node\n      })\n  }\n\n  const path = []\n  if (nodeGoal.parent) {\n    let n: PathNode = nodeGoal\n    while (n.parent) {\n      path.push(n)\n      n = n.parent\n    }\n  }\n  return path\n}\n\nexport class PathNode implements RaycastablePoint {\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  public visited: boolean = false\n  public g: number = Infinity // Global goal\n  public f: number = Infinity // Local goal\n  public parent: PathNode = null\n  public neighbourNodes: PathNode[]\n\n  constructor(coordinates: Point, cBox: CollisionBox) {\n    this.x = coordinates.x\n    this.y = coordinates.y\n    this.collisionBox = new CollisionBox(cBox.width, cBox.height)\n    this.updateTileDeltas()\n    this.updateMapPosition()\n  }\n\n  public heuristic(nodeGoal: PathNode): number {\n    return pointToPointDistance(this, nodeGoal)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { angleBetweenPoints, updatePointRowAndColValues, updatePointDeltas } from '@app/infrastructure/geometry/Point'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport RaycastablePoint from './geometry/RaycastablePoint'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { PathNode } from './Pathfinding'\nimport Player from '@app/domain/player/Player'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(\n    p: RaycastablePoint,\n    theta: number,\n    pEnd?: RaycastablePoint\n  ): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta, pEnd)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta, pEnd)\n      }\n    } else { // North\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta, pEnd)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta, pEnd)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  public static determineIfThereAreObstaclesBetweenTwoPoints(p1: RaycastablePoint, p2: RaycastablePoint): boolean {\n    const angleBetweenTwoGivenPoints = angleBetweenPoints(p2, p1)\n    const results = Raycaster.cast(p1, angleBetweenTwoGivenPoints, p2)\n\n    // I have to check if results exist because sometimes .cast() can return 'undefined'..\n    // Why .cast() sometimes returns 'undefined' could be worth investigating in the future..\n    if (results) {\n      return results.hitObject !== null\n    }\n    else {\n      return true\n    }\n  }\n\n  // This function is very computationaly expensive, see if it can be optimized\n  public static determineIfThereAreObstaclesBetweenTwoPathNodes(n1: PathNode | Enemy, n2: PathNode | Player) {\n    const angleBetweenNodes: number = +angleBetweenPoints(n2, n1).toFixed(2)\n\n    if (angleBetweenNodes === 0) { // 0deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > 0 && angleBetweenNodes < Math.PI / 2) { // between 0deg and 90deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === (Math.PI / 2)) { // 90deg\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > Math.PI / 2 && angleBetweenNodes < Math.PI) { // between 90deg and 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (Math.abs(angleBetweenNodes) === 3.14) { // 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI && angleBetweenNodes < -Math.PI / 2) { // between 180deg and 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === -1.57) { // 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI / 2 && angleBetweenNodes < 0) { // between 270deg and 360deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n  }\n\n  private static outsideOfScreenOffset = CONFIG.TILE_SIZE * 2\n  private static rangeHorizontal: number = Canvas.halfWidth  + Raycaster.outsideOfScreenOffset\n  private static rangeVertical: number   = Canvas.halfHeight + Raycaster.outsideOfScreenOffset * 2\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyBottom > (pEnd.y - p.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y - tileStepY - p.deltas.dyTop,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (p.x - pEnd.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - xIntercept,\n            y: Canvas.center.y - p.deltas.dyTop - tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (-xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if ((tileStepY + p.deltas.dyBottom > (pEnd.y - p.y)) || (-xIntercept > (p.x - pEnd.x))) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const xTile_leftByOnePixel = p.col + Math.floor((p.deltas.dxLeft + xIntercept - 1) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile][xTile_leftByOnePixel]) {\n        gameObjectHit = gameObjects[yTile][xTile_leftByOnePixel]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n\nconst blankVertex: Point = {\n  x: 0,\n  y: 0,\n  deltas: {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  },\n}\nconst vertexNW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\n\nfunction getVerticesNW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexNW1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNW1.row = Math.floor(vertexNW1.y / CONFIG.TILE_SIZE)\n  vertexNW1.col = Math.floor(vertexNW1.x / CONFIG.TILE_SIZE)\n  vertexNW1.deltas.dyTop = vertexNW1.y % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW1.deltas.dyTop\n  vertexNW1.deltas.dxLeft = vertexNW1.x % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW1.deltas.dxLeft\n\n  vertexNW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexNW2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNW2.row = Math.floor(vertexNW2.y / CONFIG.TILE_SIZE)\n  vertexNW2.col = Math.floor(vertexNW2.x / CONFIG.TILE_SIZE)\n  vertexNW2.deltas.dyTop = vertexNW2.y % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW2.deltas.dyTop\n  vertexNW2.deltas.dxLeft = vertexNW2.x % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW2.deltas.dxLeft\n\n  return [ vertexNW1, vertexNW2 ]\n}\n\nfunction getVerticesNE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexNE1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNE1.row = Math.floor(vertexNE1.y / CONFIG.TILE_SIZE)\n  vertexNE1.col = Math.floor(vertexNE1.x / CONFIG.TILE_SIZE)\n  vertexNE1.deltas.dyTop = vertexNE1.y % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE1.deltas.dyTop\n  vertexNE1.deltas.dxLeft = vertexNE1.x % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE1.deltas.dxLeft\n\n  vertexNE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexNE2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNE2.row = Math.floor(vertexNE2.y / CONFIG.TILE_SIZE)\n  vertexNE2.col = Math.floor(vertexNE2.x / CONFIG.TILE_SIZE)\n  vertexNE2.deltas.dyTop = vertexNE2.y % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE2.deltas.dyTop\n  vertexNE2.deltas.dxLeft = vertexNE2.x % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE2.deltas.dxLeft\n\n  return [ vertexNE1, vertexNE2 ]\n}\n\nfunction getVerticesSW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexSW1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSW1.row = Math.floor(vertexSW1.y / CONFIG.TILE_SIZE)\n  vertexSW1.col = Math.floor(vertexSW1.x / CONFIG.TILE_SIZE)\n  vertexSW1.deltas.dyTop = vertexSW1.y % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW1.deltas.dyTop\n  vertexSW1.deltas.dxLeft = vertexSW1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW1.deltas.dxLeft\n\n  vertexSW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexSW2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSW2.row = Math.floor(vertexSW2.y / CONFIG.TILE_SIZE)\n  vertexSW2.col = Math.floor(vertexSW2.x / CONFIG.TILE_SIZE)\n  vertexSW2.deltas.dyTop = vertexSW2.y % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW2.deltas.dyTop\n  vertexSW2.deltas.dxLeft = vertexSW2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW2.deltas.dxLeft\n\n  return [ vertexSW1, vertexSW2 ]\n}\n\nfunction getVerticesSE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexSE1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSE1.row = Math.floor(vertexSE1.y / CONFIG.TILE_SIZE)\n  vertexSE1.col = Math.floor(vertexSE1.x / CONFIG.TILE_SIZE)\n  vertexSE1.deltas.dyTop = vertexSE1.y % CONFIG.TILE_SIZE\n  vertexSE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE1.deltas.dyTop\n  vertexSE1.deltas.dxLeft = vertexSE1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE1.deltas.dxLeft\n\n  vertexSE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexSE2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSE2.row = Math.floor(vertexSE2.y / CONFIG.TILE_SIZE)\n  vertexSE2.col = Math.floor(vertexSE2.x / CONFIG.TILE_SIZE)\n  vertexSE2.deltas.dyTop = vertexSE2.y % CONFIG.TILE_SIZE\n  vertexSE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE2.deltas.dyTop\n  vertexSE2.deltas.dxLeft = vertexSE2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE2.deltas.dxLeft\n\n  return [ vertexSE1, vertexSE2 ]\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport AudioLoader from '@app/audio/AudioLoader'\nimport GraphicsLoader from '@app/graphics/GraphicsLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport FrameRate from '../FrameRate'\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0\n  public static loadedPercentages: Map<GameAssets, { loaded: number, weight: number }> = new Map()\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  public static togglePause(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PAUSED) {\n      Game.stateManager.setState(GAME_STATES.PLAYING)\n    } else {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n  }\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n\n    Game.loadedPercentages.set(GameAssets.Graphics, { weight: 0.3, loaded: 0.0 })\n    Game.loadedPercentages.set(GameAssets.Audio,    { weight: 0.7, loaded: 0.0 })\n\n    AudioLoader.load(   percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n    GraphicsLoader.load(percentage => this.gameAssetLoaded(GameAssets.Graphics, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop()\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const assetValue = Game.loadedPercentages.get(asset)\n    assetValue.loaded = percentage\n    Game.loadedPercentages.set(asset, assetValue)\n\n    Game.loadedPercentage = 0\n    for (const [_key, value] of Game.loadedPercentages) {\n      Game.loadedPercentage += value.loaded * value.weight\n    }\n\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private toggleRender = true\n\n  private gameLoop(): void {\n    if (this.toggleRender) {\n      this.update()\n      this.render()\n\n      FrameRate.calculateFrameRate()\n    }\n    this.toggleRender = !this.toggleRender\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  // private gameLoop(): void {\n  //   this.update()\n  //   this.render()\n\n  //   FrameRate.calculateFrameRate()\n\n  //   window.requestAnimationFrame(() => this.gameLoop())\n  // }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    if (CONFIG.DEBUG.FPS) {\n      FrameRate.drawFPS()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationCounter: number = 0\n  private animationPosition: number = 100\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationCounter = (this.animationCounter + 1) % this.animationPosition\n    if (this.animationCounter >= this.animationPosition / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press any key to start', CONFIG.CANVAS_WIDTH / 2 - 132, CONFIG.CANVAS_HEIGHT / 2 - 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection(): void {\n    Game.stateManager.setState(GAME_STATES.PLAYING)\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePlaying implements IGameState {\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n  }\n\n  public exit(nextState: IGameState): void {\n    if (nextState !== GAME_STATES.PAUSED) {\n      window.onblur = null\n    }\n  }\n\n  public update(): void {\n    Canvas.updateMousePosition()\n    Gamepads.update(this.player)\n    this.player.update()\n    this.map.update()\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n  }\n\n  private startNewGame(): void {\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n}\n","import GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStatePaused from './GameStatePaused'\n\n// TODO: Add a IGameState type definition\nconst GAME_STATES = {\n  LOADING   : new GameStateLoading(),\n  MAIN_MENU : new GameStateMainMenu(),\n  PLAYING   : new GameStatePlaying(),\n  PAUSED    : new GameStatePaused(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nexport default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}\n\nexport function updatePointRowAndColValues(p: Point): void {\n  p.row = Math.floor(p.y / CONFIG.TILE_SIZE)\n  p.col = Math.floor(p.x / CONFIG.TILE_SIZE)\n}\n\nexport function updatePointDeltas(p: Point): void {\n  p.deltas.dyTop = p.y % CONFIG.TILE_SIZE\n  p.deltas.dyBottom = CONFIG.TILE_SIZE - p.deltas.dyTop\n  p.deltas.dxLeft = p.x % CONFIG.TILE_SIZE\n  p.deltas.dxRight = CONFIG.TILE_SIZE - p.deltas.dxLeft\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","import Game from '@app/infrastructure/game/Game'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    document.addEventListener('keydown', e => {\n      // TODO: Move Player logic to Player class\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.ESC:\n        case KEYBOARD_KEYS.p:\n          Game.togglePause()\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n"],"names":["URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","buffer","send","context","AudioContext","static","loadCallback","load","Mixer","musicVolume","this","_musicVolume","vol","soundFxVolume","_soundFxVolume","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","all","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","SMG_INDEX","gainNode","createGain","gain","value","connect","destination","start","length","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","prevX","prevY","maxHealth","state","Idling","previousState","animationPosition","moving","left","right","up","down","blocked","deltas","dyTop","dyBottom","dxLeft","dxRight","resetMoving","resetBlocked","calculateNextCoordinates","nextX","x","nextY","y","maxSpeedDiagonal","maxSpeed","checkIfBlockedByCreature","c","nextCreatureState","collisionBoxesIntersect","intersectionX","intersectionY","collisionBox","halfWidth","halfHeight","adjustCollisionWithGameObjects","o","gameObjects","row","col","mapX","width","SWVertexRow","Math","floor","CONFIG","TILE_SIZE","NWVertexRow","SEVertexRow","NEVertexRow","mapY","height","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","updatePreviousCoordinates","push","shift","updateDirection","direction","dx","dy","Directions","S","N","E","W","directionString","join","checkIfMoving","xUnchanged","yUnchanged","initializeHealth","healthPercentage","health","getHealthColor","resetAnimation","setState","newState","CreatureState","rows","CANVAS_HEIGHT","cols","CANVAS_WIDTH","ConcreteEnemy","constructor","pathfindingInterval","super","sprite","Zerg","attackSpeed","updateMapPosition","update","player","enemies","Dying","Decaying","target","stuck","checkIfStuck","Attacking","checkForCollisionWithPlayer","checkForCollisionWithOtherEnemies","distanceFromTarget","pointToPointDistance","targetIsInRange","targetInRange","resetAttackCooldown","attack","Moving","thereAreObstaclesBetweenPlayerAndThisEnemy","determineIfThereAreObstaclesBetweenTwoPathNodes","findPathToPlayer","shortestPath","move","updateTileDeltas","stateManager","getState","PLAYING","advanceAnimation","draw","DEBUG","ENEMY_COLLISION_BOX","drawCollisionBox","ENEMY_STATE","drawStateDebug","RAY_TO_PLAYER","drawRayToPlayer","PATHFINDING_NODES","drawPathNodes","pathfindingNodes","SHORTEST_PATH_TO_PLAYER","drawShortestPathToPlayer","takeDamage","damageAmount","playEnemyHit","die","playEnemyDeath","numberOfSpritesInAnimation","attacking","walking","generatePathNodes","round","abs","findShortestPath","pathfindingPeriod","followTheShortestPath","moveTowardsPlayer","nextNodeX","nextNodeY","pop","moveTowards","strokeStyle","lineWidth","beginPath","moveTo","center","lineTo","stroke","font","fillText","toString","p","forEach","n","i","drawNode","visited","node","drawRayFromPointToPoint","p1","p2","Enemy","sin","attackCooldown","isOnScreen","playerX","playerY","offScreenOffset","nextEnemyState","getEnemiesOnScreen","e","sumOfCollisionBoxHalfDiagonals","sqrt","xIsStatic","every","yIsStatic","playSMG","dealDamage","getDamage","filter","grid","loadMap","Map01","splice","drawGameObjects","offsetLeft","colRemainder","offsetTop","rowRemainder","rowStart","halfRows","colStart","halfCols","gameObject","map","createGameObject","MapKeys","mapKey","startsWith","color","destructable","isBox","createBox","Box","playCrateHit","BoxGray","BoxGreen","BoxBlue","Error","canvasX","mousePosition","canvasY","offsetX","offsetY","Player","alive","rotation","sightLineLength","shooting","shootingCooldown","projectiles","checkForCollisionWithEnemies","shoot","theta","calculateTheta","drawPlayer","drawPlayerVisionRay","PLAYER_VISION_RAY_SHOTGUN","drawProjectiles","xVel","yVel","FEATURES","SCATTER_PROJECTILES","randomFactorX","random","randomFactorY","setShooting","isShooting","angleBetweenPoints","fillStyle","toFixed","cos","PLAYER_COLLISION_BOX","hitPoint","hitObject","cast","drawRay","nextPlayerState","enemiesOnScreen","some","directionX","directionY","speed","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithGameObject","arc","PI","intermediateIntervalX","intermediateIntervalY","point","Sprites","callback","_reject","spriteSheet","Image","src","url","SpriteZerg","spriteLocations","flip","NE","SE","SW","NW","spriteSize","spriteStep","enemy","playerCoordinates","spriteOffsets","getSpriteOffsets","spriteLocation","drawSprite","enemyState","SPRITE_STEP","cBox","px","py","save","translate","scale","drawImage","restore","canvas","document","getElementById","style","SCALE","getContext","Canvas","clearRect","getCanvasDomElement","THROW_DEVELOPMENT_ERRORS","a","b","lastFrameTime","frameElapsedTime","FPS_ARR","FPS","now","performance","unshift","reduce","sum","current","GameAssets","startRow","startCol","path","rowEnd","colEnd","PathNode","nodeGoal","nodeStart","f","g","heuristic","nodesNotTested","nodeCurrent","sort","neighbourNodes","possiblyLowerLocalGoal","parent","coordinates","Infinity","Raycaster","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","angleBetweenTwoGivenPoints","results","n1","n2","angleBetweenNodes","vNE1","vNE2","getVerticesNE","determineIfThereAreObstaclesBetweenTwoPoints","vSE1","vSE2","getVerticesSE","vSW1","vSW2","getVerticesSW","vNW1","vNW2","getVerticesNW","yIntercept","tileStepX","hitPointVertical","objectHitVertical","rangeHorizontal","rangeVertical","RAYCASTER","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","checkGameObjectCollisionHorizontalSE","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","yTile_aboveByOnePixel","gameObjectHit","xTile_leftByOnePixel","outsideOfScreenOffset","blankVertex","vertexNW1","vertexNW2","vertexNE1","vertexNE2","vertexSW1","vertexSW2","vertexSE1","vertexSE2","Game","toggleRender","window","onfocus","restart","loadedPercentages","set","Graphics","weight","loaded","Audio","percentage","gameAssetLoaded","PAUSED","loadInterval","setInterval","clearInterval","MAIN_MENU","gameLoop","asset","assetValue","get","loadedPercentage","_key","render","calculateFrameRate","requestAnimationFrame","clear","drawFPS","Map","enter","exit","drawLoadingDialog","animationCounter","instructionsVisible","addEventListener","handleMenuSelection","removeEventListener","drawMainMenu","currentState","LOADING","nextState","drawPauseMenu","startNewGame","onblur","updateMousePosition","init","GAME_STATES","atan2","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","keyCode","KEYBOARD_KEYS","w","s","d","ESC","togglePause","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","preventDefault","pageX","pageY","innerWidth","innerHeight","ENTER","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__"],"sourceRoot":""}
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/infrastructure/Canvas.ts","webpack:///./src/app/domain/Map.ts","webpack:///./src/app/peripherals/Mouse.ts","webpack:///./src/app/audio/SoundFX.ts","webpack:///./src/app/audio/AudioContext.ts","webpack:///./src/main.ts","webpack:///./src/app/infrastructure/Game.ts","webpack:///./src/app/infrastructure/Raycaster.ts","webpack:///./src/app/domain/factories/BoxFactory.ts","webpack:///./src/app/infrastructure/objects/primitives/Box.ts","webpack:///./src/app/infrastructure/objects/GameObject.ts","webpack:///./src/app/peripherals/Keyboard.ts","webpack:///./src/app/domain/Grid.ts","webpack:///./src/app/domain/Player.ts","webpack:///./src/app/domain/Projectile.ts","webpack:///./src/app/audio/Mixer.ts","webpack:///./src/app/audio/AudioBufferLoader.ts","webpack:///./src/app/audio/AudioLoader.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","Raycaster_1","Mouse_1","canvas","document","getElementById","width","CANVAS_WIDTH","height","CANVAS_HEIGHT","style","SCALE","context","getContext","Canvas","[object Object]","clearRect","box","strokeStyle","color","lineWidth","beginPath","moveTo","x","y","lineTo","TILE_SIZE","stroke","theta","Math","atan2","this","getCanvasMouseY","center","getCanvasMouseX","fillStyle","fillText","font","sightLineLength","cos","sin","canvasX","canvasY","offsetX","offsetY","hitPoint","hitObject","default","cast","drawRay","projectiles","playerX","playerY","forEach","arc","PI","rows","floor","cols","halfRows","halfCols","rowRemainder","colRemainder","getCanvasDomElement","offsetLeft","offsetTop","Canvas_1","BoxFactory_1","Map01","gameObjects","grid","player","loadMap","deltas","dxLeft","dyTop","rowStart","row","colStart","col","gameObject","draw","map","length","createBox","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","window","addEventListener","e","preventDefault","pageX","pageY","setShooting","Mixer_1","AudioContext_1","AudioBufferLoader_1","SoundFX","SMG","load","playSound","createBufferSource","buffer","SMG_INDEX","gainNode","createGain","gain","soundFxVolume","connect","destination","start","AudioContext","Keyboard_1","Grid_1","Map_1","Player_1","init","requestAnimationFrame","gameLoop","update","render","clear","Raycaster","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","dyBottom","getInterceptPointSE","getInterceptPointSW","yIntercept","tileStepX","hitPointVertical","objectHitVertical","dxRight","RAYCASTER","DEBUG","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","checkGameObjectCollisionHorizontalSE","sqrt","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","gameObjectHit","Box_1","destructable","GameObject_1","drawBox","mapX","mapY","keyCode","moving","up","left","down","right","Projectile_1","SoundFX_1","rotation","maxSpeed","shooting","shootingCooldown","updateMapPosition","move","updateTileDeltas","shoot","alive","splice","adjustCollisionWithGameObjects","canvasMouseX","canvasMouseY","dx","dy","xVel","abs","yVel","randomFactorX","random","randomFactorY","push","playSMG","calculateTheta","drawPlayer","drawPlayerVisionRay","drawCrosshair","drawProjectiles","isShooting","directionX","directionY","speed","Mixer","musicVolume","_musicVolume","vol","_soundFxVolume","URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Player from '@app/domain/Player'\nimport Projectile from '@app/domain/Projectile'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport Mouse from '@app/peripherals/Mouse'\nimport Box from './objects/primitives/Box'\nimport Point from './geometry/Point'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n\n  public static center: { x: number, y: number } = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  // TODO: Move to Box.draw()\n  public static drawBox(box: Box): void {\n    context.strokeStyle = box.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + box.x,                     0.5 + box.y)\n      context.lineTo(-0.5 + box.x + CONFIG.TILE_SIZE,  0.5 + box.y)\n      context.lineTo(-0.5 + box.x + CONFIG.TILE_SIZE, -0.5 + box.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + box.x                   , -0.5 + box.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + box.x,                     0.5 + box.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + box.x,                     0.5 + box.y)\n      context.lineTo(-0.5 + box.x + CONFIG.TILE_SIZE, -0.5 + box.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + box.x + CONFIG.TILE_SIZE,  0.5 + box.y)\n      context.lineTo( 0.5 + box.x,                    -0.5 + box.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public static calculateTheta(p: Player): number {\n    const theta = Math.atan2(\n      (this.getCanvasMouseY() - this.center.y),\n      (this.getCanvasMouseX() - this.center.x)\n    )\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta}`, 10, 56)\n    return theta\n  }\n  \n  public static drawPlayer(p: Player, theta: number) {\n    context.beginPath()\n      context.fillStyle = '#00AA00'\n      context.font = \"10px Monospace\"\n\n      context.fillText(`p (${p.x}, ${p.y})`, 10, 20)\n\n      context.strokeStyle = '#523DA5'\n      context.lineWidth = 2\n      context.moveTo(this.center.x, this.center.y)\n      context.lineTo(this.center.x + (p.sightLineLength * Math.cos(theta)), this.center.y + (p.sightLineLength * Math.sin(theta)))\n    context.stroke()\n  }\n\n  public static drawCrosshair(): void {\n    const canvasX: number = Canvas.getCanvasMouseX()\n    const canvasY: number = Canvas.getCanvasMouseY()\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n\n  public static drawPlayerVisionRay(p: Player, theta: number): void {\n    const { hitPoint, hitObject } = Raycaster.cast(p, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        this.drawRay(hitPoint, '#FF4444')\n      } else {\n        this.drawRay(hitPoint)\n      }\n    }\n  }\n\n  public static drawProjectiles(projectiles: Projectile[], playerX: number, playerY: number) {\n    context.fillStyle = '#FFFFFF'\n    context.lineWidth = 1\n    projectiles.forEach(p => {\n      context.beginPath()\n      context.arc(\n        p.x + this.center.x - playerX,\n        p.y + this.center.y - playerY,\n        2,\n        0,\n        (2 * Math.PI)\n      )\n      context.stroke()\n    })\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n  // TODO: Optimize by not calculating this many times\n  public static getCanvasMouseX = (): number => Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE)\n  public static getCanvasMouseY = (): number => Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n\n  private static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(this.center.x, this.center.y)\n      context.lineTo(\n        this.center.x + hitPoint.x,\n        this.center.y + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/Player'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/infrastructure/objects/GameObject'\nimport BoxFactory from '@app/domain/factories/BoxFactory'\n\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: Array<GameObject[]> = []\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public draw(): void {\n    let offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    let offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: number[][]): void {\n    for (let row = 0; row < map.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map[row].length; ++col) {\n        switch (map[row][col]) {\n          case 1:\n            gameObjects[row][col] = BoxFactory.createBox('#4B4B4B', row, col, false)\n            break\n          case 2:\n            gameObjects[row][col] = BoxFactory.createBox('#27531B', row, col)\n            break\n          case 3:\n            gameObjects[row][col] = BoxFactory.createBox('#572F17', row, col)\n            break\n          default:\n            gameObjects[row][col] = null\n        }\n      }\n    }\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/Player'\n\nexport default class Mouse {\n\tpublic static x: number = 0\n\tpublic static y: number = 0\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n\t\t\tthis.x = e.pageX\n\t\t\tthis.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  public static async load(): Promise<void> {\n    this.SMG[0] = await load('./audio/smg_1.wav')\n    this.SMG[1] = await load('./audio/smg_2.wav')\n    this.SMG[2] = await load('./audio/smg_3.wav')\n    this.SMG[3] = await load('./audio/smg_4.wav')\n    this.SMG[4] = await load('./audio/smg_5.wav')\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import Game from '@app/infrastructure/Game'\n\nconst game: Game = new Game()\ngame.start()\n","import Canvas from '@app/infrastructure/Canvas'\nimport Mouse from '@app/peripherals/Mouse'\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/Map'\nimport Player from '@app/domain/Player'\nimport AudioLoader from '@app/audio/AudioLoader'\n\n// Load all assets\nAudioLoader.load()\n\n// Initialize the game\nconst grid: Grid = new Grid()\nconst player: Player = new Player(128, 64)\nconst map: Map = new Map(grid, player)\n\nKeyboard.init(player)\nMouse.init(player)\n\nexport default class Game {\n  public start(): void {\n\t\twindow.requestAnimationFrame(() => this.gameLoop())\n  }\n\n\tprivate gameLoop(): void {\n\t\tthis.update()\n\t\tthis.render()\n\t\twindow.requestAnimationFrame(() => this.gameLoop())\n\t}\n\n  private update(): void {\n    player.update()\n  }\n\n  private render(): void {\n\t  Canvas.clear()\n    map.draw()\n    player.draw()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Player from '@app/domain/Player'\nimport GameObject from '@app/infrastructure/objects/GameObject'\nimport { gameObjects } from '@app/domain/Map'\n\n// DEBUG: context - only for debugging\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Raycaster {\n  /**\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   // TODO: Make the hit point the edge of the screen in worst case so the player can't see what's beyond (+ some offset maybe if you want the player to see beyond)\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const yInt = p.deltas.dyBottom\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta)\n      }\n    } else { // North\n      const yInt = p.deltas.dyTop\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta)\n      }\n      else {\n        return Raycaster.getInterceptPointNW(p, theta)\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + p.deltas.dxRight + tileStepX,\n          Canvas.center.y + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + tileStepX + p.deltas.dxRight,\n          Canvas.center.y - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static getInterceptPointNW(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - tileStepX - p.deltas.dxLeft,\n          Canvas.center.y - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - xIntercept,\n          Canvas.center.y - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - p.deltas.dxLeft - tileStepX,\n          Canvas.center.y + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.center.y) || (-xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n","import * as CONFIG from '../../configuration/config.json'\n\nimport Box from '@app/infrastructure/objects/primitives/Box'\n\nexport default class BoxFactory {\n  public static createBox(color: string, row: number, col: number, destructable: boolean = true): Box {\n    return new Box(\n      color,\n      row,\n      col,\n      CONFIG.TILE_SIZE,\n      CONFIG.TILE_SIZE,\n      destructable,\n    )\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    Canvas.drawBox(this)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public color: string,\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n}\n","import Player from '@app/domain/Player'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    // TODO: Move Player logic to Player class\n    document.addEventListener('keydown', e => {\n      switch (e.keyCode) {\n        case 87: // w\n          player.moving.up = true\n          break\n        case 65: // a\n          player.moving.left = true\n          break\n        case 83: // s\n          player.moving.down = true\n          break\n        case 68: // d\n          player.moving.right = true\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case 87: // w\n          player.moving.up = false\n          break\n        case 65: // a\n          player.moving.left = false\n          break\n        case 83: // s\n          player.moving.down = false\n          break\n        case 68: // d\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class Grid {\n  rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n","import * as CONFIG from '@app/configuration/config.json'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Projectile from '@app/domain/Projectile'\nimport { gameObjects } from '@app/domain/Map'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player {\n  public rotation: number = 0\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public row: number\n  public col: number\n  public sightLineLength = 10\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  private maxSpeed = 4\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n  )\n  {\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.move()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public move(): void {\n    if (this.moving.left) {\n      this.x -= this.maxSpeed\n    }\n    if (this.moving.right) {\n      this.x += this.maxSpeed\n    }\n    if (this.moving.up) {\n      this.y -= this.maxSpeed\n    }\n    if (this.moving.down) {\n      this.y += this.maxSpeed\n    }\n    this.adjustCollisionWithGameObjects()\n    this.updateMapPosition()\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const canvasMouseX: number = Canvas.getCanvasMouseX()\n      const canvasMouseY: number = Canvas.getCanvasMouseY()\n\n      const dx = (canvasMouseX - Canvas.center.x)\n      const dy = (canvasMouseY - Canvas.center.y)\n      let xVel = dx / ( Math.abs(dx) + Math.abs(dy) )\n      let yVel = dy / ( Math.abs(dx) + Math.abs(dy) )\n\n      // TODO: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public draw(): void {\n    const theta = Canvas.calculateTheta(this)\n    Canvas.drawPlayer(this, theta)\n    Canvas.drawPlayerVisionRay(this, theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    // Canvas.drawPlayerVisionRay(this, theta - 0.45)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.4)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.35)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.3)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.25)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.2)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.15)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.1)\n    // Canvas.drawPlayerVisionRay(this, theta - 0.05)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.05)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.1)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.15)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.2)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.25)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.3)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.35)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.4)\n    // Canvas.drawPlayerVisionRay(this, theta + 0.45)\n\n    Canvas.drawCrosshair()\n    Canvas.drawProjectiles(this.projectiles, this.x, this.y)\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Generalize collision physics\n  private adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (o = gameObjects[this.row][this.col - 1]) { // West\n        if (this.x <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + 1\n        }\n      }\n      if (o = gameObjects[this.row][this.col + 1]) { // East\n        if (this.x >= o.mapX) {\n          this.x = o.mapX - 1\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (o = gameObjects[this.row - 1][this.col]) { // North\n        if (this.y <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + 1\n        }\n      }\n      if (o = gameObjects[this.row - 1][this.col + 1]) { // North East\n        if (this.y <= o.mapY + o.height && this.x >= o.mapX) {\n          this.y = o.mapY + o.height + 1\n        }\n      }\n      if (o = gameObjects[this.row - 1][this.col - 1]) { // North West\n        if (this.y <= o.mapY + o.height && this.x <= o.mapX + o.width) {\n          this.y = o.mapY + o.height + 1\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (o = gameObjects[this.row + 1][this.col]) { // South\n        if (this.y >= o.mapY) {\n          this.y = o.mapY - 1\n        }\n      }\n      if (o = gameObjects[this.row + 1][this.col + 1]) { // South East\n        if (this.x >= o.mapX && this.y >= o.mapY) {\n          this.y = o.mapY - 1\n        }\n      }\n      if (o = gameObjects[this.row + 1][this.col - 1]) { // South West\n        if (this.x <= o.mapX + o.width && this.y >= o.mapY) {\n          this.y = o.mapY - 1\n        }\n      }\n    }\n  }\n\n}\n","import * as CONFIG from '@app/configuration/config.json'\nimport Canvas from '@app/infrastructure/Canvas'\nimport { gameObjects } from '@app/domain/Map'\n\nexport default class Projectile {\n  public speed: number = 24\n  public alive: boolean\n  constructor (\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number\n  )\n  {\n    this.alive = true\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    if (\n      this.x < playerX - Canvas.center.x || this.x > playerX + Canvas.center.x ||\n      this.y < playerY - Canvas.center.y || this.y > playerY + Canvas.center.y\n    )\n    {\n      this.alive = false\n    }\n\n    let o\n    for (let row = 0; row < gameObjects.length; ++row) {\n      for (let col = 0; col < gameObjects[row].length; ++col) {\n        o = gameObjects[row][col]\n        if (o) {\n          if (\n            this.x >= o.mapX && this.x <= o.mapX + o.width &&\n            this.y >= o.mapY && this.y <= o.mapY + o.height\n          )\n          {\n            this.alive = false\n            if (gameObjects[row][col].destructable) {\n              gameObjects[row][col] = null\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.3\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load() {\n    await SoundFX.load()\n  }\n}\n"],"sourceRoot":""}
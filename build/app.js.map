{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/infrastructure/Canvas.ts","webpack:///./src/app/infrastructure/game/Game.ts","webpack:///./src/app/infrastructure/game/game_states/GameState.ts","webpack:///./src/app/domain/map/Map.ts","webpack:///./src/app/audio/SoundFX.ts","webpack:///./src/app/peripherals/Mouse.ts","webpack:///./src/app/audio/AudioContext.ts","webpack:///./src/app/peripherals/constants/KeyCodes.ts","webpack:///./src/app/infrastructure/CollisionBox.ts","webpack:///./src/app/domain/map/MapKeys.ts","webpack:///./src/main.ts","webpack:///./src/app/audio/AudioLoader.ts","webpack:///./src/app/audio/Mixer.ts","webpack:///./src/app/audio/AudioBufferLoader.ts","webpack:///./src/app/infrastructure/FrameRate.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack:///./src/app/peripherals/Keyboard.ts","webpack:///./src/app/peripherals/Gamepads.ts","webpack:///./src/app/domain/Grid.ts","webpack:///./src/app/domain/enemies/ConcreteEnemy.ts","webpack:///./src/app/infrastructure/geometry/Point.ts","webpack:///./src/app/domain/enemies/Enemy.ts","webpack:///./src/app/domain/objects/GameObjectFactory.ts","webpack:///./src/app/domain/objects/box/BoxFactory.ts","webpack:///./src/app/domain/objects/box/Box.ts","webpack:///./src/app/domain/objects/GameObject.ts","webpack:///./src/app/domain/player/Player.ts","webpack:///./src/app/infrastructure/Raycaster.ts","webpack:///./src/app/domain/player/Crosshair.ts","webpack:///./src/app/domain/player/Projectile.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack:///./src/app/infrastructure/GameAssets.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","Mouse_1","canvas","document","getElementById","width","CANVAS_WIDTH","height","CANVAS_HEIGHT","style","SCALE","context","getContext","Canvas","[object Object]","clearRect","this","mousePosition","x","Math","floor","default","offsetLeft","y","offsetTop","rows","TILE_SIZE","cols","halfRows","halfCols","rowRemainder","colRemainder","center","getCanvasDomElement","AudioLoader_1","Canvas_1","FrameRate_1","GameState_1","GameAssets_1","Game","window","onfocus","restart","load","gameAssetLoaded","Audio","state","paused","playing","loadInterval","setInterval","loaded","clearInterval","mainMenu","gameLoop","asset","loadedPercentage","update","nextFrameRenderingShouldBeSkipped","render","calculateFrameRate","requestAnimationFrame","clear","drawFPS","loading","GameStateLoading_1","GameStateMainMenu_1","GameStatePlaying_1","GameStatePaused_1","GameState","ConcreteEnemy_1","GameObjectFactory_1","Map01","getEnemiesOnScreen","playerX","playerY","enemies","filter","e","isOnScreen","gameObjects","grid","player","loadMap","forEach","alive","splice","drawGameObjects","draw","deltas","dxLeft","dyTop","rowStart","row","colStart","col","gameObject","map","length","createGameObject","push","healthPercentage","Mixer_1","AudioContext_1","AudioBufferLoader_1","SoundFX","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","buffer","SMG_INDEX","gainNode","createGain","gain","soundFxVolume","connect","destination","start","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","addEventListener","preventDefault","pageX","pageY","setShooting","innerWidth","innerHeight","AudioContext","KEYBOARD_KEYS","ENTER","ESC","w","a","halfWidth","halfHeight","MapKeys","isBox","mapKey","startsWith","SoundFX_1","loadCallback","Mixer","musicVolume","_musicVolume","vol","_soundFxVolume","URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send","lastFrameTime","frameDeltaTime","frameOverstepTime","ONE_FRAME_LENGTH_IN_SECONDS","FPS_ARR","FPS","skipNextFrameRendering","now","performance","unshift","pop","reduce","sum","current","beginPath","fillStyle","font","fillText","toFixed","stroke","Game_1","drawLoadingDialog","KeyCodes_1","animationCounter","animationInterval","instructionsVisible","handleMenuSelection","drawMainMenu","keyCode","removeEventListener","Keyboard_1","Gamepads_1","Grid_1","Map_1","Player_1","onblur","init","moving","up","left","down","right","togglePause","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","CollisionBox_1","Point_1","Enemy_1","super","updateMapPosition","adjustCollisionWithGameObjects","moveTowardsPlayer","move","updateTileDeltas","drawCollisionBox","damageAmount","playEnemyHit","health","die","playEnemyDeath","collisionBox","mapX","SWVertexRow","dxRight","NWVertexRow","dyBottom","SEVertexRow","NEVertexRow","mapY","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","pointToPointDistance","moveTowards","maxSpeedDiagonal","maxSpeed","strokeStyle","getHealthColor","lineWidth","moveTo","lineTo","p1","p2","sqrt","maxHealth","initializeHealth","sin","abs","playerCollisionBox","MapKeys_1","BoxFactory_1","createBox","Box_1","BoxGray","BoxGreen","BoxBlue","Error","GameObject_1","color","playCrateHit","destructable","Raycaster_1","Crosshair_1","Projectile_1","rotation","sightLineLength","shooting","shootingCooldown","projectiles","shoot","dx","dy","xVel","yVel","randomFactorX","random","randomFactorY","playSMG","isShooting","theta","calculateTheta","drawPlayer","drawPlayerVisionRay","drawProjectiles","checkForCollisionWithEnemies","atan2","cos","hitPoint","hitObject","cast","drawRay","collidesWithPlayer","Raycaster","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","yIntercept","tileStepX","hitPointVertical","objectHitVertical","RAYCASTER","DEBUG","arc","PI","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","checkGameObjectCollisionHorizontalSE","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","gameObjectHit","canvasX","canvasY","offsetX","offsetY","directionX","directionY","speed","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithGameObject","intermediateIntervalX","intermediateIntervalY","point","takeDamage","getDamage","drawPauseMenu","GameAssets"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static update() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import AudioLoader from '@app/audio/AudioLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport FrameRate from '../FrameRate'\nimport IGameState from './game_states/IGameState'\nimport GameState from './game_states/GameState'\nimport GameAssets from '../GameAssets'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0 // 0.0 to 1.0\n\n  public static state: IGameState = GameState.loading\n\n  public static togglePause(): void {\n    if (Game.state === GameState.paused) {\n      Game.state = GameState.playing\n    } else {\n      Game.state = GameState.paused\n    }\n  }\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n    AudioLoader.load(() => this.gameAssetLoaded(GameAssets.Audio))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.state = GameState.mainMenu\n      }\n    }, 250)\n\n    this.gameLoop()\n  }\n\n  private gameAssetLoaded(asset: GameAssets) {\n    if (asset === GameAssets.Audio) {\n      Game.loadedPercentage += 1.0\n    }\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(): void {\n    this.update()\n\n    if (FrameRate.nextFrameRenderingShouldBeSkipped() === false) {\n      this.render()\n    }\n\n    FrameRate.calculateFrameRate()\n\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private update(): void {\n    Canvas.update()\n    Game.state.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.state.render()\n    FrameRate.drawFPS() // TODO: Remove this, used just for debugging\n  }\n}\n","import GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStatePaused from './GameStatePaused'\n\nexport default class GameState {\n  public static loading: GameStateLoading   = new GameStateLoading()\n  public static mainMenu: GameStateMainMenu = new GameStateMainMenu()\n  public static playing: GameStatePlaying   = new GameStatePlaying()\n  public static paused: GameStatePaused     = new GameStatePaused()\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport ConcreateEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport IMap from './IMap'\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\nexport const enemies: Enemy[] = []\n\nexport function getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n  return enemies.filter(e => e.isOnScreen(playerX, playerY))\n}\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public update(): void {\n    enemies.forEach((e, i) => {\n      e.update(this.player)\n      if (e.alive === false) {\n        enemies.splice(i, 1) // Remove the enemy\n      }\n    })\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map.gameObjects[row][col])\n      }\n    }\n\n    map.enemies.forEach(e => enemies.push(new ConcreateEnemy(e.x, e.y, e.healthPercentage)))\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(): Promise<void> {\n    this.SMG[0] = await load('./audio/smg_1.wav')\n    this.SMG[1] = await load('./audio/smg_2.wav')\n    this.SMG[2] = await load('./audio/smg_3.wav')\n    this.SMG[3] = await load('./audio/smg_4.wav')\n    this.SMG[4] = await load('./audio/smg_5.wav')\n\n    this.CRATE_HIT[0] = await load('./audio/crate_hit_1.wav')\n\n    this.ENEMY_HIT[0] = await load('./audio/enemy_hit_1.mp3')\n    this.ENEMY_HIT[1] = await load('./audio/enemy_hit_2.mp3')\n    this.ENEMY_HIT[2] = await load('./audio/enemy_hit_3.mp3')\n    this.ENEMY_HIT[3] = await load('./audio/enemy_hit_4.mp3')\n    this.ENEMY_HIT[4] = await load('./audio/enemy_hit_5.mp3')\n\n    this.ENEMY_DEATH[0] = await load('./audio/enemy_die_1.mp3')\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playCrateHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","export default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: () => void) {\n    await SoundFX.load()\n    loadCallback()\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nlet lastFrameTime: number\nlet frameDeltaTime: number\nlet frameOverstepTime: number = 0\n\nconst ONE_FRAME_LENGTH_IN_SECONDS = 0.01667\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\nlet skipNextFrameRendering = false\n\nexport default class FrameRate {\n  public static nextFrameRenderingShouldBeSkipped(): boolean {\n    return skipNextFrameRendering\n  }\n\n  public static restart() {\n    lastFrameTime = null\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(): void {\n    if (!lastFrameTime) {\n      lastFrameTime = performance.now()\n      FPS = 0\n    } else {\n      const now = performance.now()\n      frameDeltaTime = (now - lastFrameTime) / 1000\n      if (frameDeltaTime > ONE_FRAME_LENGTH_IN_SECONDS) {\n        frameOverstepTime += frameDeltaTime - ONE_FRAME_LENGTH_IN_SECONDS\n      }\n\n      FPS_ARR.unshift(1 / (frameDeltaTime + frameOverstepTime))\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n\n      if (frameOverstepTime >= ONE_FRAME_LENGTH_IN_SECONDS) {\n        frameOverstepTime = frameOverstepTime - ONE_FRAME_LENGTH_IN_SECONDS\n        skipNextFrameRendering = true\n      } else {\n        skipNextFrameRendering = false\n      }\n\n      lastFrameTime = now\n    }\n  }\n\n  public static drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport GameState from '@app/infrastructure/game/game_states/GameState'\nimport { context } from '@app/infrastructure/Canvas'\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes';\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationCounter: number = 0\n  private animationInterval: number = 100\n  private instructionsVisible: boolean = true\n\n  constructor() {\n    document.addEventListener('keydown', e => this.handleMenuSelection(e))\n  }\n\n  public update(): void {\n    this.animationCounter = (this.animationCounter + 1) % this.animationInterval\n    if (this.animationCounter >= this.animationInterval / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText(`Retro 2D Top-Down Game Engine`, CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press ENTER to start', CONFIG.CANVAS_WIDTH / 2 - 130, CONFIG.CANVAS_HEIGHT / 2 - 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection(e: KeyboardEvent): void {\n    if (e.keyCode === KEYBOARD_KEYS.ENTER) {\n      Game.state = GameState.playing\n      document.removeEventListener('keydown', e => this.handleMenuSelection(e))\n    }\n  }\n}\n","import IGameState from './IGameState'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GameState from '@app/infrastructure/game/game_states/GameState'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\n\nexport default class GameStatePlaying implements IGameState {\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  constructor() {\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    window.onblur = () => {\n      Game.state = GameState.paused\n    }\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n\n  public update(): void {\n    Gamepads.update(this.player)\n    this.player.update()\n    this.map.update()\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n  }\n}\n","import Game from '@app/infrastructure/game/Game'\nimport FrameRate from '@app/infrastructure/FrameRate'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    document.addEventListener('keydown', e => {\n      // TODO: Move Player logic to Player class\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.ESC:\n        case KEYBOARD_KEYS.p:\n          Game.togglePause()\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class Grid {\n  rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport { gameObjects } from '@app/domain/map/Map'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default class ConcreateEnemy extends Enemy {\n  constructor(\n    x: number,\n    y: number,\n    healthPercentage: number\n  ) {\n    super(x, y, new CollisionBox(16, 16), 1, healthPercentage)\n    this.updateMapPosition()\n  }\n\n  public update(player: Player): void {\n    this.adjustCollisionWithGameObjects()\n    this.moveTowardsPlayer(player)\n    this.move()\n    this.updateTileDeltas()\n  }\n\n  public draw(player: Player): void {\n    this.drawCollisionBox(player) // Just for debugging\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.alive = false\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight\n          }\n        }\n      }\n    }\n  }\n\n  private moveTowardsPlayer(player: Player): void {\n    const distanceFromPlayer = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x, y: this.y }\n    )\n    if (distanceFromPlayer > 1) {\n      this.moveTowards(player.x, player.y)\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private move(): void {\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n}\n","export default interface Point {\n  x: number\n  y: number\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Player from '@app/domain/player/Player'\n\nexport default abstract class Enemy {\n  public alive: boolean = true\n  public maxHealth: number = 100\n  public health: number\n\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n\n  protected maxSpeedDiagonal: number\n\n  constructor(\n    public x: number,\n    public y: number,\n    public collisionBox: CollisionBox,\n    protected maxSpeed: number,\n    healthPercentage: number\n  ) {\n    this.initializeHealth(healthPercentage)\n\n    this.maxSpeedDiagonal = Math.sin(45) * this.maxSpeed\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    return (\n      Math.abs(this.x - playerX) < (CONFIG.CANVAS_WIDTH  / 2) + CONFIG.TILE_SIZE &&\n      Math.abs(this.y - playerY) < (CONFIG.CANVAS_HEIGHT / 2) + CONFIG.TILE_SIZE\n    )\n  }\n\n  public collidesWithPlayer(playerX: number, playerY: number, playerCollisionBox: CollisionBox): boolean {\n    return (\n      this.x - this.collisionBox.halfWidth  < playerX + playerCollisionBox.halfWidth  &&\n      this.x + this.collisionBox.halfWidth  > playerX - playerCollisionBox.halfWidth  &&\n      this.y - this.collisionBox.halfHeight < playerY + playerCollisionBox.halfHeight &&\n      this.y + this.collisionBox.halfHeight > playerY - playerCollisionBox.halfHeight\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.10) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.20) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.30) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.40) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.50) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.60) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.70) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.80) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.90) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n\n  private initializeHealth(healthPercentage: number): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playCrateHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\n\nimport { gameObjects, getEnemiesOnScreen } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\nimport Game from '@app/infrastructure/game/Game'\nimport GameState from '@app/infrastructure/game/game_states/GameState'\n\nexport default class Player {\n  public alive: boolean = true\n  public rotation: number = 0\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public row: number\n  public col: number\n  public sightLineLength = 10\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  private collisionBox: CollisionBox = new CollisionBox(12, 12)\n  private maxSpeed = 3\n  private maxSpeedDiagonal = Math.sin(45) * this.maxSpeed\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n  )\n  {\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.move()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = (Canvas.mousePosition.x - Canvas.center.x)\n      const dy = (Canvas.mousePosition.y - Canvas.center.y)\n      let xVel = dx / ( Math.abs(dx) + Math.abs(dy) )\n      let yVel = dy / ( Math.abs(dx) + Math.abs(dy) )\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    // this.drawPlayerVisionRay(theta - 0.45)\n    // this.drawPlayerVisionRay(theta - 0.4)\n    // this.drawPlayerVisionRay(theta - 0.35)\n    // this.drawPlayerVisionRay(theta - 0.3)\n    // this.drawPlayerVisionRay(theta - 0.25)\n    // this.drawPlayerVisionRay(theta - 0.2)\n    // this.drawPlayerVisionRay(theta - 0.15)\n    // this.drawPlayerVisionRay(theta - 0.1)\n    // this.drawPlayerVisionRay(theta - 0.05)\n    // this.drawPlayerVisionRay(theta + 0.05)\n    // this.drawPlayerVisionRay(theta + 0.1)\n    // this.drawPlayerVisionRay(theta + 0.15)\n    // this.drawPlayerVisionRay(theta + 0.2)\n    // this.drawPlayerVisionRay(theta + 0.25)\n    // this.drawPlayerVisionRay(theta + 0.3)\n    // this.drawPlayerVisionRay(theta + 0.35)\n    // this.drawPlayerVisionRay(theta + 0.4)\n    // this.drawPlayerVisionRay(theta + 0.45)\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  private move(): void {\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.adjustCollisionWithGameObjects()\n    this.checkForCollisionWithEnemies()\n    this.updateMapPosition()\n  }\n\n  private calculateTheta(): number {\n    const theta = Math.atan2(\n      (Canvas.mousePosition.y - Canvas.center.y),\n      (Canvas.mousePosition.x - Canvas.center.x)\n    )\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n      context.fillStyle = '#00AA00'\n      context.font = '10px Monospace'\n\n      context.fillText(`p (${this.x.toFixed(2)}, ${this.y.toFixed(2)})`, 10, 20)\n\n      context.strokeStyle = '#523DA5'\n      context.lineWidth = 2\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(Canvas.center.x + (this.sightLineLength * Math.cos(theta)), Canvas.center.y + (this.sightLineLength * Math.sin(theta)))\n    context.stroke()\n\n    this.drawCollisionBox() // Just for debugging\n  }\n\n  private drawCollisionBox() {\n    context.lineWidth = 1\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x - this.collisionBox.halfWidth,  0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + this.collisionBox.halfWidth,  0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x - this.collisionBox.halfWidth,  0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach(p => p.draw(this.x, this.y))\n  }\n\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Generalize collision physics\n  private adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight\n          }\n        }\n      }\n    }\n  }\n\n  private checkForCollisionWithEnemies(): void {\n    if (getEnemiesOnScreen(this.x, this.y)\n      .filter(e => e.collidesWithPlayer(this.x, this.y, this.collisionBox))\n      .length > 0) {\n        this.die()\n      }\n  }\n\n  private die(): void {\n    this.alive = false\n    Game.state = GameState.paused\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Player from '@app/domain/player/Player'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Raycaster {\n  /**\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   // TODO: Make the hit point the edge of the screen in worst case so the player can't see what's beyond (+ some offset maybe if you want the player to see beyond)\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const yInt = p.deltas.dyBottom\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta)\n      }\n    } else { // North\n      const yInt = p.deltas.dyTop\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(\n        Canvas.center.x + hitPoint.x,\n        Canvas.center.y + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + p.deltas.dxRight + tileStepX,\n          Canvas.center.y + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + tileStepX + p.deltas.dxRight,\n          Canvas.center.y - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static getInterceptPointNW(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - tileStepX - p.deltas.dxLeft,\n          Canvas.center.y - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - xIntercept,\n          Canvas.center.y - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - p.deltas.dxLeft - tileStepX,\n          Canvas.center.y + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.center.y) || (-xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { gameObjects, enemies } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        o.takeDamage(this.getDamage())\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport GameState from './GameState'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStatePaused implements IGameState {\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GameState.playing.render()\n    this.drawPauseMenu()\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","\nenum GameAssets {\n  Audio,\n}\n\nexport default GameAssets"],"sourceRoot":""}
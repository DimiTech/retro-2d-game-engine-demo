{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/infrastructure/Canvas.ts","webpack:///./src/app/infrastructure/game/Game.ts","webpack:///./src/app/infrastructure/game/game_states/GameStates.ts","webpack:///./src/app/domain/map/Map.ts","webpack:///./src/app/audio/SoundFX.ts","webpack:///./src/app/infrastructure/geometry/Point.ts","webpack:///./src/app/infrastructure/CollisionBox.ts","webpack:///./src/app/peripherals/Mouse.ts","webpack:///./src/app/audio/AudioContext.ts","webpack:///./src/app/graphics/Sprites.ts","webpack:///./src/app/infrastructure/Raycaster.ts","webpack:///./src/app/domain/Creature.ts","webpack:///./src/app/domain/map/MapKeys.ts","webpack:///./src/main.ts","webpack:///./src/app/audio/AudioLoader.ts","webpack:///./src/app/audio/Mixer.ts","webpack:///./src/app/audio/AudioBufferLoader.ts","webpack:///./src/app/graphics/GraphicsLoader.ts","webpack:///./src/app/graphics/sprites/SpriteZerg.ts","webpack:///./src/app/graphics/sprites/CreatureSprite.ts","webpack:///./src/app/infrastructure/FrameRate.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack:///./src/app/peripherals/Keyboard.ts","webpack:///./src/app/peripherals/constants/KeyCodes.ts","webpack:///./src/app/peripherals/Gamepads.ts","webpack:///./src/app/domain/Grid.ts","webpack:///./src/app/domain/enemies/ConcreteEnemy.ts","webpack:///./src/app/infrastructure/Pathfinding.ts","webpack:///./src/app/domain/enemies/Enemy.ts","webpack:///./src/app/infrastructure/Directions.ts","webpack:///./src/app/domain/objects/GameObjectFactory.ts","webpack:///./src/app/domain/objects/box/BoxFactory.ts","webpack:///./src/app/domain/objects/box/Box.ts","webpack:///./src/app/domain/objects/GameObject.ts","webpack:///./src/app/domain/player/Player.ts","webpack:///./src/app/domain/player/Crosshair.ts","webpack:///./src/app/domain/player/Projectile.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack:///./src/app/infrastructure/GameAssets.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","canvas","document","getElementById","width","CONFIG","CANVAS_WIDTH","height","CANVAS_HEIGHT","style","SCALE","context","getContext","Canvas","clearRect","this","mousePosition","x","Math","floor","offsetLeft","y","offsetTop","halfWidth","halfHeight","rows","TILE_SIZE","cols","halfRows","halfCols","rowRemainder","colRemainder","center","getCanvasDomElement","Game","window","onfocus","restart","loadedPercentages","set","Graphics","weight","loaded","Audio","load","percentage","gameAssetLoaded","stateManager","getState","PAUSED","setState","PLAYING","loadInterval","setInterval","clearInterval","MAIN_MENU","gameLoop","asset","assetValue","loadedPercentage","_key","update","render","calculateFrameRate","requestAnimationFrame","clear","drawFPS","Map","GAME_STATES","LOADING","getEnemiesOnScreen","playerX","playerY","enemies","filter","e","isOnScreen","gameObjects","grid","player","loadMap","Map01","forEach","alive","splice","drawGameObjects","draw","deltas","dxLeft","dyTop","rowStart","row","colStart","col","gameObject","map","length","createGameObject","push","healthPercentage","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","Promise","all","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","buffer","SMG_INDEX","gainNode","createGain","gain","soundFxVolume","connect","destination","start","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","p1","p2","sqrt","atan2","dyBottom","dxRight","THROW_DEVELOPMENT_ERRORS","Error","a","b","collisionBox","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","addEventListener","preventDefault","pageX","pageY","setShooting","innerWidth","innerHeight","AudioContext","Sprites","Zerg","Raycaster","theta","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","hitPoint","color","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","angleBetweenTwoGivenPoints","angleBetweenPoints","results","cast","hitObject","n1","n2","angleBetweenNodes","toFixed","vNE1","vNE2","getVerticesNE","determineIfThereAreObstaclesBetweenTwoPoints","vSE1","vSE2","getVerticesSE","PI","vSW1","vSW2","getVerticesSW","vNW1","vNW2","getVerticesNW","abs","yIntercept","tileStepX","hitPointVertical","objectHitVertical","rangeHorizontal","rangeVertical","RAYCASTER","DEBUG","coordinates","arc","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","round","checkGameObjectCollisionHorizontalSE","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","yTile_aboveByOnePixel","gameObjectHit","fillText","xTile_leftByOnePixel","outsideOfScreenOffset","blankVertex","vertexNW1","vertexNW2","vertexNE1","vertexNE2","vertexSW1","vertexSW2","vertexSE1","vertexSE2","prevX","prevY","animationInterval","isMoving","moving","left","right","up","down","blocked","nextX","nextY","maxSpeedDiagonal","maxSpeed","nextCreatureState","collisionBoxesIntersect","intersectionX","intersectionY","mapX","SWVertexRow","NWVertexRow","SEVertexRow","NEVertexRow","mapY","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","shift","direction","dx","dy","Directions","S","N","E","W","directionString","join","xUnchanged","yUnchanged","MapKeys","mapKey","startsWith","loadCallback","Mixer","_musicVolume","vol","_soundFxVolume","URI","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send","url","animationPeriods","walking","enemy","playerCoordinates","spriteLocation","flip","NE","SE","SW","NW","SPRITE_OFFSETS","SPRITE_SIZE","cBox","px","py","save","translate","scale","drawImage","spriteSheet","restore","callback","_reject","Image","src","lastFrameTime","frameElapsedTime","FPS_ARR","FPS","now","performance","unshift","pop","reduce","sum","current","fillStyle","font","drawLoadingDialog","animationCounter","instructionsVisible","handleMenuSelection","removeEventListener","drawMainMenu","previousState","startNewGame","nextState","onblur","updateMousePosition","init","keyCode","KEYBOARD_KEYS","w","ESC","togglePause","ENTER","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","pathfindingInterval","super","sprite","updateMapPosition","resetBlocked","calculateNextCoordinates","updatePreviousCoordinates","stuck","checkIfStuck","checkIfMoving","adjustCollisionWithGameObjects","checkForCollisionWithPlayer","checkForCollisionWithOtherEnemies","distanceFromPlayer","pointToPointDistance","thereAreObstaclesBetweenPlayerAndThisEnemy","determineIfThereAreObstaclesBetweenTwoPathNodes","findPathToPlayer","move","updateDirection","updateTileDeltas","advanceAnimation","drawCollisionBox","damageAmount","playEnemyHit","health","die","playEnemyDeath","pathfindingNodes","generatePathNodes","shortestPath","findShortestPath","pathfindingPeriod","followTheShortestPath","moveTowardsPlayer","nextNodeX","nextNodeY","moveTowards","resetMoving","getHealthColor","drawNode","node","startRow","startCol","path","rowEnd","colEnd","PathNode","nodeGoal","nodeStart","f","g","heuristic","nodesNotTested","nodeCurrent","sort","visited","neighbourNodes","possiblyLowerLocalGoal","parent","Infinity","maxHealth","initializeHealth","sin","offScreenOffset","nextEnemyState","checkIfBlockedByCreature","xIsStatic","every","yIsStatic","isBox","createBox","BoxGray","BoxGreen","BoxBlue","playCrateHit","destructable","rotation","sightLineLength","shooting","shootingCooldown","projectiles","checkForCollisionWithEnemies","shoot","calculateTheta","drawPlayer","drawPlayerVisionRay","drawProjectiles","xVel","yVel","randomFactorX","random","randomFactorY","playSMG","isShooting","cos","drawRay","nextPlayerState","enemiesOnScreen","some","canvasX","canvasY","offsetX","offsetY","directionX","directionY","speed","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithGameObject","intermediateIntervalX","intermediateIntervalY","point","takeDamage","getDamage","drawPauseMenu","currentState","exit","enter","GameAssets"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,mPClFrD,aAGA,OAEMC,EAASC,SAASC,eAAe,UACvCF,EAAOG,MAASC,EAAOC,aACvBL,EAAOM,OAASF,EAAOG,cACvBP,EAAOQ,MAAML,MAA0B,IAAjBC,EAAOK,MAAeL,EAAOK,MAAQL,EAAOC,aAAiB,KAAO,OAC1FL,EAAOQ,MAAMF,OAA0B,IAAjBF,EAAOK,MAAeL,EAAOK,MAAQL,EAAOG,cAAiB,KAAO,OAC7E,EAAAG,QAAUV,EAAOW,WAAW,MAEzC,MAAqBC,EAgBZ,eACL,EAAAF,QAAQG,UAAU,EAAG,EAAGb,EAAOG,MAAOH,EAAOM,QAKxC,6BACLQ,KAAKC,cAAgB,CACnBC,EAAGC,KAAKC,OAAO,UAAMF,EAAIhB,EAAOmB,YAAcf,EAAOK,OACrDW,EAAGH,KAAKC,OAAO,UAAME,EAAIpB,EAAOqB,WAAcjB,EAAOK,SAzB3D,YACgB,EAAAa,UAAatB,EAAOG,MAAS,EAC7B,EAAAoB,WAAavB,EAAOM,OAAS,EAC7B,EAAAkB,KAAOP,KAAKC,MAAMlB,EAAOM,OAASF,EAAOqB,WACzC,EAAAC,KAAOT,KAAKC,MAAMlB,EAAOG,MAASC,EAAOqB,WACzC,EAAAE,SAAWV,KAAKC,MAAOlB,EAAOM,OAAS,EAAKF,EAAOqB,WACnD,EAAAG,SAAWX,KAAKC,MAAOlB,EAAOG,MAAS,EAAKC,EAAOqB,WACnD,EAAAI,aAAgB7B,EAAOM,OAAS,EAAKF,EAAOqB,UAC5C,EAAAK,aAAgB9B,EAAOG,MAAS,EAAKC,EAAOqB,UAG5C,EAAAM,OAAgB,CAC5Bf,EAAGZ,EAAOC,aAAgB,EAC1Be,EAAGhB,EAAOG,cAAgB,GAOd,EAAAyB,oBAAsB,IAAyBhC,G,8EChC/D,cACA,QACA,OAEA,QACA,OACA,QACA,QAEA,MAAqBiC,EAenB,cACEC,OAAOC,QAAU,KACf,UAAUC,WAGZH,EAAKI,kBAAkBC,IAAI,UAAWC,SAAU,CAAEC,OAAQ,GAAKC,OAAQ,IACvER,EAAKI,kBAAkBC,IAAI,UAAWI,MAAU,CAAEF,OAAQ,GAAKC,OAAQ,IAEvE,UAAYE,KAAQC,GAAc9B,KAAK+B,gBAAgB,UAAWH,MAAOE,IACzE,UAAeD,KAAKC,GAAc9B,KAAK+B,gBAAgB,UAAWN,SAAUK,IAjBvE,qBACDX,EAAKa,aAAaC,aAAe,UAAYC,OAC/Cf,EAAKa,aAAaG,SAAS,UAAYC,SAEvCjB,EAAKa,aAAaG,SAAS,UAAYD,QAgBpC,QACL,MAAMG,EAAeC,YAAY,KAC3BnB,EAAKQ,SACPY,cAAcF,GACdlB,EAAKa,aAAaG,SAAS,UAAYK,aAExC,KAEHxC,KAAKyC,WAGC,gBAAgBC,EAAmBZ,GACzC,MAAMa,EAAaxB,EAAKI,kBAAkBxD,IAAI2E,GAC9CC,EAAWhB,OAASG,EACpBX,EAAKI,kBAAkBC,IAAIkB,EAAOC,GAElCxB,EAAKyB,iBAAmB,EACxB,IAAK,MAAOC,EAAM1E,KAAUgD,EAAKI,kBAC/BJ,EAAKyB,kBAAoBzE,EAAMwD,OAASxD,EAAMuD,OAGlB,IAA1BP,EAAKyB,mBACPzB,EAAKQ,QAAS,GAIV,WACN3B,KAAK8C,SACL9C,KAAK+C,SAEL,UAAUC,qBAEV5B,OAAO6B,sBAAsB,IAAMjD,KAAKyC,YAGlC,SACNtB,EAAKa,aAAac,SAGZ,SACN,UAAOI,QACP/B,EAAKa,aAAae,SAClB,UAAUI,WArEd,YACgB,EAAAxB,QAAkB,EAClB,EAAAiB,iBAA2B,EAC3B,EAAArB,kBAAyE,IAAI6B,IAE7E,EAAApB,aAAiC,IAAI,W,8ECdrD,cACA,QACA,QACA,QAGMqB,EAAc,CAClBC,QAAY,IAAI,UAChBd,UAAY,IAAI,UAChBJ,QAAY,IAAI,UAChBF,OAAY,IAAI,WAGlB,UAAemB,G,8ECbf,aAKA,QAEA,OAEA,QAGA,QAKA,SAAgBE,EAAmBC,EAAiBC,GAClD,OAAO,EAAAC,QAAQC,OAAOC,GAAKA,EAAEC,WAAWL,EAASC,IAJtC,EAAAK,YAA8B,GAC9B,EAAAJ,QAAmB,GAEhC,uBAIA,gBACE,YAAoBK,EAAoBC,GAApB,KAAAD,OAAoB,KAAAC,SACtChE,KAAKiE,QAAQC,GAGR,SACL,EAAAR,QAAQS,QAAQ,CAACP,EAAG1G,KAClB0G,EAAEd,OAAO9C,KAAKgE,OAAQ,EAAAN,UACN,IAAZE,EAAEQ,OACJ,EAAAV,QAAQW,OAAOnH,EAAG,KAKjB,OACL8C,KAAKsE,kBACLf,EAAmBvD,KAAKgE,OAAO9D,EAAGF,KAAKgE,OAAO1D,GAC3C6D,QAAQP,GAAKA,EAAEW,KAAKvE,KAAKgE,SAGtB,kBACN,MAAM3D,EAAaL,KAAKgE,OAAOQ,OAAOC,OAAS,UAAOzD,aAChDT,EAAaP,KAAKgE,OAAOQ,OAAOE,MAAS,UAAO3D,aAEhD4D,EAAW3E,KAAKgE,OAAOY,IAAM,UAAO/D,SACpCgE,EAAW7E,KAAKgE,OAAOc,IAAM,UAAOhE,SAC1C,IAAIiE,EACJ,IAAK,IAAIH,EAAMD,EAAUC,EAAMD,EAAW,UAAOjE,KAAO,IAAKkE,EAC3D,IAAK,IAAIE,EAAMD,EAAW,EAAGC,EAAMD,EAAW,UAAOjE,KAAO,IAAKkE,EAC3D,EAAAhB,YAAYc,IAAQ,EAAAd,YAAYc,GAAKE,MACvCC,EAAa,EAAAjB,YAAYc,GAAKE,IACnB5E,GAAK4E,EAAMD,GAAYvF,EAAOqB,UAAYN,EACrD0E,EAAWzE,GAAKsE,EAAMD,GAAYrF,EAAOqB,UAAYJ,EACrDwE,EAAWR,QAMX,QAAQS,GACd,IAAK,IAAIJ,EAAM,EAAGA,EAAMI,EAAIlB,YAAYmB,SAAUL,EAAK,CACrD,EAAAd,YAAYc,GAAO,GACnB,IAAK,IAAIE,EAAM,EAAGA,EAAME,EAAIlB,YAAYc,GAAKK,SAAUH,EACrD,EAAAhB,YAAYc,GAAKE,GAAO,UAAkBI,iBAAiBN,EAAKE,EAAKE,EAAIlB,YAAYc,GAAKE,IAI9FE,EAAItB,QAAQS,QAAQ,CAACP,EAAG1G,KACtB,EAAAwG,QAAQyB,KAAK,IAAI,UAAcvB,EAAE1D,EAAG0D,EAAEtD,EAAGsD,EAAEwB,iBAAkBlI,S,8ECrEnE,cACA,OACA,QAEA,MAAqBmI,EAYZ,kBAAkBC,GACvB,MAAMC,EAAsB,CAC1B,EAAA1D,KAAK,qBACL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBAEL,EAAAA,KAAK,2BAEL,EAAAA,KAAK,2BACL,EAAAA,KAAK,2BACL,EAAAA,KAAK,2BACL,EAAAA,KAAK,2BACL,EAAAA,KAAK,2BAEL,EAAAA,KAAK,4BAID2D,QAAqBC,QAAQC,IAAIH,GAEvCvF,KAAK2F,IAAI,GAAKH,EAAa,GAC3BxF,KAAK2F,IAAI,GAAKH,EAAa,GAC3BxF,KAAK2F,IAAI,GAAKH,EAAa,GAC3BxF,KAAK2F,IAAI,GAAKH,EAAa,GAC3BxF,KAAK2F,IAAI,GAAKH,EAAa,GAE3BxF,KAAK4F,UAAU,GAAKJ,EAAa,GAEjCxF,KAAK6F,UAAU,GAAKL,EAAa,GACjCxF,KAAK6F,UAAU,GAAKL,EAAa,GACjCxF,KAAK6F,UAAU,GAAKL,EAAa,GACjCxF,KAAK6F,UAAU,GAAKL,EAAa,GACjCxF,KAAK6F,UAAU,GAAKL,EAAa,IAEjCxF,KAAK8F,YAAY,GAAKN,EAAa,IACnCF,EAAoB,GAGf,iBACL,MAAMS,EAAY,UAAQC,qBAC1BD,EAAUE,OAASjG,KAAK2F,IAAI3F,KAAKkG,WAEjC,MAAMC,EAAW,UAAQC,aACzBD,EAASE,KAAKlI,MAA8B,GAAtB,UAAMmI,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBT,EAAUU,QACVzG,KAAKkG,YAAclG,KAAKkG,UAAYlG,KAAK2F,IAAIV,OAGxC,sBACL,IAA6B,IAAzBjF,KAAK0G,gBACP,OAEF,MAAMX,EAAY,UAAQC,qBAC1BD,EAAUE,OAASjG,KAAK6F,UAAU7F,KAAK2G,iBAEvC,MAAMR,EAAW,UAAQC,aACzBD,EAASE,KAAKlI,MAAQ,UAAMmI,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBT,EAAUU,QACVzG,KAAK2G,kBAAoB3G,KAAK2G,gBAAkB3G,KAAK6F,UAAUZ,OAE/DjF,KAAK0G,iBAAkB,EACvBE,WAAW,KAAQ5G,KAAK0G,iBAAkB,GAAQ,KAG7C,wBACL,MAAMX,EAAY,UAAQC,qBAC1BD,EAAUE,OAASjG,KAAK8F,YAAY,GAEpC,MAAMK,EAAW,UAAQC,aACzBD,EAASE,KAAKlI,MAAQ,UAAMmI,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBT,EAAUU,QAGL,sBACL,MAAMV,EAAY,UAAQC,qBAC1BD,EAAUE,OAASjG,KAAK4F,UAAU,GAElC,MAAMO,EAAW,UAAQC,aACzBD,EAASE,KAAKlI,MAAQ,UAAMmI,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBT,EAAUU,SA7Gd,YACiB,EAAAd,IAAqB,GACrB,EAAAO,UAAY,EAEZ,EAAAN,UAA2B,GAE3B,EAAAC,UAA2B,GAC3B,EAAAc,gBAAkB,EAClB,EAAAD,iBAA2B,EAE3B,EAAAZ,YAA6B,I,8ECd9C,aAeA,gCAAqCe,EAAWC,GAC9C,OAAO3G,KAAK4G,MAAMD,EAAG5G,EAAI2G,EAAG3G,IAAM4G,EAAG5G,EAAI2G,EAAG3G,IAAM4G,EAAGxG,EAAIuG,EAAGvG,IAAMwG,EAAGxG,EAAIuG,EAAGvG,KAG9E,8BAAmCuG,EAAWC,GAE5C,OADc3G,KAAK6G,MAAOH,EAAGvG,EAAIwG,EAAGxG,EAAKuG,EAAG3G,EAAI4G,EAAG5G,IAIrD,sCAA2ClB,GACzCA,EAAE4F,IAAMzE,KAAKC,MAAMpB,EAAEsB,EAAIhB,EAAOqB,WAChC3B,EAAE8F,IAAM3E,KAAKC,MAAMpB,EAAEkB,EAAIZ,EAAOqB,YAGlC,6BAAkC3B,GAChCA,EAAEwF,OAAOE,MAAQ1F,EAAEsB,EAAIhB,EAAOqB,UAC9B3B,EAAEwF,OAAOyC,SAAW3H,EAAOqB,UAAY3B,EAAEwF,OAAOE,MAChD1F,EAAEwF,OAAOC,OAASzF,EAAEkB,EAAIZ,EAAOqB,UAC/B3B,EAAEwF,OAAO0C,QAAU5H,EAAOqB,UAAY3B,EAAEwF,OAAOC,S,8ECjCjD,aAEA,gBAGE,YACSpF,EACAG,GAGP,GAJO,KAAAH,QACA,KAAAG,SAGHF,EAAO6H,2BACL9H,EAAQ,GAAM,GAAKG,EAAS,GAAM,GACpC,MAAM,IAAI4H,MAAM,yDAGpBpH,KAAKQ,UAAaR,KAAKX,MAAS,EAChCW,KAAKS,WAAaT,KAAKR,OAAS,IAUpC,mCAAwC6H,EAAgBC,GACtD,OACED,EAAEnH,EAAImH,EAAEE,aAAa/G,UAAa8G,EAAEpH,EAAIoH,EAAEC,aAAa/G,WACvD6G,EAAEnH,EAAImH,EAAEE,aAAa/G,UAAa8G,EAAEpH,EAAIoH,EAAEC,aAAa/G,WACvD6G,EAAE/G,EAAI+G,EAAEE,aAAa9G,WAAa6G,EAAEhH,EAAIgH,EAAEC,aAAa9G,YACvD4G,EAAE/G,EAAI+G,EAAEE,aAAa9G,WAAa6G,EAAEhH,EAAIgH,EAAEC,aAAa9G,a,8EC/B3D,aAGA,MAAqB+G,EAGZ,YAAYxD,GACjBhE,KAAKyH,mBACLzH,KAAK0H,qBACL1H,KAAK2H,oBAAoB3D,GAGnB,0BACN5C,OAAOwG,iBAAiB,cAAehE,IACrCA,EAAEiE,mBACD,GAGG,4BAC4B,UAAO3G,sBAClC0G,iBAAiB,YAAahE,IACnC5D,KAAKE,EAAI0D,EAAEkE,MACX9H,KAAKM,EAAIsD,EAAEmE,QACV,GAGG,2BAA2B/D,GACjC,MAAM9E,EAA4B,UAAOgC,sBACzChC,EAAO0I,iBAAiB,YAAahE,IACnCI,EAAOgE,aAAY,KAClB,GACH9I,EAAO0I,iBAAiB,UAAWhE,IACjCI,EAAOgE,aAAY,KAClB,IA9BP,YACgB,EAAA9H,EAAYkB,OAAO6G,WAAc,EAAI,IACrC,EAAA3H,EAAYc,OAAO8G,YAAc,EAAI,I,8ECLrD,MAAMtI,EAAwB,IAAIuI,aAElC,UAAevI,G,8ECDf,cAEA,MAAqBwI,EAGZ,kBAAkB9C,SACjB8C,EAAQC,KAAKxG,KAAK,IAAMyD,EAAoB,KAJtD,YACgB,EAAA+C,KAAuB,IAAI,W,8ECJ3C,aAEA,OAEA,OAEA,OAMA,MAAqBC,EAWZ,YACLtJ,EACAuJ,EACAC,GAEA,KAAID,GAAS,GASN,CACL,MAAME,EAAOzJ,EAAEwF,OAAOE,MAAQvE,KAAKuI,KAAKH,GAGlCI,EAAkB,EAAIF,EAAQ,EAEpC,OAAIA,GAAQ,GAAKE,EACRL,EAAUM,oBAAoB5J,EAAGuJ,EAAOC,GAGxCF,EAAUO,oBAAoB7J,EAAGuJ,EAAOC,GAnBnC,CACd,MAAMC,EAAOzJ,EAAEwF,OAAOyC,SAAW9G,KAAKuI,IAAIH,GAE1C,GAAIE,GAAQ,EACV,OAAOH,EAAUQ,oBAAoB9J,EAAGuJ,EAAOC,GAE5C,GAAIC,EAAO,EACd,OAAOH,EAAUS,oBAAoB/J,EAAGuJ,EAAOC,IAiB9C,eAAeQ,EAAiBC,EAAgB,WACrD,EAAArJ,QAAQsJ,YAAcD,EACtB,EAAArJ,QAAQuJ,UAAY,GACpB,EAAAvJ,QAAQwJ,YACN,EAAAxJ,QAAQyJ,OAAO,UAAO7I,UAAW,UAAOC,YACxC,EAAAb,QAAQ0J,OACN,UAAO9I,UAAYwI,EAAS9I,EAC5B,UAAOO,WAAauI,EAAS1I,GAEjC,EAAAV,QAAQ2J,SACR,EAAA3J,QAAQuJ,UAAY,EAGf,oDAAoDtC,EAAsBC,GAC/E,MAAM0C,EAA6B,EAAAC,mBAAmB3C,EAAID,GACpD6C,EAAUpB,EAAUqB,KAAK9C,EAAI2C,EAA4B1C,GAI/D,OAAI4C,GAC2B,OAAtBA,EAAQE,UAQZ,uDAAuDC,EAAsBC,GAClF,MAAMC,GAA6B,EAAAN,mBAAmBK,EAAID,GAAIG,QAAQ,GAEtE,GAA0B,IAAtBD,EAAyB,CAC3B,MAAOE,EAAMC,GAAQC,EAAcN,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CH,EAA0BC,GACnF,OAAO,EAET,MAAOG,EAAMC,GAAQC,EAAcV,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CC,EAA0BC,GAMlF,GAAIP,EAAoB,GAAKA,EAAoB5J,KAAKqK,GAAK,EAAG,CACjE,MAAOP,EAAMC,GAAQC,EAAcN,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CH,EAA0BC,GACnF,OAAO,EAET,MAAOO,EAAMC,GAAQC,EAAcd,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CK,EAA0BC,GAMlF,GAAIX,IAAuB5J,KAAKqK,GAAK,EAAI,CAC5C,MAAOH,EAAMC,GAAQC,EAAcV,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CC,EAA0BC,GACnF,OAAO,EAET,MAAOG,EAAMC,GAAQC,EAAcd,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CK,EAA0BC,GAMlF,GAAIX,EAAoB5J,KAAKqK,GAAK,GAAKT,EAAoB5J,KAAKqK,GAAI,CACvE,MAAOI,EAAMC,GAAQC,EAAcjB,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CQ,EAA0BC,GACnF,OAAO,EAET,MAAOR,EAAMC,GAAQC,EAAcV,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CC,EAA0BC,GAMlF,GAAoC,OAAhCnK,KAAK4K,IAAIhB,GAA6B,CAC7C,MAAOa,EAAMC,GAAQC,EAAcjB,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CQ,EAA0BC,GACnF,OAAO,EAET,MAAOJ,EAAMC,GAAQC,EAAcd,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CK,EAA0BC,GAMlF,GAAIX,GAAqB5J,KAAKqK,IAAMT,GAAqB5J,KAAKqK,GAAK,EAAG,CACzE,MAAOP,EAAMC,GAAQC,EAAcN,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CH,EAA0BC,GACnF,OAAO,EAET,MAAOO,EAAMC,GAAQC,EAAcd,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CK,EAA0BC,GAMlF,IAA2B,OAAvBX,EAA6B,CACpC,MAAOE,EAAMC,GAAQC,EAAcN,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CH,EAA0BC,GACnF,OAAO,EAET,MAAOU,EAAMC,GAAQC,EAAcjB,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CQ,EAA0BC,GAMlF,GAAId,GAAqB5J,KAAKqK,GAAK,GAAKT,EAAoB,EAAG,CAClE,MAAOa,EAAMC,GAAQC,EAAcjB,EAAIC,GACvC,GAAIxB,EAAU8B,6CAA6CQ,EAA0BC,GACnF,OAAO,EAET,MAAOR,EAAMC,GAAQC,EAAcV,EAAIC,GACvC,QAAIxB,EAAU8B,6CAA6CC,EAA0BC,IAYjF,2BAA2BtL,EAAqBuJ,EAAeC,GAIrE,IAIIwC,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhCjO,EAAI,EAIR,OACE+N,EAAY/N,EAAIoC,EAAOqB,UAErBqK,EADY,IAAVzC,EACW,GAECvJ,EAAEwF,OAAO0C,QAAU+D,GAAa9K,KAAKuI,IAAIH,GAIpD0C,EAAYjM,EAAEwF,OAAO0C,QAAUoB,EAAU8C,iBAAqBJ,EAAa1C,EAAU+C,eAKtF7C,IACEyC,EAAYjM,EAAEwF,OAAO0C,QAAWsB,EAAKtI,EAAIlB,EAAEkB,GAAM8K,EAAcxC,EAAKlI,EAAItB,EAAEsB,KAfrE,CAoBX,GAAIhB,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKlB,EAAEwF,OAAO0C,QAAU+D,EACzD3K,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAK0K,GAG1B,CACZ9K,EAAG,UAAOe,OAAOf,EAAIlB,EAAEwF,OAAO0C,QAAU+D,EACxC3K,EAAG,UAAOW,OAAOX,EAAI0K,GAGzB,EAAApL,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAKV,GAFA4B,EAAoB7C,EAAUoD,mCAAmCxO,EAAG8B,EAAGgM,GAEhD,CACrBE,EAAmB,CAAEhL,EAAG+K,EAAYjM,EAAEwF,OAAO0C,QAAS5G,EAAG0K,GACzD,QAEA9N,EAMJ,IAIIyO,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAIzM,EAAOqB,UACT,IAAV4H,IAGFoD,GAAc3M,EAAEwF,OAAOyC,SAAW2E,GAAazL,KAAKuI,IAAIH,GAIrDqD,EAAY5M,EAAEwF,OAAOyC,SAAWqB,EAAU+C,eAAmBM,EAAarD,EAAU8C,kBAKrF5C,IACEoD,EAAY5M,EAAEwF,OAAOyC,SAAYuB,EAAKlI,EAAItB,EAAEsB,GAAMH,KAAK6L,MAAML,GAAenD,EAAKtI,EAAIlB,EAAEkB,KAflF,CAoBX,GAAIZ,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKyL,EACtCrL,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAKtB,EAAEwF,OAAOyC,SAAW2E,GAG9C,CACZ1L,EAAG,UAAOe,OAAOf,EAAIyL,EACrBrL,EAAG,UAAOW,OAAOX,EAAItB,EAAEwF,OAAOyC,SAAW2E,GAG7C,EAAAhM,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAIV,GAAIyB,EAAaY,EACf,MAKF,GAFAE,EAAsBxD,EAAU2D,qCAAqCF,EAAG/M,EAAG2M,GAElD,CACvBE,EAAqB,CAAE3L,EAAGyL,EAAYrL,EAAGsL,EAAY5M,EAAEwF,OAAOyC,UAC9D,QAEA8E,EAOJ,GAAIb,GAA2C,OAAvBW,EACtB,MAAO,CACL7C,SAAYkC,EACZtB,UAAYuB,GAGX,GAAIU,GAA2C,OAArBX,EAC7B,MAAO,CACLlC,SAAY6C,EACZjC,UAAYkC,GAGX,GAAID,GAAsBX,EAAkB,CAG/C,OAFwC/K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,GAIb,GAA2B,OAAvBU,GAAoD,OAArBX,EAA2B,CAEjE,MAAMW,EAAqB,CAAE3L,EAAGyL,EAAYrL,EAAGsL,EAAY5M,EAAEwF,OAAOyC,UAC9DiE,EAAqB,CAAEhL,EAAG+K,EAAYjM,EAAEwF,OAAO0C,QAAS5G,EAAG0K,GAGjE,OAFwC7K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,IAOZ,2BAA2BnM,EAAqBuJ,EAAeC,GAIrE,IAIIwC,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhCjO,EAAI,EAIR,OACE+N,EAAY/N,EAAIoC,EAAOqB,UAErBqK,EADY,IAAVzC,EACW,GAECvJ,EAAEwF,OAAO0C,QAAU+D,GAAa9K,KAAKuI,KAAKH,GAIrD0C,EAAYjM,EAAEwF,OAAO0C,QAAUoB,EAAU8C,iBAAqBJ,EAAa1C,EAAU+C,eAKtF7C,IACEyC,EAAYjM,EAAEwF,OAAO0C,QAAWsB,EAAKtI,EAAIlB,EAAEkB,GAAM8K,EAAchM,EAAEsB,EAAIkI,EAAKlI,KAfrE,CAoBX,GAAIhB,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKlB,EAAEwF,OAAO0C,QAAU+D,EACzD3K,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAK0K,GAG1B,CACZ9K,EAAG,UAAOe,OAAOf,EAAIlB,EAAEwF,OAAO0C,QAAU+D,EACxC3K,EAAG,UAAOW,OAAOX,EAAI0K,GAGzB,EAAApL,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAKV,GAFA4B,EAAoB7C,EAAU6D,mCAAmCjP,EAAG8B,EAAGgM,GAEhD,CACrBE,EAAmB,CAAEhL,EAAG+K,EAAYjM,EAAEwF,OAAO0C,QAAS5G,GAAI0K,GAC1D,QAEA9N,EAMJ,IAIIyO,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAIzM,EAAOqB,UACT,IAAV4H,IAGFoD,GAAc3M,EAAEwF,OAAOE,MAAQkH,GAAazL,KAAKuI,KAAKH,GAInDqD,EAAY5M,EAAEwF,OAAOE,MAAQ4D,EAAU+C,eAAmBM,EAAarD,EAAU8C,kBAKlF5C,IACEoD,EAAY5M,EAAEwF,OAAOE,MAAS1F,EAAEsB,EAAIkI,EAAKlI,GAAMH,KAAK6L,MAAML,GAAenD,EAAKtI,EAAIlB,EAAEkB,KAf/E,CAoBX,GAAIZ,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKyL,EACtCrL,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAKtB,EAAEwF,OAAOE,MAAQkH,GAG3C,CACZ1L,EAAG,UAAOe,OAAOf,EAAIyL,EACrBrL,EAAG,UAAOW,OAAOX,EAAIsL,EAAY5M,EAAEwF,OAAOE,OAG9C,EAAA9E,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAIV,GAAIyB,EAAaY,EACf,MAKF,GAFAE,EAAsBxD,EAAU8D,qCAAqCL,EAAG/M,EAAG2M,GAElD,CACvBE,EAAqB,CAAE3L,EAAGyL,EAAYrL,GAAIsL,EAAY5M,EAAEwF,OAAOE,OAC/D,QAEAqH,EAOJ,GAAIb,GAA2C,OAAvBW,EACtB,MAAO,CACL7C,SAAYkC,EACZtB,UAAYuB,GAGX,GAAIU,GAA2C,OAArBX,EAC7B,MAAO,CACLlC,SAAY6C,EACZjC,UAAYkC,GAGX,GAAID,GAAsBX,EAAkB,CAG/C,OAFwC/K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,GAIb,GAA2B,OAAvBU,GAAoD,OAArBX,EAA2B,CAEjE,MAAMW,EAAqB,CAAE3L,EAAGyL,EAAYrL,GAAIsL,EAAY5M,EAAEwF,OAAOE,OAC/DwG,EAAqB,CAAEhL,EAAG+K,EAAYjM,EAAEwF,OAAO0C,QAAS5G,GAAI0K,GAGlE,OAFwC7K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,IAOZ,2BAA2BnM,EAAUuJ,EAAeC,GAI1D,IAIIwC,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhCjO,EAAI,EAIR,OACE+N,EAAY/N,EAAIoC,EAAOqB,UAErBqK,EADY,IAAVzC,EACW,GAECvJ,EAAEwF,OAAOC,OAASwG,GAAa9K,KAAKuI,IAAIvI,KAAKqK,KAAOjC,GAI/D0C,EAAYjM,EAAEwF,OAAOC,OAAS6D,EAAU8C,iBAAqBJ,EAAa1C,EAAU+C,eAKrF7C,IACEyC,EAAYjM,EAAEwF,OAAOC,OAAUzF,EAAEkB,EAAIsI,EAAKtI,GAAM8K,EAAchM,EAAEsB,EAAIkI,EAAKlI,KAfpE,CAoBX,GAAIhB,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKlB,EAAEwF,OAAOC,OAASwG,EACxD3K,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAK0K,GAG1B,CACZ9K,EAAG,UAAOe,OAAOf,EAAIlB,EAAEwF,OAAOC,OAASwG,EACvC3K,EAAG,UAAOW,OAAOX,EAAI0K,GAGzB,EAAApL,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAKV,GAFA4B,EAAoB7C,EAAU+D,mCAAmCnP,EAAG8B,EAAGgM,GAEhD,CACrBE,EAAmB,CAAEhL,GAAK+K,EAAYjM,EAAEwF,OAAOC,OAAQnE,GAAI0K,GAC3D,QAEA9N,EAMJ,IAIIyO,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAIzM,EAAOqB,UACT,IAAV4H,IAGFoD,GAAc3M,EAAEwF,OAAOE,MAAQkH,GAAazL,KAAKuI,IAAIvI,KAAKqK,KAAOjC,GAI9DqD,EAAY5M,EAAEwF,OAAOE,MAAQ4D,EAAU+C,eAAmBM,EAAarD,EAAU8C,kBAKlF5C,IACEoD,EAAY5M,EAAEwF,OAAOE,MAAS1F,EAAEsB,EAAIkI,EAAKlI,GAAMH,KAAK6L,MAAML,GAAe3M,EAAEkB,EAAIsI,EAAKtI,KAf/E,CAoBX,GAAIZ,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKyL,EACtCrL,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAKtB,EAAEwF,OAAOE,MAAQkH,GAG3C,CACZ1L,EAAG,UAAOe,OAAOf,EAAIyL,EACrBrL,EAAG,UAAOW,OAAOX,EAAItB,EAAEwF,OAAOE,MAAQkH,GAG1C,EAAAhM,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAIV,GAAIyB,EAAaY,EACf,MAKF,GAFAE,EAAsBxD,EAAUgE,qCAAqCP,EAAG/M,EAAG2M,GAElD,CACvBE,EAAqB,CAAE3L,GAAIyL,EAAYrL,GAAIsL,EAAY5M,EAAEwF,OAAOE,OAChE,QAEAqH,EAOJ,GAAIb,GAA2C,OAAvBW,EACtB,MAAO,CACL7C,SAAYkC,EACZtB,UAAYuB,GAGX,GAAIU,GAA2C,OAArBX,EAC7B,MAAO,CACLlC,SAAY6C,EACZjC,UAAYkC,GAGX,GAAID,GAAsBX,EAAkB,CAG/C,OAFwC/K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,GAIb,GAA2B,OAAvBU,GAAoD,OAArBX,EAA2B,CAEjE,MAAMW,EAAqB,CAAE3L,GAAIyL,EAAYrL,GAAIsL,EAAY5M,EAAEwF,OAAOE,OAChEwG,EAAqB,CAAEhL,GAAK+K,EAAYjM,EAAEwF,OAAOC,OAAQnE,GAAI0K,GAGnE,OAFwC7K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,IAOZ,2BAA2BnM,EAAUuJ,EAAeC,GAI1D,IAIIwC,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhCjO,EAAI,EAIR,OACE+N,EAAY/N,EAAIoC,EAAOqB,UAErBqK,EADY,IAAVzC,EACW,GAECvJ,EAAEwF,OAAOC,OAASwG,GAAa9K,KAAKuI,IAAIvI,KAAKqK,GAAKjC,GAI7D0C,EAAYjM,EAAEwF,OAAOC,OAAS6D,EAAU8C,iBAAqBJ,EAAa1C,EAAU+C,eAKrF7C,IACEyC,EAAYjM,EAAEwF,OAAOC,OAAUzF,EAAEkB,EAAIsI,EAAKtI,GAAM8K,EAAcxC,EAAKlI,EAAItB,EAAEsB,KAfpE,CAoBX,GAAIhB,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKlB,EAAEwF,OAAOC,OAASwG,EACxD3K,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAK0K,GAG1B,CACZ9K,EAAG,UAAOe,OAAOf,EAAIlB,EAAEwF,OAAOC,OAASwG,EACvC3K,EAAG,UAAOW,OAAOX,EAAI0K,GAGzB,EAAApL,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAKV,GAFA4B,EAAoB7C,EAAUiE,mCAAmCrP,EAAG8B,EAAGgM,GAEhD,CACrBE,EAAmB,CAAEhL,GAAI+K,EAAYjM,EAAEwF,OAAOC,OAAQnE,EAAG0K,GACzD,QAEA9N,EAMJ,IAIIyO,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAIzM,EAAOqB,UACT,IAAV4H,IAGFoD,GAAc3M,EAAEwF,OAAOyC,SAAW2E,GAAazL,KAAKuI,IAAIH,GAIrDqD,EAAY5M,EAAEwF,OAAOyC,SAAWqB,EAAU+C,gBAAoBM,EAAarD,EAAU8C,kBAKtF5C,IACGoD,EAAY5M,EAAEwF,OAAOyC,SAAYuB,EAAKlI,EAAItB,EAAEsB,IAASqL,EAAc3M,EAAEkB,EAAIsI,EAAKtI,KAf1E,CAoBX,GAAIZ,EAAOgM,UAAUC,MAAO,CAC1B,IAAIC,EAEFA,EADEhD,EACY,CACZtI,EAAG,UAAOe,OAAOf,GAAKsI,EAAKtI,EAAIlB,EAAEkB,GAAKyL,EACtCrL,EAAG,UAAOW,OAAOX,GAAKkI,EAAKlI,EAAItB,EAAEsB,GAAKtB,EAAEwF,OAAOyC,SAAW2E,GAG9C,CACZ1L,EAAG,UAAOe,OAAOf,EAAIyL,EACrBrL,EAAG,UAAOW,OAAOX,EAAItB,EAAEwF,OAAOyC,SAAW2E,GAG7C,EAAAhM,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IAAID,EAAYtL,EAAGsL,EAAYlL,EAAG,EAAG,EAAI,EAAIH,KAAKqK,IAC1D,EAAA5K,QAAQ2J,SAIV,GAAIyB,EAAaY,EACf,MAKF,GAFAE,EAAsBxD,EAAUkE,qCAAqCT,EAAG/M,EAAG2M,GAElD,CACvBE,EAAqB,CAAE3L,EAAGyL,EAAYrL,EAAGsL,EAAY5M,EAAEwF,OAAOyC,UAC9D,QAEA8E,EAOJ,GAAIb,GAA2C,OAAvBW,EACtB,MAAO,CACL7C,SAAYkC,EACZtB,UAAYuB,GAGX,GAAIU,GAA2C,OAArBX,EAC7B,MAAO,CACLlC,SAAY6C,EACZjC,UAAYkC,GAGX,GAAID,GAAsBX,EAAkB,CAG/C,OAFwC/K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,GAIb,GAA2B,OAAvBU,GAAoD,OAArBX,EAA2B,CAEjE,MAAMW,EAAqB,CAAE3L,EAAGyL,EAAYrL,EAAGsL,EAAY5M,EAAEwF,OAAOyC,UAC9DiE,EAAqB,CAAEhL,GAAI+K,EAAYjM,EAAEwF,OAAOC,OAAQnE,EAAG0K,GAGjE,OAFwC7K,KAAK4G,KAAK5G,KAAK+L,IAAMhB,EAAiBhL,EAAG,GAAKC,KAAK+L,IAAMhB,EAAiB5K,EAAG,IAC7EH,KAAK4G,KAAK5G,KAAK+L,IAAIL,EAAmB3L,EAAG,GAAKC,KAAK+L,IAAIL,EAAmBvL,EAAG,IAE5G,CACL0I,SAAY6C,EACZjC,UAAYkC,GAGP,CACL9C,SAAYkC,EACZtB,UAAYuB,IAMZ,0CAA0CjO,EAAW8B,EAAUgM,GACrE,MAAMyB,EAAQ,EAAIzN,EAAE8F,IAAM5H,EACpBwP,EAAQ1N,EAAE4F,IAAMzE,KAAKC,OAAOpB,EAAEwF,OAAOE,MAAQsG,GAAc1L,EAAOqB,WAClEgM,EAAwB3N,EAAE4F,IAAMzE,KAAKC,OAAOpB,EAAEwF,OAAOE,MAAQsG,EAAa,GAAK1L,EAAOqB,WAE5F,IAAIiM,EAAgB,KAcpB,OAbI,EAAA9I,YAAY4I,KACV,EAAA5I,YAAY4I,GAAOD,GACrBG,EAAgB,EAAA9I,YAAY4I,GAAOD,GAE5B,EAAA3I,YAAY6I,GAAuBF,KAC1CG,EAAgB,EAAA9I,YAAY6I,GAAuBF,KAInDnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAED,4CAA4C1P,EAAW8B,EAAU2M,GACvE,MAAMc,EAAQzN,EAAE8F,IAAM3E,KAAKC,OAAOpB,EAAEwF,OAAOC,OAASkH,GAAcrM,EAAOqB,WACnE+L,EAAQ1N,EAAE4F,IAAM1H,EAAI,EAE1B,IAAI0P,EAAgB,KASpB,OARI,EAAA9I,YAAY4I,IAAU,EAAA5I,YAAY4I,GAAOD,KAC3CG,EAAgB,EAAA9I,YAAY4I,GAAOD,IAGjCnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAGD,0CAA0C1P,EAAW8B,EAAUgM,GACrE,MAAMyB,EAAQ,EAAIzN,EAAE8F,IAAM5H,EACpBwP,EAAQ1N,EAAE4F,IAAMzE,KAAKC,OAAOpB,EAAEwF,OAAOE,MAAQsG,GAAc1L,EAAOqB,WAExE,IAAIiM,EAAgB,KASpB,OARI,EAAA9I,YAAY4I,IAAU,EAAA5I,YAAY4I,GAAOD,KAC3CG,EAAgB,EAAA9I,YAAY4I,GAAOD,IAGjCnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAED,4CAA4C1P,EAAW8B,EAAU2M,GACvE,MAAMc,EAAQzN,EAAE8F,IAAM3E,KAAKC,OAAOpB,EAAEwF,OAAOC,OAASkH,GAAcrM,EAAOqB,WACnEmM,EAAuB9N,EAAE8F,IAAM3E,KAAKC,OAAOpB,EAAEwF,OAAOC,OAASkH,EAAa,GAAKrM,EAAOqB,WACtF+L,EAAQ1N,EAAE4F,IAAM1H,EAAI,EAE1B,IAAI0P,EAAgB,KAcpB,OAbI,EAAA9I,YAAY4I,KACV,EAAA5I,YAAY4I,GAAOD,GACrBG,EAAgB,EAAA9I,YAAY4I,GAAOD,GAE5B,EAAA3I,YAAY4I,GAAOI,KAC1BF,EAAgB,EAAA9I,YAAY4I,GAAOI,KAInCxN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAGD,0CAA0C1P,EAAW8B,EAAUgM,GACrE,MAAMyB,GAAU,EAAIzN,EAAE8F,IAAM5H,EACtBwP,EAAQ1N,EAAE4F,IAAMzE,KAAKC,OAAOpB,EAAEwF,OAAOE,MAAQsG,GAAc1L,EAAOqB,WAExE,IAAIiM,EAAgB,KASpB,OARI,EAAA9I,YAAY4I,IAAU,EAAA5I,YAAY4I,GAAOD,KAC3CG,EAAgB,EAAA9I,YAAY4I,GAAOD,IAGjCnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAED,4CAA4C1P,EAAW8B,EAAU2M,GACvE,MAAMc,EAAQzN,EAAE8F,IAAM3E,KAAKC,OAAOpB,EAAEwF,OAAO0C,QAAUyE,GAAcrM,EAAOqB,WACpE+L,EAAQ1N,EAAE4F,IAAM1H,EAAI,EAE1B,IAAI0P,EAAgB,KASpB,OARI,EAAA9I,YAAY4I,IAAU,EAAA5I,YAAY4I,GAAOD,KAC3CG,EAAgB,EAAA9I,YAAY4I,GAAOD,IAGjCnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAGD,0CAA0C1P,EAAW8B,EAAUgM,GACrE,MAAMyB,EAAQzN,EAAE8F,IAAM5H,EAAI,EACpBwP,EAAQ1N,EAAE4F,IAAMzE,KAAKC,OAAOpB,EAAEwF,OAAOE,MAAQsG,GAAc1L,EAAOqB,WAClEgM,EAAwB3N,EAAE4F,IAAMzE,KAAKC,OAAOpB,EAAEwF,OAAOE,MAAQsG,EAAa,GAAK1L,EAAOqB,WAE5F,IAAIiM,EAAgB,KAcpB,OAbI,EAAA9I,YAAY4I,KACV,EAAA5I,YAAY4I,GAAOD,GACrBG,EAAgB,EAAA9I,YAAY4I,GAAOD,GAE5B,EAAA3I,YAAY6I,GAAuBF,KAC1CG,EAAgB,EAAA9I,YAAY6I,GAAuBF,KAInDnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,EAED,4CAA4C1P,EAAW8B,EAAU2M,GACvE,MAAMc,EAAQzN,EAAE8F,IAAM3E,KAAKC,OAAOpB,EAAEwF,OAAO0C,QAAUyE,GAAcrM,EAAOqB,WACpE+L,EAAQ1N,EAAE4F,IAAM1H,EAAI,EAE1B,IAAI0P,EAAgB,KASpB,OARI,EAAA9I,YAAY4I,IAAU,EAAA5I,YAAY4I,GAAOD,KAC3CG,EAAgB,EAAA9I,YAAY4I,GAAOD,IAGjCnN,EAAOgM,UAAUC,OACnB,EAAA3L,QAAQiN,iBAAiBJ,WAAeC,WAAeE,EAAgB,CAACA,EAAchI,IAAKgI,EAAc9H,KAAO,OAAQ,GAAI,IAAU,GAAJ5H,GAG7H0P,GA/+BX,YAwKiB,EAAAG,sBAA2C,EAAnBzN,EAAOqB,UAC/B,EAAAyK,gBAA0B,UAAO5K,UAAa8H,EAAUyE,sBACxD,EAAA1B,cAA0B,UAAO5K,WAA+C,EAAlC6H,EAAUyE,sBAy0BzE,MAAMC,EAAqB,CACzB9M,EAAG,EACHI,EAAG,EACHkE,OAAQ,CACNE,MAAW,EACXuC,SAAW,EACXxC,OAAW,EACXyC,QAAW,IAGT+F,EAAmB,IAAKD,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9D0I,EAAmB,IAAKF,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9D2I,EAAmB,IAAKH,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9D4I,EAAmB,IAAKJ,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9D6I,EAAmB,IAAKL,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9D8I,EAAmB,IAAKN,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9D+I,EAAmB,IAAKP,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAC9DgJ,EAAmB,IAAKR,EAAaxI,OAAQ,IAAKwI,EAAYxI,SAEpE,SAASsG,EAAcjB,EAAsBC,GAmB3C,OAlBAmD,EAAU/M,EAAI2J,EAAG3J,EAAI2J,EAAGtC,aAAa/G,UACrCyM,EAAU3M,EAAIuJ,EAAGvJ,EAAIuJ,EAAGtC,aAAa9G,WACrCwM,EAAUrI,IAAMzE,KAAKC,MAAM6M,EAAU3M,EAAIhB,EAAOqB,WAChDsM,EAAUnI,IAAM3E,KAAKC,MAAM6M,EAAU/M,EAAIZ,EAAOqB,WAChDsM,EAAUzI,OAAOE,MAAQuI,EAAU3M,EAAIhB,EAAOqB,UAC9CsM,EAAUzI,OAAOyC,SAAW3H,EAAOqB,UAAYsM,EAAUzI,OAAOE,MAChEuI,EAAUzI,OAAOC,OAASwI,EAAU/M,EAAIZ,EAAOqB,UAC/CsM,EAAUzI,OAAO0C,QAAU5H,EAAOqB,UAAYsM,EAAUzI,OAAOC,OAE/DyI,EAAUhN,EAAI4J,EAAG5J,EAAI4J,EAAGvC,aAAa/G,UACrC0M,EAAU5M,EAAIwJ,EAAGxJ,EAAIwJ,EAAGvC,aAAa9G,WACrCyM,EAAUtI,IAAMzE,KAAKC,MAAM8M,EAAU5M,EAAIhB,EAAOqB,WAChDuM,EAAUpI,IAAM3E,KAAKC,MAAM8M,EAAUhN,EAAIZ,EAAOqB,WAChDuM,EAAU1I,OAAOE,MAAQwI,EAAU5M,EAAIhB,EAAOqB,UAC9CuM,EAAU1I,OAAOyC,SAAW3H,EAAOqB,UAAYuM,EAAU1I,OAAOE,MAChEwI,EAAU1I,OAAOC,OAASyI,EAAUhN,EAAIZ,EAAOqB,UAC/CuM,EAAU1I,OAAO0C,QAAU5H,EAAOqB,UAAYuM,EAAU1I,OAAOC,OAExD,CAAEwI,EAAWC,GAGtB,SAAS/C,EAAcN,EAAsBC,GAmB3C,OAlBAqD,EAAUjN,EAAI2J,EAAG3J,EAAI2J,EAAGtC,aAAa/G,UACrC2M,EAAU7M,EAAIuJ,EAAGvJ,EAAIuJ,EAAGtC,aAAa9G,WACrC0M,EAAUvI,IAAMzE,KAAKC,MAAM+M,EAAU7M,EAAIhB,EAAOqB,WAChDwM,EAAUrI,IAAM3E,KAAKC,MAAM+M,EAAUjN,EAAIZ,EAAOqB,WAChDwM,EAAU3I,OAAOE,MAAQyI,EAAU7M,EAAIhB,EAAOqB,UAC9CwM,EAAU3I,OAAOyC,SAAW3H,EAAOqB,UAAYwM,EAAU3I,OAAOE,MAChEyI,EAAU3I,OAAOC,OAAS0I,EAAUjN,EAAIZ,EAAOqB,UAC/CwM,EAAU3I,OAAO0C,QAAU5H,EAAOqB,UAAYwM,EAAU3I,OAAOC,OAE/D2I,EAAUlN,EAAI4J,EAAG5J,EAAI4J,EAAGvC,aAAa/G,UACrC4M,EAAU9M,EAAIwJ,EAAGxJ,EAAIwJ,EAAGvC,aAAa9G,WACrC2M,EAAUxI,IAAMzE,KAAKC,MAAMgN,EAAU9M,EAAIhB,EAAOqB,WAChDyM,EAAUtI,IAAM3E,KAAKC,MAAMgN,EAAUlN,EAAIZ,EAAOqB,WAChDyM,EAAU5I,OAAOE,MAAQ0I,EAAU9M,EAAIhB,EAAOqB,UAC9CyM,EAAU5I,OAAOyC,SAAW3H,EAAOqB,UAAYyM,EAAU5I,OAAOE,MAChE0I,EAAU5I,OAAOC,OAAS2I,EAAUlN,EAAIZ,EAAOqB,UAC/CyM,EAAU5I,OAAO0C,QAAU5H,EAAOqB,UAAYyM,EAAU5I,OAAOC,OAExD,CAAE0I,EAAWC,GAGtB,SAASzC,EAAcd,EAAsBC,GAmB3C,OAlBAuD,EAAUnN,EAAI2J,EAAG3J,EAAI2J,EAAGtC,aAAa/G,UACrC6M,EAAU/M,EAAIuJ,EAAGvJ,EAAIuJ,EAAGtC,aAAa9G,WACrC4M,EAAUzI,IAAMzE,KAAKC,MAAMiN,EAAU/M,EAAIhB,EAAOqB,WAChD0M,EAAUvI,IAAM3E,KAAKC,MAAMiN,EAAUnN,EAAIZ,EAAOqB,WAChD0M,EAAU7I,OAAOE,MAAQ2I,EAAU/M,EAAIhB,EAAOqB,UAC9C0M,EAAU7I,OAAOyC,SAAW3H,EAAOqB,UAAY0M,EAAU7I,OAAOE,MAChE2I,EAAU7I,OAAOC,OAAS4I,EAAUnN,EAAIZ,EAAOqB,UAC/C0M,EAAU7I,OAAO0C,QAAU5H,EAAOqB,UAAY0M,EAAU7I,OAAOC,OAE/D6I,EAAUpN,EAAI4J,EAAG5J,EAAI4J,EAAGvC,aAAa/G,UACrC8M,EAAUhN,EAAIwJ,EAAGxJ,EAAIwJ,EAAGvC,aAAa9G,WACrC6M,EAAU1I,IAAMzE,KAAKC,MAAMkN,EAAUhN,EAAIhB,EAAOqB,WAChD2M,EAAUxI,IAAM3E,KAAKC,MAAMkN,EAAUpN,EAAIZ,EAAOqB,WAChD2M,EAAU9I,OAAOE,MAAQ4I,EAAUhN,EAAIhB,EAAOqB,UAC9C2M,EAAU9I,OAAOyC,SAAW3H,EAAOqB,UAAY2M,EAAU9I,OAAOE,MAChE4I,EAAU9I,OAAOC,OAAS6I,EAAUpN,EAAIZ,EAAOqB,UAC/C2M,EAAU9I,OAAO0C,QAAU5H,EAAOqB,UAAY2M,EAAU9I,OAAOC,OAExD,CAAE4I,EAAWC,GAGtB,SAAS/C,EAAcV,EAAsBC,GAmB3C,OAlBAyD,EAAUrN,EAAI2J,EAAG3J,EAAI2J,EAAGtC,aAAa/G,UACrC+M,EAAUjN,EAAIuJ,EAAGvJ,EAAIuJ,EAAGtC,aAAa9G,WACrC8M,EAAU3I,IAAMzE,KAAKC,MAAMmN,EAAUjN,EAAIhB,EAAOqB,WAChD4M,EAAUzI,IAAM3E,KAAKC,MAAMmN,EAAUrN,EAAIZ,EAAOqB,WAChD4M,EAAU/I,OAAOE,MAAQ6I,EAAUjN,EAAIhB,EAAOqB,UAC9C4M,EAAU/I,OAAOyC,SAAW3H,EAAOqB,UAAY4M,EAAU/I,OAAOE,MAChE6I,EAAU/I,OAAOC,OAAS8I,EAAUrN,EAAIZ,EAAOqB,UAC/C0M,EAAU7I,OAAO0C,QAAU5H,EAAOqB,UAAY4M,EAAU/I,OAAOC,OAE/D+I,EAAUtN,EAAI4J,EAAG5J,EAAI4J,EAAGvC,aAAa/G,UACrCgN,EAAUlN,EAAIwJ,EAAGxJ,EAAIwJ,EAAGvC,aAAa9G,WACrC+M,EAAU5I,IAAMzE,KAAKC,MAAMoN,EAAUlN,EAAIhB,EAAOqB,WAChD6M,EAAU1I,IAAM3E,KAAKC,MAAMoN,EAAUtN,EAAIZ,EAAOqB,WAChD6M,EAAUhJ,OAAOE,MAAQ8I,EAAUlN,EAAIhB,EAAOqB,UAC9C6M,EAAUhJ,OAAOyC,SAAW3H,EAAOqB,UAAY6M,EAAUhJ,OAAOE,MAChE8I,EAAUhJ,OAAOC,OAAS+I,EAAUtN,EAAIZ,EAAOqB,UAC/C2M,EAAU9I,OAAO0C,QAAU5H,EAAOqB,UAAY6M,EAAUhJ,OAAOC,OAExD,CAAE8I,EAAWC,K,8ECvmCtB,aAEA,OAEA,OACA,QAEA,8BACS,KAAAC,MAAkB,GAClB,KAAAC,MAAkB,GAWlB,KAAAC,kBAA4B,EAG5B,KAAAC,UAAoB,EACpB,KAAAC,OAAS,CACdC,MAAQ,EACRC,OAAQ,EACRC,IAAQ,EACRC,MAAQ,GAEH,KAAAC,QAAU,CACfJ,MAAQ,EACRC,OAAQ,EACRC,IAAQ,EACRC,MAAQ,GAEH,KAAAzJ,OAAS,CACdE,MAAW,EACXuC,SAAW,EACXxC,OAAW,EACXyC,QAAW,GAIH,cACRlH,KAAK6N,OAAOC,MAAQ,EACpB9N,KAAK6N,OAAOE,OAAQ,EACpB/N,KAAK6N,OAAOG,IAAQ,EACpBhO,KAAK6N,OAAOI,MAAQ,EAGZ,eACRjO,KAAKkO,QAAQF,IAAQ,EACrBhO,KAAKkO,QAAQD,MAAQ,EACrBjO,KAAKkO,QAAQJ,MAAQ,EACrB9N,KAAKkO,QAAQH,OAAQ,EAGb,2BACR/N,KAAKmO,MAAQnO,KAAKE,EAClBF,KAAKoO,MAAQpO,KAAKM,EAEdN,KAAK6N,OAAOC,OACV9N,KAAK6N,OAAOG,IAAMhO,KAAK6N,OAAOI,KAChCjO,KAAKmO,OAASnO,KAAKqO,iBAEnBrO,KAAKmO,OAASnO,KAAKsO,UAGnBtO,KAAK6N,OAAOE,QACV/N,KAAK6N,OAAOG,IAAMhO,KAAK6N,OAAOI,KAChCjO,KAAKmO,OAASnO,KAAKqO,iBAEnBrO,KAAKmO,OAASnO,KAAKsO,UAGnBtO,KAAK6N,OAAOG,KACVhO,KAAK6N,OAAOC,MAAQ9N,KAAK6N,OAAOE,MAClC/N,KAAKoO,OAASpO,KAAKqO,iBAEnBrO,KAAKoO,OAASpO,KAAKsO,UAGnBtO,KAAK6N,OAAOI,OACVjO,KAAK6N,OAAOC,MAAQ9N,KAAK6N,OAAOE,MAClC/N,KAAKoO,OAASpO,KAAKqO,iBAEnBrO,KAAKoO,OAASpO,KAAKsO,UAKf,yBAAyB/Q,EAAagR,GAC9C,GAAI,EAAAC,wBAAwBD,EAAmBhR,GAAI,CACjD,IAAIkR,EACAC,EACAH,EAAkBrO,EAAI3C,EAAE2C,EAC1BuO,EAAiBF,EAAkBrO,EAAIqO,EAAkBhH,aAAa/G,WAAcjD,EAAE2C,EAAI3C,EAAEgK,aAAa/G,WAChG+N,EAAkBrO,EAAI3C,EAAE2C,IACjCuO,EAAiBlR,EAAE2C,EAAI3C,EAAEgK,aAAa/G,WAAc+N,EAAkBrO,EAAIqO,EAAkBhH,aAAa/G,YAEvG+N,EAAkBjO,EAAI/C,EAAE+C,EAC1BoO,EAAiBH,EAAkBjO,EAAIiO,EAAkBhH,aAAa9G,YAAelD,EAAE+C,EAAI/C,EAAEgK,aAAa9G,YACjG8N,EAAkBjO,EAAI/C,EAAE+C,IACjCoO,EAAiBnR,EAAE+C,EAAI/C,EAAEgK,aAAa9G,YAAe8N,EAAkBjO,EAAIiO,EAAkBhH,aAAa9G,cAEvGgO,GAAiBA,GAAiBC,EACjCH,EAAkBjO,EAAI/C,EAAE+C,EAC1BN,KAAKkO,QAAQD,MAAO,EAEpBjO,KAAKkO,QAAQF,IAAK,IAEVU,GAAiBD,EAAgBC,KACvCH,EAAkBrO,EAAI3C,EAAE2C,EAC1BF,KAAKkO,QAAQH,OAAQ,EAErB/N,KAAKkO,QAAQJ,MAAO,IAMlB,iCACR,IAAInQ,EACJ,GAAI,EAAAmG,YAAY9D,KAAK4E,KAAM,CACzB,GAAI5E,KAAK6N,OAAOC,KAAM,EACpBnQ,EAAI,EAAAmG,YAAY9D,KAAK4E,KAAK5E,KAAK8E,IAAM,KAC5B9E,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAa7C,EAAEgR,KAAOhR,EAAE0B,QAC1DW,KAAKE,EAAIvC,EAAEgR,KAAOhR,EAAE0B,MAAQW,KAAKuH,aAAa/G,UAAY,GAG5D,MAAMoO,EAAczO,KAAKC,OAAOJ,KAAKM,EAAIN,KAAKuH,aAAa9G,WAAa,GAAKnB,EAAOqB,WAChFiO,GAAeA,IAAgB5O,KAAK4E,MACtCjH,EAAI,EAAAmG,YAAY8K,GAAa5O,KAAK8E,IAAM,KAC/B9E,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAa7C,EAAEgR,KAAOhR,EAAE0B,QACpDW,KAAK6N,OAAOI,MAAQjO,KAAKwE,OAAOE,OAAS1E,KAAKwE,OAAO0C,UACzDlH,KAAKE,EAAIvC,EAAEgR,KAAOhR,EAAE0B,MAAQW,KAAKuH,aAAa/G,UAAY,IAKhE,MAAMqO,EAAc1O,KAAKC,OAAOJ,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAcnB,EAAOqB,WAC5EkO,GAAeA,IAAgB7O,KAAK4E,MACtCjH,EAAI,EAAAmG,YAAY+K,GAAa7O,KAAK8E,IAAM,KAC/B9E,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAa7C,EAAEgR,KAAOhR,EAAE0B,QACpDW,KAAK6N,OAAOG,IAAMhO,KAAKwE,OAAOyC,UAAYjH,KAAKwE,OAAO0C,UAC1DlH,KAAKE,EAAIvC,EAAEgR,KAAOhR,EAAE0B,MAAQW,KAAKuH,aAAa/G,UAAY,IAKlE,GAAIR,KAAK6N,OAAOE,MAAO,EACrBpQ,EAAI,EAAAmG,YAAY9D,KAAK4E,KAAK5E,KAAK8E,IAAM,KAC5B9E,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAa7C,EAAEgR,OACjD3O,KAAKE,EAAIvC,EAAEgR,KAAO3O,KAAKuH,aAAa/G,UAAY,GAGlD,MAAMsO,EAAc3O,KAAKC,OAAOJ,KAAKM,EAAIN,KAAKuH,aAAa9G,WAAa,GAAKnB,EAAOqB,WAChFmO,GAAeA,IAAgB9O,KAAK4E,MACtCjH,EAAI,EAAAmG,YAAYgL,GAAa9O,KAAK8E,IAAM,KAC/B9E,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAa7C,EAAEgR,OAC3C3O,KAAK6N,OAAOI,MAAQjO,KAAKwE,OAAOE,OAAS1E,KAAKwE,OAAOC,SACzDzE,KAAKE,EAAIvC,EAAEgR,KAAO3O,KAAKuH,aAAa/G,UAAY,IAKtD,MAAMuO,EAAc5O,KAAKC,OAAOJ,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAcnB,EAAOqB,WAC5EmO,GAAeC,IAAgB/O,KAAK4E,MACtCjH,EAAI,EAAAmG,YAAYiL,GAAa/O,KAAK8E,IAAM,KAC/B9E,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAa7C,EAAEgR,OAC3C3O,KAAK6N,OAAOG,IAAMhO,KAAKwE,OAAOyC,UAAYjH,KAAKwE,OAAOC,SAC1DzE,KAAKE,EAAIvC,EAAEgR,KAAO3O,KAAKuH,aAAa/G,UAAY,KAM1D,GAAI,EAAAsD,YAAY9D,KAAK4E,IAAM,IACrB5E,KAAK6N,OAAOG,GAAI,EAClBrQ,EAAI,EAAAmG,YAAY9D,KAAK4E,IAAM,GAAG5E,KAAK8E,OAC1B9E,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAc9C,EAAEqR,KAAOrR,EAAE6B,SAC3DQ,KAAKM,EAAI3C,EAAEqR,KAAOrR,EAAE6B,OAASQ,KAAKuH,aAAa9G,WAAa,GAG9D,MAAMwO,EAAc9O,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKuH,aAAa/G,UAAY,GAAKlB,EAAOqB,WAC/EsO,GAAeA,IAAgBjP,KAAK8E,MACtCnH,EAAI,EAAAmG,YAAY9D,KAAK4E,IAAM,GAAGqK,KACrBjP,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAc9C,EAAEqR,KAAOrR,EAAE6B,SACrDQ,KAAK6N,OAAOE,OAAS/N,KAAKwE,OAAOyC,SAAWjH,KAAKwE,OAAOC,SAC5DzE,KAAKM,EAAI3C,EAAEqR,KAAOrR,EAAE6B,OAASQ,KAAKuH,aAAa9G,WAAa,IAKlE,MAAMyO,EAAc/O,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAalB,EAAOqB,WAC3EuO,GAAeA,IAAgBlP,KAAK8E,MACtCnH,EAAI,EAAAmG,YAAY9D,KAAK4E,IAAM,GAAGsK,KACrBlP,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAc9C,EAAEqR,KAAOrR,EAAE6B,SACrDQ,KAAK6N,OAAOC,MAAQ9N,KAAKwE,OAAOyC,SAAWjH,KAAKwE,OAAO0C,UAC3DlH,KAAKM,EAAI3C,EAAEqR,KAAOrR,EAAE6B,OAASQ,KAAKuH,aAAa9G,WAAa,IAMtE,GAAI,EAAAqD,YAAY9D,KAAK4E,IAAM,GAAI,CACzB5E,KAAK6N,OAAOI,OACdtQ,EAAI,EAAAmG,YAAY9D,KAAK4E,IAAM,GAAG5E,KAAK8E,OAC1B9E,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAc9C,EAAEqR,OAClDhP,KAAKM,EAAI3C,EAAEqR,KAAOhP,KAAKuH,aAAa9G,WAAa,GAIrD,MAAM0O,EAAchP,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKuH,aAAa/G,UAAY,GAAKlB,EAAOqB,WAC/EwO,GAAeA,IAAgBnP,KAAK8E,MACtCnH,EAAI,EAAAmG,YAAY9D,KAAK4E,IAAM,GAAGuK,KACrBnP,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAc9C,EAAEqR,OAC5ChP,KAAK6N,OAAOE,OAAS/N,KAAKwE,OAAOE,MAAQ1E,KAAKwE,OAAOC,SACzDzE,KAAKM,EAAI3C,EAAEqR,KAAOhP,KAAKuH,aAAa9G,WAAa,IAKvD,MAAM2O,EAAcjP,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKuH,aAAa/G,WAAalB,EAAOqB,WAC3EyO,GAAeA,IAAgBpP,KAAK8E,MACtCnH,EAAI,EAAAmG,YAAY9D,KAAK4E,IAAM,GAAGwK,KACrBpP,KAAKM,EAAIN,KAAKuH,aAAa9G,YAAc9C,EAAEqR,OAC5ChP,KAAK6N,OAAOC,MAAQ9N,KAAKwE,OAAOE,MAAQ1E,KAAKwE,OAAO0C,UACxDlH,KAAKM,EAAI3C,EAAEqR,KAAOhP,KAAKuH,aAAa9G,WAAa,KAOjD,4BACRT,KAAKyN,MAAMtI,KAAKnF,KAAKE,GACjBF,KAAKyN,MAAMxI,OAAS,GAAKjF,KAAKyN,MAAM4B,QAExCrP,KAAK0N,MAAMvI,KAAKnF,KAAKM,GACjBN,KAAK0N,MAAMzI,OAAS,GAAKjF,KAAK0N,MAAM2B,QAGhC,kBACR,MAAMC,EAAsB,GAEtBC,EAAKvP,KAAKyN,MAAMzN,KAAKyN,MAAMxI,OAAS,GAAKjF,KAAKyN,MAAMzN,KAAKyN,MAAMxI,OAAS,GACxEuK,EAAKxP,KAAK0N,MAAM1N,KAAK0N,MAAMzI,OAAS,GAAKjF,KAAK0N,MAAM1N,KAAK0N,MAAMzI,OAAS,GAE1EuK,EAAK,EACPF,EAAUnK,KAAK,EAAAsK,WAAWC,GAEnBF,EAAK,GACZF,EAAUnK,KAAK,EAAAsK,WAAWE,GAGxBJ,EAAK,EACPD,EAAUnK,KAAK,EAAAsK,WAAWG,GAEnBL,EAAK,GACZD,EAAUnK,KAAK,EAAAsK,WAAWI,GAG5B,MAAMC,EAAkBR,EAAUS,KAAK,KAAO/P,KAAKsP,WAAa,IAEhEtP,KAAKsP,UAAY,EAAAG,WAAWK,GAGpB,gBACR,MAAME,EAAahQ,KAAKyN,MAAMzN,KAAKyN,MAAMxI,OAAS,KAAOjF,KAAKyN,MAAMzN,KAAKyN,MAAMxI,OAAS,GAClFgL,EAAajQ,KAAK0N,MAAM1N,KAAK0N,MAAMzI,OAAS,KAAOjF,KAAK0N,MAAM1N,KAAK0N,MAAMzI,OAAS,GACxF,OAAI+K,IAAcC,K,6BChRtB,IAAKC,E,iDAAL,SAAKA,GACH,qBACA,yBACA,2BACA,yBAJF,CAAKA,MAAO,KAOZ,iBAAsBC,GACpB,OAAOD,EAAQC,GAAQC,WAAW,QAGpC,UAAeF,G,+ECTI,IAFnB,KAEuB,UAClBzJ,S,8ECHL,aAEA,gBACS,kBAAkB4J,SACjB,UAAQxO,KAAKwO,M,8ECJvB,MAAqBC,EAIZ,yBACL,OAAOtQ,KAAKuQ,aAEP,uBAAuBC,GACxBA,GAAO,GAAKA,GAAO,IACrBxQ,KAAKuQ,aAAeC,GAIjB,2BACL,OAAOxQ,KAAKyQ,eAEP,yBAAyBD,GAC1BA,GAAO,GAAKA,GAAO,IACrBxQ,KAAKyQ,eAAiBD,IAlB5B,YACiB,EAAAD,aAA0B,GAC1B,EAAAE,eAA0B,K,8ECF3C,aAEA,gBAAqBC,GACnB,OAAO,IAAIjL,QAAQ,CAACkL,EAASC,KAC3B,MAAMC,EAAU,IAAIC,eACpBD,EAAQE,KAAK,MAAOL,GAAK,GACzBG,EAAQG,aAAe,cACvBH,EAAQI,OAAS,KACf,UAAQC,gBAAgBL,EAAQM,SAAUlL,GACjC0K,EAAQ1K,KAGnB4K,EAAQO,W,8ECZZ,cAEA,gBACS,kBAAkB9L,GACvB,UAAQzD,KAAKyD,M,8ECJjB,aAIA,QAEA,wBAAwC,UAAxC,c,oBACS,KAAA+L,IAAc,uCAEd,KAAAC,iBAAmB,CACxBC,QAAS,GAGJ,KAAKC,EAAcC,GAExB,MAWMC,EAXsE,CAC1E/B,EAAI,CAAE7K,IAAK,EAAG6M,MAAM,GACpBC,GAAI,CAAE9M,IAAK,EAAG6M,MAAM,GACpB/B,EAAI,CAAE9K,IAAK,EAAG6M,MAAM,GACpBE,GAAI,CAAE/M,IAAK,EAAG6M,MAAM,GACpBjC,EAAI,CAAE5K,IAAK,EAAG6M,MAAM,GACpBG,GAAI,CAAEhN,IAAK,EAAG6M,MAAM,GACpB9B,EAAI,CAAE/K,IAAK,EAAG6M,MAAM,GACpBI,GAAI,CAAEjN,IAAK,EAAG6M,MAAM,IAGkBH,EAAMlC,WAGxC0C,EACK,CAAE9R,EAAG,EAAGI,EAAG,GADhB0R,EAEE,CAAE9R,EAAG+R,GAAkB3R,EAAG2R,KAE5B,EAAE/R,EAAC,EAAEI,EAAGiH,aAAc2K,GAASV,GAC7BtR,EAAGiS,EAAI7R,EAAG8R,GAAOX,GAEF,IAAnBD,EAAM5D,WACR4D,EAAM7D,kBAAoB,GAGxB+D,EAAeC,OACjB,EAAA/R,QAAQyS,OACR,EAAAzS,QAAQ0S,UACN,UAAOrR,OAAOf,GAAKA,EAAIiS,EAAKD,EAAK1R,WACjC,UAAOS,OAAOX,GAAKA,EAAI8R,EAAKF,EAAKzR,aAEnC,EAAAb,QAAQ2S,OAAO,EAAG,IAGpB,EAAA3S,QAAQ4S,UACNxS,KAAKyS,YACLT,EAAuB9R,EAAI8R,EAAoB9R,EAAIwR,EAAe5M,IAClEkN,EAAuB1R,EAAI0R,EAAoB1R,EAAIH,KAAKC,MAAMoR,EAAM7D,kBAAoB,GAxBtE,MA2BlB+D,EAAeC,MAAO,GAAsB,UAAO1Q,OAAOf,GAAKA,EAAIiS,EAAKD,EAAK1R,WAC7EkR,EAAeC,KAAO,EAAsB,UAAO1Q,OAAOX,GAAKA,EAAI8R,EAAKF,EAAKzR,YAC7E+Q,EAAMjK,aAAalI,MAAQ,EAC3BmS,EAAMjK,aAAa/H,OAAS,GAE1BkS,EAAeC,MACjB,EAAA/R,QAAQ8S,a,8EC1Dd,gBAQS,KAAKC,GACV,OAAO,IAAIlN,QAAQ,CAACkL,EAASiC,KAC3B5S,KAAKyS,YAAc,IAAII,MACvB7S,KAAKyS,YAAYK,IAAM9S,KAAKqR,IAC5BrR,KAAKyS,YAAYxB,OAAS,KACxB0B,IACAhC,U,8ECjBR,aAEA,OAEA,IAAIoC,EACAC,EAEJ,MAAMC,EAAoB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1D,IAAIC,EAEJ,gBAES,iBACLH,EAAgB,KAChB,IAAK,IAAI7V,EAAI,EAAGA,EAAI+V,EAAQhO,SAAU/H,EACpC+V,EAAQ/V,GAAK,EAIV,4BACL,GAAK6V,EAGE,CACL,MAAMI,EAAMC,YAAYD,MACxBH,EAAoBG,EAAMJ,EAE1BE,EAAQI,QAAQ,IAAOL,GACvBC,EAAQK,MACRJ,EAAMD,EAAQM,OAAO,CAACC,EAAKC,IAAYD,GAAOC,EAAS,GAAKR,EAAQhO,OAEpE8N,EAAgBI,OAVhBJ,EAAgBK,YAAYD,MAC5BD,EAAM,EAaH,iBACL,EAAAtT,QAAQwJ,YACN,EAAAxJ,QAAQ8T,UAAY,UACpB,EAAA9T,QAAQ+T,KAAO,gBAEf,EAAA/T,QAAQiN,iBAAiBqG,GAAOA,EAAIlJ,QAAQ,IAAM,YAAa,GAAI1K,EAAOG,cAAgB,IAC5F,EAAAG,QAAQ2J,Y,8ECzCZ,aAGA,OACA,OAEA,gBACS,SAGA,QAIA,UAIA,SACLvJ,KAAK4T,oBAGC,oBACN,EAAAhU,QAAQwJ,YACN,EAAAxJ,QAAQ8T,UAAY,UACpB,EAAA9T,QAAQ+T,KAAO,iBACf,EAAA/T,QAAQiN,qBAA+C,IAAxB,UAAKjK,oBAA4BtD,EAAOC,aAAe,EAAI,GAAID,EAAOG,cAAgB,EAAI,IAC3H,EAAAG,QAAQ2J,Y,8EC3BZ,aAGA,OACA,OACA,OAEA,8BACU,KAAAsK,iBAA2B,EAC3B,KAAAlG,kBAA4B,IAC5B,KAAAmG,qBAA+B,EAEhC,QACL1S,OAAOwG,iBAAiB,UAAW5H,KAAK+T,qBAEnC,OACL3S,OAAO4S,oBAAoB,UAAWhU,KAAK+T,qBAGtC,SACL/T,KAAK6T,kBAAoB7T,KAAK6T,iBAAmB,GAAK7T,KAAK2N,kBACvD3N,KAAK6T,kBAAoB7T,KAAK2N,kBAAoB,EACpD3N,KAAK8T,qBAAsB,EAE3B9T,KAAK8T,qBAAsB,EAKxB,SACL9T,KAAKiU,eAGC,eACN,EAAArU,QAAQwJ,YACN,EAAAxJ,QAAQ8T,UAAY,UAEpB,EAAA9T,QAAQ+T,KAAO,iBACf,EAAA/T,QAAQiN,SAAS,gCAAiCvN,EAAOC,aAAe,EAAI,IAAKD,EAAOG,cAAgB,EAAI,IACxGO,KAAK8T,sBACP,EAAAlU,QAAQ+T,KAAO,iBACf,EAAA/T,QAAQiN,SAAS,yBAA0BvN,EAAOC,aAAe,EAAI,IAAKD,EAAOG,cAAgB,EAAI,KAEzG,EAAAG,QAAQ2J,SAGF,sBACN,UAAKvH,aAAaG,SAAS,UAAYC,Y,8EC7C3C,aACA,OAEA,QACA,OACA,QAEA,QACA,OACA,QACA,OAEA,gBAKS,MAAM8R,GACPA,IAAkB,UAAYhS,QAChClC,KAAKmU,eAIF,KAAKC,GACNA,IAAc,UAAYlS,SAC5Bd,OAAOiT,OAAS,MAIb,SACL,UAAOC,sBACP,UAASxR,OAAO9C,KAAKgE,QACrBhE,KAAKgE,OAAOlB,SACZ9C,KAAKgF,IAAIlC,SAGJ,SACL9C,KAAKgF,IAAIT,OACTvE,KAAKgE,OAAOO,OAGN,eACNvE,KAAK+D,KAAO,IAAI,UAChB/D,KAAKgE,OAAS,IAAI,UAAO,IAAK,IAC9BhE,KAAKgF,IAAM,IAAI,UAAIhF,KAAK+D,KAAM/D,KAAKgE,QAEnC5C,OAAOiT,OAAS,KACd,UAAKrS,aAAaG,SAAS,UAAYD,SAGzC,UAASqS,KAAKvU,KAAKgE,QACnB,UAAMuQ,KAAKvU,KAAKgE,W,8ECrDpB,aAGA,QAEA,gBACS,YAAYA,GACjB7E,SAASyI,iBAAiB,UAAWhE,IAEnC,OAAQA,EAAE4Q,SACR,KAAK,EAAAC,cAAcC,EACjB1Q,EAAO6J,OAAOG,IAAK,EACnB,MACF,KAAK,EAAAyG,cAAcpN,EACjBrD,EAAO6J,OAAOC,MAAO,EACrB,MACF,KAAK,EAAA2G,cAAcxV,EACjB+E,EAAO6J,OAAOI,MAAO,EACrB,MACF,KAAK,EAAAwG,cAAcjX,EACjBwG,EAAO6J,OAAOE,OAAQ,EACtB,MACF,KAAK,EAAA0G,cAAcE,IACnB,KAAK,EAAAF,cAAczV,EACjB,UAAK4V,iBAMXzV,SAASyI,iBAAiB,QAAShE,IACjC,OAAQA,EAAE4Q,SACR,KAAK,EAAAC,cAAcC,EACjB1Q,EAAO6J,OAAOG,IAAK,EACnB,MACF,KAAK,EAAAyG,cAAcpN,EACjBrD,EAAO6J,OAAOC,MAAO,EACrB,MACF,KAAK,EAAA2G,cAAcxV,EACjB+E,EAAO6J,OAAOI,MAAO,EACrB,MACF,KAAK,EAAAwG,cAAcjX,EACjBwG,EAAO6J,OAAOE,OAAQ,Q,8EC1CnB,EAAA0G,cAAgB,CAC3BI,MAAO,GACPF,IAAK,GACLD,EAAG,GACHrN,EAAG,GACHpI,EAAG,GACHzB,EAAG,GACHwB,EAAG,K,8ECNL,aAEA,MAAqB8V,EACZ,cAAc9Q,GACnB,MAAM+Q,EAAWC,UAAUC,cACvBF,EAAS,KACX/U,KAAKkV,eAAeH,EAAS,GAAI/Q,GACjChE,KAAKmV,aAAaJ,EAAS,IAC3B/U,KAAKoV,cAAcL,EAAS,GAAI/Q,IAM5B,sBAAsBqR,EAAcrR,GAC1C,MAAMsR,GAAyBD,EAAQE,KAAK,GAAGvL,QAAQ,GACnDsL,EAAgB,EAClBtR,EAAO6J,OAAOE,OAAQ,EAEfuH,EAAgB,EACvBtR,EAAO6J,OAAOC,MAAO,GAGrB9J,EAAO6J,OAAOC,MAAQ,EACtB9J,EAAO6J,OAAOE,OAAQ,GAGxB,MAAMyH,GAAyBH,EAAQE,KAAK,GAAGvL,QAAQ,GACnDwL,EAAgB,EAClBxR,EAAO6J,OAAOI,MAAO,EAEduH,EAAgB,EACvBxR,EAAO6J,OAAOG,IAAK,GAGnBhK,EAAO6J,OAAOG,IAAO,EACrBhK,EAAO6J,OAAOI,MAAO,GAIjB,oBAAoBoH,GAC1B,MAAMI,EAAWJ,EAAQE,KAAK,GACxBG,EAAWL,EAAQE,KAAK,GACD,IAAxBE,EAASzL,QAAQ,KACpB,UAAM9J,GAAKuV,EAAWzV,KAAK2V,aAEA,IAAxBD,EAAS1L,QAAQ,KACpB,UAAM1J,GAAKoV,EAAW1V,KAAK2V,aAIvB,qBAAqBN,EAAcrR,GAC9BqR,EAAQO,QAAQ,GACpBC,QACL7R,EAAOgE,aAAY,GAGnBhE,EAAOgE,aAAY,IAvDzB,YAUiB,EAAA2N,YAAsB,I,8ECbvC,aAGA,8BACS,KAAAjV,KAAepB,EAAOG,cAAgBH,EAAOqB,UAC7C,KAAAC,KAAetB,EAAOC,aAAgBD,EAAOqB,a,8ECLtD,aAEA,OAEA,OACA,OACA,OACA,OACA,OACA,QACA,QAGA,QAEA,QAEA,wBAA2C,UAEzC,YACET,EACAI,EACA8E,EACU0Q,GAEVC,MAAM7V,EAAGI,EAAG,IAAI,UAAa,GAAI,IAAK,EAAG8E,GAF/B,KAAA0Q,sBALF,KAAAE,OAAyB,UAAQ3N,KAQzCrI,KAAKiW,oBAGA,OAAOjS,EAAgBN,GAC5B1D,KAAKkW,eACLlW,KAAKmW,2BACLnW,KAAKoW,4BAELpW,KAAKqW,MAAWrW,KAAKsW,eACrBtW,KAAK4N,SAAW5N,KAAKuW,gBAErBvW,KAAKwW,iCACLxW,KAAKyW,4BAA4BzS,GACjChE,KAAK0W,kCAAkC1S,GACvChE,KAAK2W,mBAAqB,EAAAC,qBACxB,CAAE1W,EAAG8D,EAAO9D,EAAGI,EAAG0D,EAAO1D,GACzB,CAAEJ,EAAGF,KAAKE,EAAKI,EAAGN,KAAKM,IAEzBN,KAAK6W,2CACH,UAAUC,gDAAgD9W,KAAMgE,GAClEhE,KAAK+W,iBAAiB/S,GAEtBhE,KAAKgX,OACLhX,KAAKiX,kBACLjX,KAAKkX,mBAED,UAAKlV,aAAaC,aAAe,UAAYC,QAC/ClC,KAAKmX,mBAIF,KAAKnT,GACVhE,KAAKoX,iBAAiBpT,GAatBhE,KAAKgW,OAAOzR,KAAKvE,KAAM,CAAEE,EAAG8D,EAAO9D,EAAGI,EAAG0D,EAAO1D,IAG3C,WAAW+W,GAChB,UAAQC,eACRtX,KAAKuX,QAAUF,EACXrX,KAAKuX,QAAU,EACjBvX,KAAKwX,MAEL,UAAQF,eAIL,MACL,UAAQG,iBACRzX,KAAKoE,OAAQ,EAGL,mBACRpE,KAAK2N,mBAAqB3N,KAAK2N,kBAAoB,IAAO3N,KAAKgW,OAAO1E,iBAAiBC,QAGjF,iBAAiBvN,GACnBhE,KAAK6W,4CAC0B,IAA7B7W,KAAK8V,sBACP9V,KAAK0X,iBAAmB,EAAAC,kBACtBxX,KAAK6L,MAAM7L,KAAK4K,IAAI/G,EAAOY,IAAM5E,KAAK4E,KAAO,GAC7CzE,KAAK6L,MAAM7L,KAAK4K,IAAI/G,EAAOc,IAAM9E,KAAK8E,KAAO,GAC7C9E,KAAKuH,cAEPvH,KAAK4X,aAAe,EAAAC,iBAAiB7X,KAAMgE,EAAQhE,KAAK0X,mBAG1D1X,KAAK8V,qBAAuB9V,KAAK8V,oBAAsB,GAAK9V,KAAK8X,kBAE7D9X,KAAK4X,aAAa3S,OAAS,GAC7BjF,KAAK+X,0BAIH/X,KAAK0X,mBACP1X,KAAK0X,iBAAmB,MAEtB1X,KAAK4X,eACP5X,KAAK4X,aAAe,IAEtB5X,KAAKgY,kBAAkBhU,IAInB,wBAEN,IAAIiU,EAAYjY,KAAK4X,aAAa5X,KAAK4X,aAAa3S,OAAS,GAAG/E,EAC5DgY,EAAYlY,KAAK4X,aAAa5X,KAAK4X,aAAa3S,OAAS,GAAG3E,EAE9DN,KAAK4X,aAAa3S,OAAS,GAC3B9E,KAAK4K,IAAIkN,EAAYjY,KAAKE,GAAK,GAC/BC,KAAK4K,IAAImN,EAAYlY,KAAKM,GAAK,IAE/BN,KAAK4X,aAAatE,MAClB2E,EAAYjY,KAAK4X,aAAa5X,KAAK4X,aAAa3S,OAAS,GAAG/E,EAC5DgY,EAAYlY,KAAK4X,aAAa5X,KAAK4X,aAAa3S,OAAS,GAAG3E,GAE9DN,KAAKmY,YAAYF,EAAWC,GAGtB,kBAAkBlU,GACpBhE,KAAK2W,mBAAqB3W,KAAKuH,aAAalI,MAC9CW,KAAKmY,YAAYnU,EAAO9D,EAAG8D,EAAO1D,GAGlCN,KAAKoY,cAID,YAAYlY,EAAWI,GAC7BN,KAAKoY,cAEDpY,KAAKE,EAAIA,EACXF,KAAK6N,OAAOE,OAAQ,EAEb/N,KAAKE,EAAIA,IAChBF,KAAK6N,OAAOC,MAAO,GAEjB9N,KAAKM,EAAIA,EACXN,KAAK6N,OAAOI,MAAO,EAEZjO,KAAKM,EAAIA,IAChBN,KAAK6N,OAAOG,IAAK,GAKb,OACFhO,KAAK6N,OAAOC,OAAS9N,KAAKkO,QAAQJ,OAChC9N,KAAK6N,OAAOG,IAAMhO,KAAK6N,OAAOI,KAChCjO,KAAKE,GAAKF,KAAKqO,iBAEfrO,KAAKE,GAAKF,KAAKsO,UAGftO,KAAK6N,OAAOE,QAAU/N,KAAKkO,QAAQH,QACjC/N,KAAK6N,OAAOG,IAAMhO,KAAK6N,OAAOI,KAChCjO,KAAKE,GAAKF,KAAKqO,iBAEfrO,KAAKE,GAAKF,KAAKsO,UAGftO,KAAK6N,OAAOG,KAAOhO,KAAKkO,QAAQF,KAC9BhO,KAAK6N,OAAOC,MAAQ9N,KAAK6N,OAAOE,MAClC/N,KAAKM,GAAKN,KAAKqO,iBAEfrO,KAAKM,GAAKN,KAAKsO,UAGftO,KAAK6N,OAAOI,OAASjO,KAAKkO,QAAQD,OAChCjO,KAAK6N,OAAOC,MAAQ9N,KAAK6N,OAAOE,MAClC/N,KAAKM,GAAKN,KAAKqO,iBAEfrO,KAAKM,GAAKN,KAAKsO,UAGnBtO,KAAKiW,oBAIC,oBACNjW,KAAK4E,IAAMzE,KAAKC,MAAMJ,KAAKM,EAAIhB,EAAOqB,WACtCX,KAAK8E,IAAM3E,KAAKC,MAAMJ,KAAKE,EAAIZ,EAAOqB,WAIhC,mBACNX,KAAKwE,OAAOE,MAAQ1E,KAAKM,EAAIhB,EAAOqB,UACpCX,KAAKwE,OAAOyC,SAAW3H,EAAOqB,UAAYX,KAAKwE,OAAOE,MACtD1E,KAAKwE,OAAOC,OAASzE,KAAKE,EAAIZ,EAAOqB,UACrCX,KAAKwE,OAAO0C,QAAU5H,EAAOqB,UAAYX,KAAKwE,OAAOC,OAI/C,iBAAiBT,GACvB,EAAApE,QAAQsJ,YAAclJ,KAAKqY,iBAC3B,EAAAzY,QAAQuJ,UAAY,GACpB,EAAAvJ,QAAQwJ,YAGN,EAAAxJ,QAAQyJ,OAAQ,GAAM,UAAOpI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAKF,KAAKuH,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,GAAKN,KAAKuH,aAAa9G,YAC5J,EAAAb,QAAQ0J,QAAQ,GAAM,UAAOrI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAKF,KAAKuH,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,GAAKN,KAAKuH,aAAa9G,YAC5J,EAAAb,QAAQ0J,QAAQ,GAAM,UAAOrI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAKF,KAAKuH,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,GAAKN,KAAKuH,aAAa9G,YAC5J,EAAAb,QAAQ0J,OAAQ,GAAM,UAAOrI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAKF,KAAKuH,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,GAAKN,KAAKuH,aAAa9G,YAC5J,EAAAb,QAAQ0J,OAAQ,GAAM,UAAOrI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAKF,KAAKuH,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,GAAKN,KAAKuH,aAAa9G,YAC9J,EAAAb,QAAQ2J,SAIF,gBAAgBvF,GAClBhE,KAAK6W,2CACP,EAAAjX,QAAQsJ,YAAc,UAEtB,EAAAtJ,QAAQsJ,YAAc,UAExB,EAAAtJ,QAAQuJ,UAAY,GACpB,EAAAvJ,QAAQwJ,YACN,EAAAxJ,QAAQyJ,OAAO,UAAOpI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAI,UAAOe,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,IACzF,EAAAV,QAAQ0J,OAAO,UAAOrI,OAAOf,EAAG,UAAOe,OAAOX,GAChD,EAAAV,QAAQ2J,SAIF,eAAevK,EAAUgF,GAC/B,EAAApE,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQuJ,UAAY,GACpB,EAAAvJ,QAAQwJ,YACN,EAAAxJ,QAAQyJ,OAAO,UAAOpI,OAAOf,GAAKF,KAAKE,EAAI8D,EAAO9D,GAAI,UAAOe,OAAOX,GAAKN,KAAKM,EAAI0D,EAAO1D,IACzF,EAAAV,QAAQ0J,OAAO,UAAOrI,OAAOf,GAAKlB,EAAEkB,EAAI8D,EAAO9D,GAAI,UAAOe,OAAOX,GAAKtB,EAAEsB,EAAI0D,EAAO1D,IACrF,EAAAV,QAAQ2J,Y,8ECtPZ,aAEA,OACA,OACA,OAEA,OAwCA,SAAgB+O,EAASC,EAAgBvU,EAAgBiF,GACvD,EAAArJ,QAAQsJ,YAAcD,EACtB,EAAArJ,QAAQuJ,UAAY,GACpB,EAAAvJ,QAAQwJ,YAGN,EAAAxJ,QAAQyJ,OAAQ,GAAM,UAAOpI,OAAOf,GAAKqY,EAAKrY,EAAI8D,EAAO9D,GAAKqY,EAAKhR,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,GAAKiY,EAAKjY,EAAI0D,EAAO1D,GAAKiY,EAAKhR,aAAa9G,YAC5J,EAAAb,QAAQ0J,QAAQ,GAAM,UAAOrI,OAAOf,GAAKqY,EAAKrY,EAAI8D,EAAO9D,GAAKqY,EAAKhR,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,GAAKiY,EAAKjY,EAAI0D,EAAO1D,GAAKiY,EAAKhR,aAAa9G,YAC5J,EAAAb,QAAQ0J,QAAQ,GAAM,UAAOrI,OAAOf,GAAKqY,EAAKrY,EAAI8D,EAAO9D,GAAKqY,EAAKhR,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,GAAKiY,EAAKjY,EAAI0D,EAAO1D,GAAKiY,EAAKhR,aAAa9G,YAC5J,EAAAb,QAAQ0J,OAAQ,GAAM,UAAOrI,OAAOf,GAAKqY,EAAKrY,EAAI8D,EAAO9D,GAAKqY,EAAKhR,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,GAAKiY,EAAKjY,EAAI0D,EAAO1D,GAAKiY,EAAKhR,aAAa9G,YAC5J,EAAAb,QAAQ0J,OAAQ,GAAM,UAAOrI,OAAOf,GAAKqY,EAAKrY,EAAI8D,EAAO9D,GAAKqY,EAAKhR,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,GAAKiY,EAAKjY,EAAI0D,EAAO1D,GAAKiY,EAAKhR,aAAa9G,YAC9J,EAAAb,QAAQ2J,SAER,EAAA3J,QAAQwJ,YACN,EAAAxJ,QAAQ6L,IACN,UAAOxK,OAAOf,GAAKqY,EAAKrY,EAAI8D,EAAO9D,GACnC,UAAOe,OAAOX,GAAKiY,EAAKjY,EAAI0D,EAAO1D,GACnC,EACA,EACC,EAAIH,KAAKqK,IAEd,EAAA5K,QAAQ2J,SAxDV,6BAAkCiP,EAAkBC,EAAkBvG,GACpE,MAAMwG,EAAmB,GAIzB,IAAI/T,EAAW6T,EAAW,UAAO3X,SAFf,EAGdgE,EAAW4T,EAAW,UAAO3X,SAFf,EAGlB,MAAM6X,EAASH,EAAW,UAAO3X,SAJf,EAKZ+X,EAASH,EAAW,UAAO3X,SAJf,EAMd6D,EAAW,IAAKA,EAAW,GAC3BE,EAAW,IAAKA,EAAW,GAE/B,IAAK,IAAID,EAAMD,EAAUC,EAAM+T,IAAU/T,EACvC,IAAK,IAAIE,EAAMD,EAAW,EAAGC,EAAM8T,IAAU9T,EACtC,EAAAhB,YAAYc,IAAS,EAAAd,YAAYc,GAAKE,IACrCA,EAAM,GAAKF,EAAM,GACnB8T,EAAKvT,KAAK,IAAI0T,EAAS,CACrB3Y,EAAG4E,EAAMxF,EAAOqB,UAAYrB,EAAOqB,UAAY,EAC/CL,EAAGsE,EAAMtF,EAAOqB,UAAYrB,EAAOqB,UAAY,GAC9CuR,IAMX,OAAOwG,GAGT,yBAA8BA,EAAkB1U,EAAgBiF,GAC1DyP,GACFA,EAAKvU,QAAQoU,GAAQD,EAASC,EAAMvU,EAAQiF,KAIhD,aAwBA,4BAAiCuI,EAAcxN,EAAgB0T,GAC7D,MAAMoB,EAAY,IAAID,EAAS7U,EAAQA,EAAOuD,cACxCwR,EAAY,IAAIF,EAASrH,EAAQA,EAAMjK,cAE7CmQ,EAAiBvS,KAAK2T,GAEtBC,EAAUC,EAAI,EACdD,EAAUE,EAAIF,EAAUG,UAAUJ,GAElC,MAAMK,EAA6B,CAAEJ,GAErC,IAAIK,EAEJ,KAAOD,EAAelU,OAAS,GAAKmU,IAAgBN,GAAU,CAG5D,IAFAK,EAAeE,KAAK,CAAChS,EAAaC,IAAgBD,EAAE4R,EAAI3R,EAAE2R,GAEnDE,EAAelU,OAAS,IAAmC,IAA9BkU,EAAe,GAAGG,SACpDH,EAAe9J,QAGjB,GAAI8J,EAAelU,QAAU,EAC3B,OAGFmU,EAAcD,EAAe9J,SACjBiK,SAAU,EAGtBF,EAAYG,eAAiB,IAAK7B,GAC/B/T,OAAO4U,OAEHA,EAAKzT,MAAQsU,EAAYtU,KAAWyT,EAAK3T,MAAQwU,EAAYxU,KAC7D2T,EAAKzT,MAAQsU,EAAYtU,KAAWyT,EAAK3T,MAAQwU,EAAYxU,IAAM,GACnE2T,EAAKzT,MAAQsU,EAAYtU,IAAM,GAAKyT,EAAK3T,MAAQwU,EAAYxU,KAC7D2T,EAAKzT,MAAQsU,EAAYtU,KAAWyT,EAAK3T,MAAQwU,EAAYxU,IAAM,GACnE2T,EAAKzT,MAAQsU,EAAYtU,IAAM,GAAKyT,EAAK3T,MAAQwU,EAAYxU,OAE5D2T,EAAKzT,MAAQsU,EAAYtU,IAAM,GAAKyT,EAAK3T,MAAQwU,EAAYxU,IAAM,GAEhE,EAAAd,YAAYyU,EAAK3T,MAAwD,OAA5C,EAAAd,YAAYyU,EAAK3T,KAAS2T,EAAKzT,IAAM,IAClE,EAAAhB,YAAYyU,EAAK3T,IAAM,IAAkD,OAA5C,EAAAd,YAAYyU,EAAK3T,IAAM,GAAG2T,EAAKzT,QAI/DyT,EAAKzT,MAAQsU,EAAYtU,IAAM,GAAKyT,EAAK3T,MAAQwU,EAAYxU,IAAM,GAEhE,EAAAd,YAAYyU,EAAK3T,MAAwD,OAA5C,EAAAd,YAAYyU,EAAK3T,KAAS2T,EAAKzT,IAAM,IAClE,EAAAhB,YAAYyU,EAAK3T,IAAM,IAAkD,OAA5C,EAAAd,YAAYyU,EAAK3T,IAAM,GAAG2T,EAAKzT,QAI/DyT,EAAKzT,MAAQsU,EAAYtU,IAAM,GAAKyT,EAAK3T,MAAQwU,EAAYxU,IAAM,GAEhE,EAAAd,YAAYyU,EAAK3T,MAAwD,OAA5C,EAAAd,YAAYyU,EAAK3T,KAAS2T,EAAKzT,IAAM,IAClE,EAAAhB,YAAYyU,EAAK3T,IAAM,IAAkD,OAA5C,EAAAd,YAAYyU,EAAK3T,IAAM,GAAG2T,EAAKzT,QAI/DyT,EAAKzT,MAAQsU,EAAYtU,IAAM,GAAKyT,EAAK3T,MAAQwU,EAAYxU,IAAM,GAEhE,EAAAd,YAAYyU,EAAK3T,MAAwD,OAA5C,EAAAd,YAAYyU,EAAK3T,KAAS2T,EAAKzT,IAAM,IAClE,EAAAhB,YAAYyU,EAAK3T,IAAM,IAAkD,OAA5C,EAAAd,YAAYyU,EAAK3T,IAAM,GAAG2T,EAAKzT,QAMvEsU,EAAYG,eACTvU,IAAIuT,KACkB,IAAjBA,EAAKe,SACPH,EAAehU,KAAKoT,GAItB,MAAMiB,EAAyBJ,EAAYJ,EAAI,EAAApC,qBAAqBwC,EAAab,GAQjF,OANIiB,EAAyBjB,EAAKS,IAChCT,EAAKkB,OAASL,EACdb,EAAKS,EAAIQ,EACTjB,EAAKU,EAAIV,EAAKS,EAAIT,EAAKW,UAAUJ,IAG5BP,IAIb,MAAMG,EAAO,GACb,GAAII,EAASW,OAAQ,CACnB,IAAI9a,EAAcma,EAClB,KAAOna,EAAE8a,QACPf,EAAKvT,KAAKxG,GACVA,EAAIA,EAAE8a,OAGV,OAAOf,GAGT,MAAaG,EAmBX,YAAYrN,EAAoB0G,GAdzB,KAAA1N,OAAS,CACdE,MAAW,EACXuC,SAAW,EACXxC,OAAW,EACXyC,QAAW,GAIN,KAAAoS,SAAmB,EACnB,KAAAL,EAAYS,IACZ,KAAAV,EAAYU,IACZ,KAAAD,OAAmB,KAIxBzZ,KAAKE,EAAIsL,EAAYtL,EACrBF,KAAKM,EAAIkL,EAAYlL,EACrBN,KAAKuH,aAAe,IAAI,UAAa2K,EAAK7S,MAAO6S,EAAK1S,QACtDQ,KAAKkX,mBACLlX,KAAKiW,oBAGA,UAAU6C,GACf,OAAO,EAAAlC,qBAAqB5W,KAAM8Y,GAI5B,mBACN9Y,KAAKwE,OAAOE,MAAQ1E,KAAKM,EAAIhB,EAAOqB,UACpCX,KAAKwE,OAAOyC,SAAW3H,EAAOqB,UAAYX,KAAKwE,OAAOE,MACtD1E,KAAKwE,OAAOC,OAASzE,KAAKE,EAAIZ,EAAOqB,UACrCX,KAAKwE,OAAO0C,QAAU5H,EAAOqB,UAAYX,KAAKwE,OAAOC,OAI/C,oBACNzE,KAAK4E,IAAMzE,KAAKC,MAAMJ,KAAKM,EAAIhB,EAAOqB,WACtCX,KAAK8E,IAAM3E,KAAKC,MAAMJ,KAAKE,EAAIZ,EAAOqB,YA1C1C,c,8ECvKA,aAGA,QAIA,OAEA,wBAA4C,UAgB1C,YACST,EACAI,EACPiH,EACA+G,EACAlJ,GAEA2Q,QANO,KAAA7V,IACA,KAAAI,IAjBF,KAAA8D,OAAiB,EACjB,KAAAuV,UAAoB,IAOjB,KAAA7D,oBAA8B,EAC9B,KAAAgC,kBAA4B,GAE5B,KAAAF,aAA2B,GAYnC5X,KAAK4Z,iBAAiBxU,GAEtBpF,KAAKsO,SAAWA,EAChBtO,KAAKqO,iBAAmBlO,KAAK6L,MAAM7L,KAAK0Z,IAAI,IAAM7Z,KAAKsO,UAEvDtO,KAAKuH,aAAeA,EAMf,WAAW/D,EAAiBC,GACjC,MAAMqW,EAAqC,EAAnBxa,EAAOqB,UAC/B,OACER,KAAK4K,IAAI/K,KAAKE,EAAIsD,GAAYlE,EAAOC,aAAgB,EAAKua,GAC1D3Z,KAAK4K,IAAI/K,KAAKM,EAAImD,GAAYnE,EAAOG,cAAgB,EAAKqa,EAOpD,4BAA4B9V,GACpC,MAAM+V,EAAiB,CAAE7Z,EAAGF,KAAKmO,MAAO7N,EAAGN,KAAKoO,MAAO7G,aAAcvH,KAAKuH,cAC1EvH,KAAKga,yBAAyBhW,EAAQ+V,GAG9B,kCAAkC/V,GAC1C,MAAM+V,EAAiB,CAAE7Z,EAAGF,KAAKmO,MAAO7N,EAAGN,KAAKoO,MAAO7G,aAAcvH,KAAKuH,cACrC,EAAAhE,mBAAmBvD,KAAKE,EAAGF,KAAKM,GAExC6D,QAAQP,IAC/B5D,OAAS4D,GACX5D,KAAKga,yBAAyBpW,EAAGmW,KAK7B,eACR,MAAME,EAAYja,KAAKyN,MAAMyM,MAAMha,GAAKA,IAAMF,KAAKyN,MAAM,IACnD0M,EAAYna,KAAK0N,MAAMwM,MAAM5Z,GAAKA,IAAMN,KAAK0N,MAAM,IACzD,OAAIuM,IAAaE,EAQT,iBACR,OAAIna,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACf,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,QAA2B,GAAjBvX,KAAK2Z,UACtB,UACE3Z,KAAKuX,OAASvX,KAAK2Z,UACrB,UACE3Z,KAAKuX,SAAWvX,KAAK2Z,UACvB,eADF,EAKD,iBAAiBvU,IACnBA,EAAmB,GAAOA,EAAmB,KAC/CA,EAAmB,GAErBpF,KAAKuX,OAASvX,KAAK2Z,UAAYvU,K,8EChHnC,SAAYqK,GACV,QACA,UACA,QACA,UACA,QACA,UACA,QACA,UARF,CAAY,EAAAA,aAAA,EAAAA,WAAU,M,8ECCtB,cACA,QAEA,gBACS,wBAAwB7K,EAAaE,EAAaqL,GACvD,OAAI,EAAAiK,MAAMjK,GACD,UAAWkK,UAAUzV,EAAKE,EAAKqL,GAG/B,Q,8ECVb,aAEA,QACA,QAEA,gBACS,iBAAiBvL,EAAaE,EAAaqL,GAChD,OAAQA,GACN,KAAK,UAAQmK,QACX,OAAO,IAAI,UAAI1V,EAAKE,EAAKxF,EAAOqB,UAAWrB,EAAOqB,UAAW,WAAW,GAC1E,KAAK,UAAQ4Z,SACX,OAAO,IAAI,UAAI3V,EAAKE,EAAKxF,EAAOqB,UAAWrB,EAAOqB,UAAW,WAC/D,KAAK,UAAQ6Z,QACX,OAAO,IAAI,UAAI5V,EAAKE,EAAKxF,EAAOqB,UAAWrB,EAAOqB,UAAW,WAC/D,QACE,MAAM,IAAIyG,MAAM,oB,8ECfxB,aAEA,OACA,OACA,QAEA,wBAAiC,UAC/B,OACE,EAAAxH,QAAQsJ,YAAclJ,KAAKiJ,MAC3B,EAAArJ,QAAQuJ,UAAY,EACpB,EAAAvJ,QAAQwJ,YAEN,EAAAxJ,QAAQyJ,OAAQ,GAAMrJ,KAAKE,EAAuB,GAAMF,KAAKM,GAC7D,EAAAV,QAAQ0J,QAAQ,GAAMtJ,KAAKE,EAAIZ,EAAOqB,UAAY,GAAMX,KAAKM,GAC7D,EAAAV,QAAQ0J,QAAQ,GAAMtJ,KAAKE,EAAIZ,EAAOqB,WAAY,GAAMX,KAAKM,EAAIhB,EAAOqB,WACxE,EAAAf,QAAQ0J,OAAQ,GAAMtJ,KAAKE,GAAuB,GAAMF,KAAKM,EAAIhB,EAAOqB,WACxE,EAAAf,QAAQ0J,OAAQ,GAAMtJ,KAAKE,EAAuB,GAAMF,KAAKM,GAG7D,EAAAV,QAAQyJ,OAAQ,GAAMrJ,KAAKE,EAAuB,GAAMF,KAAKM,GAC7D,EAAAV,QAAQ0J,QAAQ,GAAMtJ,KAAKE,EAAIZ,EAAOqB,WAAY,GAAMX,KAAKM,EAAIhB,EAAOqB,WACxE,EAAAf,QAAQyJ,QAAQ,GAAMrJ,KAAKE,EAAIZ,EAAOqB,UAAY,GAAMX,KAAKM,GAC7D,EAAAV,QAAQ0J,OAAQ,GAAMtJ,KAAKE,GAAuB,GAAMF,KAAKM,EAAIhB,EAAOqB,WAC1E,EAAAf,QAAQ2J,SAGH,WAAW8N,GAChB,UAAQoD,kB,8EC3BZ,aAEA,gBAME,YACS7V,EACAE,EACAzF,EACAG,EACAyJ,EACAyR,GAAwB,GALxB,KAAA9V,MACA,KAAAE,MACA,KAAAzF,QACA,KAAAG,SACA,KAAAyJ,QACA,KAAAyR,eAEP1a,KAAK2O,KAAO7J,EAAMxF,EAAOqB,UACzBX,KAAKgP,KAAOpK,EAAMtF,EAAOqB,a,myECjB7B,aAEA,OACA,QACA,OACA,OAEA,QACA,OACA,QACA,QAEA,OAEA,wBAAoC,UAQlC,YACST,EACAI,GAGPyV,QAJO,KAAA7V,IACA,KAAAI,IATF,KAAA8D,OAAiB,EACjB,KAAAuW,SAAmB,EACnB,KAAAC,gBAAkB,GACjB,KAAAC,UAAW,EACX,KAAAC,iBAAmB,EACnB,KAAAC,YAA4B,GASlC/a,KAAKsO,SAAW,EAChBtO,KAAKqO,iBAAmBlO,KAAK6L,MAAM7L,KAAK0Z,IAAI,IAAM7Z,KAAKsO,UAEvDtO,KAAKuH,aAAe,IAAI,UAAa,GAAI,IAEzCvH,KAAKiW,oBAGA,SACLjW,KAAKkW,eACLlW,KAAKmW,2BAELnW,KAAKgb,+BACLhb,KAAKgX,OACLhX,KAAKwW,iCACLxW,KAAKiW,oBACLjW,KAAKkX,mBACLlX,KAAKib,QACLjb,KAAK+a,YAAY5W,QAAQ,CAACnF,EAAG9B,KAC3B8B,EAAE8D,OAAO9C,KAAKE,EAAGF,KAAKM,IACN,IAAZtB,EAAEoF,OACJpE,KAAK+a,YAAY1W,OAAOnH,EAAG,KAK1B,OACL,MAAMqL,EAAQvI,KAAKkb,iBACnBlb,KAAKmb,WAAW5S,GAChBvI,KAAKob,oBAAoB7S,GAsBzB,UAAUhE,OACVvE,KAAKqb,kBAGA,QACL,GAAIrb,KAAK6a,UAAY7a,KAAK8a,kBAAoB,EAAG,CAC/C,MAAMvL,EAAM,UAAOtP,cAAcC,EAAI,UAAOe,OAAOf,EAC7CsP,EAAM,UAAOvP,cAAcK,EAAI,UAAOW,OAAOX,EACnD,IAAIgb,EAAO/L,GAAOpP,KAAK4K,IAAIwE,GAAMpP,KAAK4K,IAAIyE,IACtC+L,EAAO/L,GAAOrP,KAAK4K,IAAIwE,GAAMpP,KAAK4K,IAAIyE,IAI1C,MAAMgM,EAAgC,GAAhBrb,KAAKsb,SAAiB,IACtCC,EAAgC,GAAhBvb,KAAKsb,SAAiB,IAC5CH,GAAQE,EACRD,GAAQG,EAER1b,KAAK+a,YAAY5V,KAAK,IAAI,UAAWnF,KAAKE,EAAGF,KAAKM,EAAGgb,EAAMC,IAC3Dvb,KAAK8a,iBAAmB,EAExB,UAAQa,gBAEN3b,KAAK8a,iBAIJ,YAAYc,GACjB5b,KAAK6a,SAAWe,EAGV,OACF5b,KAAK6N,OAAOC,OAAS9N,KAAKkO,QAAQJ,OAChC9N,KAAK6N,OAAOG,IAAMhO,KAAK6N,OAAOI,KAChCjO,KAAKE,GAAKF,KAAKqO,iBAEfrO,KAAKE,GAAKF,KAAKsO,UAGftO,KAAK6N,OAAOE,QAAU/N,KAAKkO,QAAQH,QACjC/N,KAAK6N,OAAOG,IAAMhO,KAAK6N,OAAOI,KAChCjO,KAAKE,GAAKF,KAAKqO,iBAEfrO,KAAKE,GAAKF,KAAKsO,UAGftO,KAAK6N,OAAOG,KAAOhO,KAAKkO,QAAQF,KAC9BhO,KAAK6N,OAAOC,MAAQ9N,KAAK6N,OAAOE,MAClC/N,KAAKM,GAAKN,KAAKqO,iBAEfrO,KAAKM,GAAKN,KAAKsO,UAGftO,KAAK6N,OAAOI,OAASjO,KAAKkO,QAAQD,OAChCjO,KAAK6N,OAAOC,MAAQ9N,KAAK6N,OAAOE,MAClC/N,KAAKM,GAAKN,KAAKqO,iBAEfrO,KAAKM,GAAKN,KAAKsO,UAKb,iBACN,MAAM/F,EAAQ,EAAAkB,mBAAmB,UAAOxJ,cAAe,UAAOgB,QAG9D,OAFA,EAAArB,QAAQ8T,UAAY,UACpB,EAAA9T,QAAQiN,gBAAgBtE,EAAMyB,QAAQ,KAAM,GAAI,IACzCzB,EAGD,WAAWA,GAEjB,EAAA3I,QAAQwJ,YACN,EAAAxJ,QAAQ8T,UAAY,UACpB,EAAA9T,QAAQ+T,KAAO,iBAEf,EAAA/T,QAAQiN,eAAe7M,KAAKE,MAAMF,KAAKM,KAAM,GAAI,IAEjD,EAAAV,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQuJ,UAAY,EACpB,EAAAvJ,QAAQyJ,OAAO,UAAOpI,OAAOf,EAAG,UAAOe,OAAOX,GAC9C,EAAAV,QAAQ0J,OAAO,UAAOrI,OAAOf,EAAKF,KAAK4a,gBAAkBza,KAAK0b,IAAItT,GAAS,UAAOtH,OAAOX,EAAKN,KAAK4a,gBAAkBza,KAAK0Z,IAAItR,IAChI,EAAA3I,QAAQ2J,SAERvJ,KAAKoX,mBAGC,mBACN,EAAAxX,QAAQuJ,UAAY,EACpB,EAAAvJ,QAAQwJ,YAGN,EAAAxJ,QAAQyJ,QAAQ,GAAM,UAAOpI,OAAOf,EAAIF,KAAKuH,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,EAAIN,KAAKuH,aAAa9G,YAChH,EAAAb,QAAQ0J,OAAQ,GAAM,UAAOrI,OAAOf,EAAIF,KAAKuH,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,EAAIN,KAAKuH,aAAa9G,YAChH,EAAAb,QAAQ0J,OAAQ,GAAM,UAAOrI,OAAOf,EAAIF,KAAKuH,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,EAAIN,KAAKuH,aAAa9G,YAChH,EAAAb,QAAQ0J,QAAQ,GAAM,UAAOrI,OAAOf,EAAIF,KAAKuH,aAAa/G,UAAY,GAAM,UAAOS,OAAOX,EAAIN,KAAKuH,aAAa9G,YAChH,EAAAb,QAAQ0J,QAAQ,GAAM,UAAOrI,OAAOf,EAAIF,KAAKuH,aAAa/G,WAAY,GAAM,UAAOS,OAAOX,EAAIN,KAAKuH,aAAa9G,YAClH,EAAAb,QAAQ2J,SAGF,oBAAoBhB,GAC1B,MAAM,SAAES,EAAQ,UAAEY,GAAc,UAAUD,KAAK3J,KAAMuI,GACjDS,IACEY,EACF,UAAUkS,QAAQ9S,EAAU,WAE5B,UAAU8S,QAAQ9S,IAKhB,kBACNhJ,KAAK+a,YAAY5W,QAAQnF,GAAKA,EAAEuF,KAAKvE,KAAKE,EAAGF,KAAKM,IAI5C,oBACNN,KAAK4E,IAAMzE,KAAKC,MAAMJ,KAAKM,EAAIhB,EAAOqB,WACtCX,KAAK8E,IAAM3E,KAAKC,MAAMJ,KAAKE,EAAIZ,EAAOqB,WAGhC,mBACNX,KAAKwE,OAAOE,MAAQ1E,KAAKM,EAAIhB,EAAOqB,UACpCX,KAAKwE,OAAOyC,SAAW3H,EAAOqB,UAAYX,KAAKwE,OAAOE,MACtD1E,KAAKwE,OAAOC,OAASzE,KAAKE,EAAIZ,EAAOqB,UACrCX,KAAKwE,OAAO0C,QAAU5H,EAAOqB,UAAYX,KAAKwE,OAAOC,OAG/C,+BACN,MAAMsX,EAAkB,CAAE7b,EAAGF,KAAKmO,MAAO7N,EAAGN,KAAKoO,MAAO7G,aAAcvH,KAAKuH,cACrEyU,EAAkB,EAAAzY,mBAAmBvD,KAAKE,EAAGF,KAAKM,GAEpD0b,EAAgBC,KAAKrY,GAAK,EAAA4K,wBAAwB5K,EAAGmY,KACvDC,EAAgB7X,QAAQP,IACtB5D,KAAKga,yBAAyBpW,EAAGmY,KAK/B,MACN/b,KAAKoE,OAAQ,K,8EC3NjB,aAEA,gBACS,cACL,MAAM8X,EAAkB,UAAOjc,cAAcC,EACvCic,EAAkB,UAAOlc,cAAcK,EAC7C,IAAI8b,EACAC,EACJ,EAAAzc,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQuJ,UAAY,GACpB,EAAAvJ,QAAQwJ,YAENgT,EAAW,GACXC,GAAW,IACX,EAAAzc,QAAQyJ,OAAO6S,EAAUE,EAASD,EAAUE,GAC5CA,GAAW,IACX,EAAAzc,QAAQ0J,OAAO4S,EAAUE,EAASD,EAAUE,GAG5CA,EAAU,IACV,EAAAzc,QAAQyJ,OAAO6S,EAAUE,EAASD,EAAUE,GAC5CA,EAAU,IACV,EAAAzc,QAAQ0J,OAAO4S,EAAUE,EAASD,EAAUE,GAG5CA,EAAW,GACXD,GAAW,IACX,EAAAxc,QAAQyJ,OAAO6S,EAAUE,EAASD,EAAUE,GAC5CD,GAAW,IACX,EAAAxc,QAAQ0J,OAAO4S,EAAUE,EAASD,EAAUE,GAG5CD,EAAU,IACV,EAAAxc,QAAQyJ,OAAO6S,EAAUE,EAASD,EAAUE,GAC5CD,EAAU,IACV,EAAAxc,QAAQ0J,OAAO4S,EAAUE,EAASD,EAAUE,GAC9C,EAAAzc,QAAQ2J,Y,8ECpCZ,aAEA,OAGA,OASA,gBAeE,YACSrJ,EACAI,EACAgc,EACAC,GAHA,KAAArc,IACA,KAAAI,IACA,KAAAgc,aACA,KAAAC,aAlBF,KAAAC,MAAgB,GAChB,KAAAC,OAAiB,GACjB,KAAArY,OAAiB,EAShB,KAAAsY,8BAAwC,EACxC,KAAAC,sBAA6C,GAQnD,IAAK,IAAIzf,EAAI,EAAGA,EAAI8C,KAAK0c,gCAAiCxf,EACxD8C,KAAK2c,sBAAsBzf,GAAK,CAAEgD,EAAG,KAAMI,EAAG,KAAMsE,IAAK,KAAME,IAAK,MAIjE,OAAOtB,EAAiBC,GAC7BzD,KAAK4c,UAAY5c,KAAKE,EACtBF,KAAK6c,UAAY7c,KAAKM,EACtBN,KAAKE,GAAKF,KAAKsc,WAAatc,KAAKwc,MACjCxc,KAAKM,GAAKN,KAAKuc,WAAavc,KAAKwc,MACjCxc,KAAK4E,IAAMzE,KAAKC,MAAMJ,KAAKM,EAAIhB,EAAOqB,WACtCX,KAAK8E,IAAM3E,KAAKC,MAAMJ,KAAKE,EAAIZ,EAAOqB,WAEtC,MAAMmc,EAAgB9c,KAAK+c,mBAE3B/c,KAAKgd,8BAEDhd,KAAKid,YAAYzZ,EAASC,KAC5BzD,KAAKoE,OAAQ,GAGfpE,KAAK2c,sBAAsBxY,QAAQ+Y,IAC7Bld,KAAKoE,QACPpE,KAAKmd,0BAA0BL,EAAeI,GAC9Cld,KAAKod,6BAA6BF,MAGlCld,KAAKoE,QACPpE,KAAKmd,0BAA0BL,GAC/B9c,KAAKod,gCAIF,KAAK5Z,EAAiBC,GACvBzD,KAAKE,IAAMsD,GAAWxD,KAAKM,IAAMmD,IAIrC,EAAA7D,QAAQsJ,YAAc,UACtB,EAAAtJ,QAAQuJ,UAAY,EACpB,EAAAvJ,QAAQwJ,YACR,EAAAxJ,QAAQ6L,IACNzL,KAAKE,EAAI,UAAOe,OAAOf,EAAIsD,EAC3BxD,KAAKM,EAAI,UAAOW,OAAOX,EAAImD,EAC3B,EACA,EACC,EAAItD,KAAKqK,IAEZ,EAAA5K,QAAQ2J,UAKF,mBACN,MAAO,IAAK,EAAA7F,SAAUC,OAAOC,GAC3BzD,KAAK4K,IAAInH,EAAE1D,EAAIF,KAAKE,IAAMZ,EAAOqB,WACjCR,KAAK4K,IAAInH,EAAEtD,EAAIN,KAAKM,IAAMhB,EAAOqB,WAY7B,8BACN,MAAM0c,GAAyBrd,KAAKE,EAAIF,KAAK4c,YAAc5c,KAAK0c,8BAAgC,GAC1FY,GAAyBtd,KAAKM,EAAIN,KAAK6c,YAAc7c,KAAK0c,8BAAgC,GAChG,IAAK,IAAIxf,EAAI8C,KAAK0c,8BAAgC,EAAGxf,GAAK,IAAKA,EAC7D8C,KAAK2c,sBAAsBzf,GAAGgD,EAAIF,KAAKE,EAAImd,GAAyBngB,EAAI,GACxE8C,KAAK2c,sBAAsBzf,GAAGoD,EAAIN,KAAKM,EAAIgd,GAAyBpgB,EAAI,GACxE8C,KAAK2c,sBAAsBzf,GAAG0H,IAAMzE,KAAKC,MAAMJ,KAAK2c,sBAAsBzf,GAAGoD,EAAIhB,EAAOqB,WACxFX,KAAK2c,sBAAsBzf,GAAG4H,IAAM3E,KAAKC,MAAMJ,KAAK2c,sBAAsBzf,GAAGgD,EAAIZ,EAAOqB,WAIpF,YAAY6C,EAAiBC,GACnC,OACEzD,KAAKE,EAAIsD,EAAU,UAAOvC,OAAOf,EAAIZ,EAAOqB,WAAaX,KAAKE,EAAIsD,EAAU,UAAOvC,OAAOf,EAAIZ,EAAOqB,WACrGX,KAAKM,EAAImD,EAAU,UAAOxC,OAAOX,EAAIhB,EAAOqB,WAAaX,KAAKM,EAAImD,EAAU,UAAOxC,OAAOX,EAAIhB,EAAOqB,UAIjG,0BAA0Bmc,EAAwBS,GACnDA,IACHA,EAAQvd,MAGV8c,EAAc3Y,QAAQP,IAElB2Z,EAAMrd,GAAK0D,EAAE1D,EAAI0D,EAAE2D,aAAa/G,WAChC+c,EAAMrd,GAAK0D,EAAE1D,EAAI0D,EAAE2D,aAAa/G,WAChC+c,EAAMjd,GAAKsD,EAAEtD,EAAIsD,EAAE2D,aAAa9G,YAChC8c,EAAMjd,GAAKsD,EAAEtD,EAAIsD,EAAE2D,aAAa9G,aAEhCT,KAAKoE,OAAQ,EACbR,EAAE4Z,WAAWxd,KAAKyd,gBAKhB,6BAA6BF,GAC9BA,IACHA,EAAQvd,MAGV,MAAMrC,EAAI,EAAAmG,YAAYyZ,EAAM3Y,KAAK2Y,EAAMzY,KACnCnH,IACAA,EAAE6f,WAAWxd,KAAKyd,aAClBzd,KAAKoE,OAAQ,EACTzG,EAAE+c,eACJ,EAAA5W,YAAYyZ,EAAM3Y,KAAK2Y,EAAMzY,KAAO,OAKpC,YACN,OAAO9E,KAAKyc,U,8EC3JhB,aAGA,OACA,OAEA,gBACS,SAGA,QAIA,UAIA,SACL,UAAYra,QAAQW,SACpB/C,KAAK0d,gBAGC,gBACN,EAAA9d,QAAQwJ,YACN,EAAAxJ,QAAQ8T,UAAY,UACpB,EAAA9T,QAAQ+T,KAAO,iBAEf,EAAA/T,QAAQiN,SAAS,SAAUvN,EAAOC,aAAe,EAAI,GAAID,EAAOG,cAAgB,EAAI,IACpF,EAAAG,QAAQ+T,KAAO,iBACf,EAAA/T,QAAQiN,SAAS,eAAmBvN,EAAOC,aAAe,EAAI,GAAID,EAAOG,cAAgB,EAAI,IAC7F,EAAAG,QAAQiN,SAAS,kBAAmBvN,EAAOC,aAAe,EAAI,GAAID,EAAOG,cAAgB,EAAI,IAC/F,EAAAG,QAAQ2J,Y,8EC/BZ,aAEA,8BACU,KAAAoU,aAA2B,UAAYra,QAExC,WACL,OAAOtD,KAAK2d,aAEP,SAASvJ,GACdpU,KAAK2d,aAAaC,KAAKxJ,GACvB,MAAMF,EAAgBlU,KAAK2d,aAG3B,OAFAvJ,EAAUyJ,MAAM3J,GAChBlU,KAAK2d,aAAevJ,EACbpU,KAAK2d,aAGP,SACL3d,KAAK2d,aAAa7a,SAEb,SACL9C,KAAK2d,aAAa5a,Y,6BCpBtB,IAAK+a,E,iDAAL,SAAKA,GACH,2BACA,qBAFF,CAAKA,MAAU,KAKf,UAAeA","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import AudioLoader from '@app/audio/AudioLoader'\nimport GraphicsLoader from '@app/graphics/GraphicsLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport FrameRate from '../FrameRate'\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0\n  public static loadedPercentages: Map<GameAssets, { loaded: number, weight: number }> = new Map()\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  public static togglePause(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PAUSED) {\n      Game.stateManager.setState(GAME_STATES.PLAYING)\n    } else {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n  }\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n\n    Game.loadedPercentages.set(GameAssets.Graphics, { weight: 0.3, loaded: 0.0 })\n    Game.loadedPercentages.set(GameAssets.Audio,    { weight: 0.7, loaded: 0.0 })\n\n    AudioLoader.load(   percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n    GraphicsLoader.load(percentage => this.gameAssetLoaded(GameAssets.Graphics, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop()\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const assetValue = Game.loadedPercentages.get(asset)\n    assetValue.loaded = percentage\n    Game.loadedPercentages.set(asset, assetValue)\n\n    Game.loadedPercentage = 0\n    for (const [_key, value] of Game.loadedPercentages) {\n      Game.loadedPercentage += value.loaded * value.weight\n    }\n\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(): void {\n    this.update()\n    this.render()\n\n    FrameRate.calculateFrameRate()\n\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    FrameRate.drawFPS() // TODO: Remove this, used just for debugging\n  }\n}\n","import GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStatePaused from './GameStatePaused'\n\n// TODO: Add a IGameState type definition\nconst GAME_STATES = {\n  LOADING   : new GameStateLoading(),\n  MAIN_MENU : new GameStateMainMenu(),\n  PLAYING   : new GameStatePlaying(),\n  PAUSED    : new GameStatePaused(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport ConcreteEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport IMap from './IMap'\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\nexport const enemies: Enemy[] = []\n\nexport function getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n  return enemies.filter(e => e.isOnScreen(playerX, playerY))\n}\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public update(): void {\n    enemies.forEach((e, i) => {\n      e.update(this.player, enemies)\n      if (e.alive === false) {\n        enemies.splice(i, 1) // Remove the enemy\n      }\n    })\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map.gameObjects[row][col])\n      }\n    }\n\n    map.enemies.forEach((e, i) => {\n      enemies.push(new ConcreteEnemy(e.x, e.y, e.healthPercentage, i))\n    })\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/enemy_hit_1.mp3'),\n      load('./audio/enemy_hit_2.mp3'),\n      load('./audio/enemy_hit_3.mp3'),\n      load('./audio/enemy_hit_4.mp3'),\n      load('./audio/enemy_hit_5.mp3'),\n\n      load('./audio/enemy_die_1.mp3'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.SMG[0] = soundFxFiles[0]\n    this.SMG[1] = soundFxFiles[1]\n    this.SMG[2] = soundFxFiles[2]\n    this.SMG[3] = soundFxFiles[3]\n    this.SMG[4] = soundFxFiles[4]\n\n    this.CRATE_HIT[0] = soundFxFiles[5]\n\n    this.ENEMY_HIT[0] = soundFxFiles[6]\n    this.ENEMY_HIT[1] = soundFxFiles[7]\n    this.ENEMY_HIT[2] = soundFxFiles[8]\n    this.ENEMY_HIT[3] = soundFxFiles[9]\n    this.ENEMY_HIT[4] = soundFxFiles[10]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[11]\n    setLoadedPercentage(1.0)\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playCrateHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}\n\nexport function updatePointRowAndColValues(p: Point): void {\n  p.row = Math.floor(p.y / CONFIG.TILE_SIZE)\n  p.col = Math.floor(p.x / CONFIG.TILE_SIZE)\n}\n\nexport function updatePointDeltas(p: Point): void {\n  p.deltas.dyTop = p.y % CONFIG.TILE_SIZE\n  p.deltas.dyBottom = CONFIG.TILE_SIZE - p.deltas.dyTop\n  p.deltas.dxLeft = p.x % CONFIG.TILE_SIZE\n  p.deltas.dxRight = CONFIG.TILE_SIZE - p.deltas.dxLeft\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    // TODO: Just a development warning, remove this in production\n    if (CONFIG.THROW_DEVELOPMENT_ERRORS) {\n      if (width % 2 !== 0 || height % 2 !== 0) {\n        throw new Error('Always use even numbers for collision box dimensions!')\n      }\n    }\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n\nexport interface ICollidable {\n  x: number\n  y: number\n  collisionBox: CollisionBox\n}\n\nexport function collisionBoxesIntersect(a: ICollidable, b: ICollidable): boolean {\n  return (\n    a.x - a.collisionBox.halfWidth  < b.x + b.collisionBox.halfWidth  &&\n    a.x + a.collisionBox.halfWidth  > b.x - b.collisionBox.halfWidth  &&\n    a.y - a.collisionBox.halfHeight < b.y + b.collisionBox.halfHeight &&\n    a.y + a.collisionBox.halfHeight > b.y - b.collisionBox.halfHeight\n  )\n}","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import CreatureSprite from './sprites/CreatureSprite'\nimport SpriteZerg from './sprites/SpriteZerg'\n\nexport default class Sprites {\n  public static Zerg: CreatureSprite = new SpriteZerg()\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    await Sprites.Zerg.load(() => setLoadedPercentage(1.0))\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { angleBetweenPoints, updatePointRowAndColValues, updatePointDeltas } from '@app/infrastructure/geometry/Point'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport RaycastablePoint from './geometry/RaycastablePoint'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { PathNode } from './Pathfinding'\nimport Player from '@app/domain/player/Player'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(\n    p: RaycastablePoint,\n    theta: number,\n    pEnd?: RaycastablePoint\n  ): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta, pEnd)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta, pEnd)\n      }\n    } else { // North\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta, pEnd)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta, pEnd)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  public static determineIfThereAreObstaclesBetweenTwoPoints(p1: RaycastablePoint, p2: RaycastablePoint): boolean {\n    const angleBetweenTwoGivenPoints = angleBetweenPoints(p2, p1)\n    const results = Raycaster.cast(p1, angleBetweenTwoGivenPoints, p2)\n\n    // I have to check if results exist because sometimes .cast() can return 'undefined'..\n    // Why .cast() sometimes returns 'undefined' could be worth investigating in the future..\n    if (results) {\n      return results.hitObject !== null\n    }\n    else {\n      return true\n    }\n  }\n\n  // This function is very computationaly expensive, see if it can be optimized\n  public static determineIfThereAreObstaclesBetweenTwoPathNodes(n1: PathNode | Enemy, n2: PathNode | Player) {\n    const angleBetweenNodes: number = +angleBetweenPoints(n2, n1).toFixed(2)\n\n    if (angleBetweenNodes === 0) { // 0deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > 0 && angleBetweenNodes < Math.PI / 2) { // between 0deg and 90deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === (Math.PI / 2)) { // 90deg\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > Math.PI / 2 && angleBetweenNodes < Math.PI) { // between 90deg and 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (Math.abs(angleBetweenNodes) === 3.14) { // 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI && angleBetweenNodes < -Math.PI / 2) { // between 180deg and 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === -1.57) { // 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI / 2 && angleBetweenNodes < 0) { // between 270deg and 360deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n  }\n\n  private static outsideOfScreenOffset = CONFIG.TILE_SIZE * 2\n  private static rangeHorizontal: number = Canvas.halfWidth  + Raycaster.outsideOfScreenOffset\n  private static rangeVertical: number   = Canvas.halfHeight + Raycaster.outsideOfScreenOffset * 2\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyBottom > (pEnd.y - p.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y - tileStepY - p.deltas.dyTop,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (p.x - pEnd.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - xIntercept,\n            y: Canvas.center.y - p.deltas.dyTop - tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (-xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if ((tileStepY + p.deltas.dyBottom > (pEnd.y - p.y)) || (-xIntercept > (p.x - pEnd.x))) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const xTile_leftByOnePixel = p.col + Math.floor((p.deltas.dxLeft + xIntercept - 1) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile][xTile_leftByOnePixel]) {\n        gameObjectHit = gameObjects[yTile][xTile_leftByOnePixel]\n      }\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n\nconst blankVertex: Point = {\n  x: 0,\n  y: 0,\n  deltas: {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  },\n}\nconst vertexNW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\n\nfunction getVerticesNW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexNW1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNW1.row = Math.floor(vertexNW1.y / CONFIG.TILE_SIZE)\n  vertexNW1.col = Math.floor(vertexNW1.x / CONFIG.TILE_SIZE)\n  vertexNW1.deltas.dyTop = vertexNW1.y % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW1.deltas.dyTop\n  vertexNW1.deltas.dxLeft = vertexNW1.x % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW1.deltas.dxLeft\n\n  vertexNW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexNW2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNW2.row = Math.floor(vertexNW2.y / CONFIG.TILE_SIZE)\n  vertexNW2.col = Math.floor(vertexNW2.x / CONFIG.TILE_SIZE)\n  vertexNW2.deltas.dyTop = vertexNW2.y % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW2.deltas.dyTop\n  vertexNW2.deltas.dxLeft = vertexNW2.x % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW2.deltas.dxLeft\n\n  return [ vertexNW1, vertexNW2 ]\n}\n\nfunction getVerticesNE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexNE1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNE1.row = Math.floor(vertexNE1.y / CONFIG.TILE_SIZE)\n  vertexNE1.col = Math.floor(vertexNE1.x / CONFIG.TILE_SIZE)\n  vertexNE1.deltas.dyTop = vertexNE1.y % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE1.deltas.dyTop\n  vertexNE1.deltas.dxLeft = vertexNE1.x % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE1.deltas.dxLeft\n\n  vertexNE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexNE2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNE2.row = Math.floor(vertexNE2.y / CONFIG.TILE_SIZE)\n  vertexNE2.col = Math.floor(vertexNE2.x / CONFIG.TILE_SIZE)\n  vertexNE2.deltas.dyTop = vertexNE2.y % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE2.deltas.dyTop\n  vertexNE2.deltas.dxLeft = vertexNE2.x % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE2.deltas.dxLeft\n\n  return [ vertexNE1, vertexNE2 ]\n}\n\nfunction getVerticesSW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexSW1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSW1.row = Math.floor(vertexSW1.y / CONFIG.TILE_SIZE)\n  vertexSW1.col = Math.floor(vertexSW1.x / CONFIG.TILE_SIZE)\n  vertexSW1.deltas.dyTop = vertexSW1.y % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW1.deltas.dyTop\n  vertexSW1.deltas.dxLeft = vertexSW1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW1.deltas.dxLeft\n\n  vertexSW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexSW2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSW2.row = Math.floor(vertexSW2.y / CONFIG.TILE_SIZE)\n  vertexSW2.col = Math.floor(vertexSW2.x / CONFIG.TILE_SIZE)\n  vertexSW2.deltas.dyTop = vertexSW2.y % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW2.deltas.dyTop\n  vertexSW2.deltas.dxLeft = vertexSW2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW2.deltas.dxLeft\n\n  return [ vertexSW1, vertexSW2 ]\n}\n\nfunction getVerticesSE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexSE1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSE1.row = Math.floor(vertexSE1.y / CONFIG.TILE_SIZE)\n  vertexSE1.col = Math.floor(vertexSE1.x / CONFIG.TILE_SIZE)\n  vertexSE1.deltas.dyTop = vertexSE1.y % CONFIG.TILE_SIZE\n  vertexSE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE1.deltas.dyTop\n  vertexSE1.deltas.dxLeft = vertexSE1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE1.deltas.dxLeft\n\n  vertexSE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexSE2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSE2.row = Math.floor(vertexSE2.y / CONFIG.TILE_SIZE)\n  vertexSE2.col = Math.floor(vertexSE2.x / CONFIG.TILE_SIZE)\n  vertexSE2.deltas.dyTop = vertexSE2.y % CONFIG.TILE_SIZE\n  vertexSE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE2.deltas.dyTop\n  vertexSE2.deltas.dxLeft = vertexSE2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE2.deltas.dxLeft\n\n  return [ vertexSE1, vertexSE2 ]\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox, { collisionBoxesIntersect, ICollidable } from '@app/infrastructure/CollisionBox'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport { Directions } from '@app/infrastructure/Directions'\n\nexport default abstract class Creature {\n  public prevX: number[] = [] // TODO: Make private?\n  public prevY: number[] = [] // TODO: Make private?\n  public x: number\n  public y: number\n  public nextX: number\n  public nextY: number\n  public row: number\n  public col: number\n\n  public maxSpeed: number\n  public maxSpeedDiagonal: number\n\n  public animationInterval: number = 0\n\n  public direction: Directions\n  public isMoving: boolean = false\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public blocked = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  protected resetMoving(): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n  }\n\n  protected resetBlocked(): void {\n    this.blocked.up    = false\n    this.blocked.down  = false\n    this.blocked.left  = false\n    this.blocked.right = false\n  }\n\n  protected calculateNextCoordinates(): void {\n    this.nextX = this.x\n    this.nextY = this.y\n\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX -= this.maxSpeedDiagonal\n      } else {\n        this.nextX -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX += this.maxSpeedDiagonal\n      } else {\n        this.nextX += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY -= this.maxSpeedDiagonal\n      } else {\n        this.nextY -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY += this.maxSpeedDiagonal\n      } else {\n        this.nextY += this.maxSpeed\n      }\n    }\n  }\n\n  protected checkIfBlockedByCreature(c: Creature, nextCreatureState: ICollidable) {\n    if (collisionBoxesIntersect(nextCreatureState, c)) {\n      let intersectionX: number\n      let intersectionY: number\n      if (nextCreatureState.x < c.x) {\n        intersectionX = (nextCreatureState.x + nextCreatureState.collisionBox.halfWidth) - (c.x - c.collisionBox.halfWidth)\n      } else if (nextCreatureState.x > c.x) {\n        intersectionX = (c.x + c.collisionBox.halfWidth) - (nextCreatureState.x - nextCreatureState.collisionBox.halfWidth)\n      }\n      if (nextCreatureState.y < c.y) {\n        intersectionY = (nextCreatureState.y + nextCreatureState.collisionBox.halfHeight) - (c.y - c.collisionBox.halfHeight)\n      } else if (nextCreatureState.y > c.y) {\n        intersectionY = (c.y + c.collisionBox.halfHeight) - (nextCreatureState.y - nextCreatureState.collisionBox.halfHeight)\n      }\n      if (!intersectionX || intersectionX >= intersectionY) {\n        if (nextCreatureState.y < c.y) {\n          this.blocked.down = true\n        } else {\n          this.blocked.up = true\n        }\n      } else if (!intersectionY || intersectionX < intersectionY) {\n        if (nextCreatureState.x < c.x) {\n          this.blocked.right = true\n        } else {\n          this.blocked.left = true\n        }\n      }\n    }\n  }\n\n  protected adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow && SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow && NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol && NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol && NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol && SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol && SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  protected updatePreviousCoordinates(): void {\n    this.prevX.push(this.x)\n    if (this.prevX.length > 5) { this.prevX.shift() }\n\n    this.prevY.push(this.y)\n    if (this.prevY.length > 5) { this.prevY.shift() }\n  }\n\n  protected updateDirection(): void {\n    const direction: string[] = []\n\n    const dx = this.prevX[this.prevX.length - 1] - this.prevX[this.prevX.length - 2]\n    const dy = this.prevY[this.prevY.length - 1] - this.prevY[this.prevY.length - 2]\n\n    if (dy > 0) {\n      direction.push(Directions.S)\n    }\n    else if (dy < 0) {\n      direction.push(Directions.N)\n    }\n\n    if (dx > 0) {\n      direction.push(Directions.E)\n    }\n    else if (dx < 0) {\n      direction.push(Directions.W)\n    }\n\n    const directionString = direction.join('') || this.direction || 'S'\n\n    this.direction = Directions[directionString as keyof typeof Directions]\n  }\n\n  protected checkIfMoving(): boolean {\n    const xUnchanged = this.prevX[this.prevX.length - 1] === this.prevX[this.prevX.length - 2]\n    const yUnchanged = this.prevY[this.prevY.length - 1] === this.prevY[this.prevY.length - 2]\n    if (xUnchanged && yUnchanged) {\n      return false\n    } else {\n      return true\n    }\n  }\n}\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","import Sprites from './Sprites'\n\nexport default class GraphicsLoader {\n  public static async load(setLoadedPercentage: (percentage: number) => void) {\n    Sprites.load(setLoadedPercentage)\n  }\n}","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nimport CreatureSprite from './CreatureSprite'\n\nexport default class SpriteZerg extends CreatureSprite {\n  public url: string = './graphics/spritesheets/zergling.png'\n\n  public animationPeriods = {\n    walking: 8,\n  }\n\n  public draw(enemy: Enemy, playerCoordinates: Point) {\n\n    const SPRITE_LOCATIONS: { [key: string]: { col: number, flip: boolean } } = {\n      N : { col: 0, flip: false },\n      NE: { col: 2, flip: false },\n      E : { col: 4, flip: false },\n      SE: { col: 6, flip: false },\n      S : { col: 8, flip: false },\n      SW: { col: 6, flip: true  },\n      W : { col: 4, flip: true  },\n      NW: { col: 2, flip: true  },\n    }\n\n    const spriteLocation = SPRITE_LOCATIONS[enemy.direction]\n\n    const SPRITE_SIZE = 32\n    const SPRITE_OFFSETS = {\n      INITIAL: { x: 7, y: 5 },\n      STEP: { x: SPRITE_SIZE + 11, y: SPRITE_SIZE + 10 }\n    }\n    const { x, y, collisionBox: cBox } = enemy\n    const { x: px, y: py } = playerCoordinates\n\n    if (enemy.isMoving === false) {\n      enemy.animationInterval = 0\n    }\n\n    if (spriteLocation.flip) {\n      context.save()\n      context.translate(\n        Canvas.center.x + (x - px - cBox.halfWidth),\n        Canvas.center.y + (y - py - cBox.halfHeight),\n      )\n      context.scale(-1, 1)\n    }\n\n    context.drawImage(\n      this.spriteSheet,\n      SPRITE_OFFSETS.INITIAL.x + SPRITE_OFFSETS.STEP.x * spriteLocation.col,\n      SPRITE_OFFSETS.INITIAL.y + SPRITE_OFFSETS.STEP.y * Math.floor(enemy.animationInterval / 2),\n      SPRITE_SIZE,\n      SPRITE_SIZE,\n      spriteLocation.flip ? 0 - SPRITE_SIZE / 2 : Canvas.center.x + (x - px - cBox.halfWidth),\n      spriteLocation.flip ? 0                   : Canvas.center.y + (y - py - cBox.halfHeight),\n      enemy.collisionBox.width + 2,\n      enemy.collisionBox.height + 2,\n    )\n    if (spriteLocation.flip) {\n      context.restore()\n    }\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default abstract class CreatureSprite {\n  public spriteSheet: HTMLImageElement\n\n  public abstract animationPeriods: { [animation: string]: number }\n\n  protected abstract url: string\n  public abstract draw(e: Enemy, playerCoordinates: Point): void\n\n  public load(callback: () => void): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      this.spriteSheet = new Image()\n      this.spriteSheet.src = this.url\n      this.spriteSheet.onload = () => {\n        callback()\n        resolve()\n      }\n    })\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nlet lastFrameTime: number\nlet frameElapsedTime: number\n\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\n\nexport default class FrameRate {\n\n  public static restart() {\n    lastFrameTime = null\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(): void {\n    if (!lastFrameTime) {\n      lastFrameTime = performance.now()\n      FPS = 0\n    } else {\n      const now = performance.now()\n      frameElapsedTime = (now - lastFrameTime)\n\n      FPS_ARR.unshift(1000 / frameElapsedTime)\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n\n      lastFrameTime = now\n    }\n  }\n\n  public static drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationCounter: number = 0\n  private animationInterval: number = 100\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationCounter = (this.animationCounter + 1) % this.animationInterval\n    if (this.animationCounter >= this.animationInterval / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press any key to start', CONFIG.CANVAS_WIDTH / 2 - 132, CONFIG.CANVAS_HEIGHT / 2 - 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection(): void {\n    Game.stateManager.setState(GAME_STATES.PLAYING)\n  }\n}\n","import IGameState from './IGameState'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePlaying implements IGameState {\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n  }\n\n  public exit(nextState: IGameState): void {\n    if (nextState !== GAME_STATES.PAUSED) {\n      window.onblur = null\n    }\n  }\n\n  public update(): void {\n    Canvas.updateMousePosition()\n    Gamepads.update(this.player)\n    this.player.update()\n    this.map.update()\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n  }\n\n  private startNewGame(): void {\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n}\n","import Game from '@app/infrastructure/game/Game'\nimport FrameRate from '@app/infrastructure/FrameRate'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    document.addEventListener('keydown', e => {\n      // TODO: Move Player logic to Player class\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.ESC:\n        case KEYBOARD_KEYS.p:\n          Game.togglePause()\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\n// TODO: This class is useless?\nexport default class Grid {\n  public rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  public cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n\nexport interface NeighbourTiles {\n    N  : (any | null)\n    NE : (any | null)\n    E  : (any | null)\n    SE : (any | null)\n    S  : (any | null)\n    SW : (any | null)\n    W  : (any | null)\n    NW : (any | null)\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, findShortestPath, drawPathNodes } from '@app/infrastructure/Pathfinding'\n\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport Sprites from '@app/graphics/Sprites'\n\nexport default class ConcreteEnemy extends Enemy {\n  protected sprite: CreatureSprite = Sprites.Zerg\n  constructor(\n    x: number,\n    y: number,\n    healthPercentage: number,\n    protected pathfindingInterval: number\n  ) {\n    super(x, y, new CollisionBox(14, 14), 1, healthPercentage)\n    this.updateMapPosition()\n  }\n\n  public update(player: Player, enemies: Enemy[]): void {\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n    this.updatePreviousCoordinates()\n\n    this.stuck    = this.checkIfStuck()\n    this.isMoving = this.checkIfMoving()\n\n    this.adjustCollisionWithGameObjects()\n    this.checkForCollisionWithPlayer(player)\n    this.checkForCollisionWithOtherEnemies(player)\n    this.distanceFromPlayer = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   }\n    )\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy =\n      Raycaster.determineIfThereAreObstaclesBetweenTwoPathNodes(this, player)\n    this.findPathToPlayer(player)\n\n    this.move()\n    this.updateDirection()\n    this.updateTileDeltas()\n\n    if (Game.stateManager.getState() !== GAME_STATES.PAUSED) {\n      this.advanceAnimation()\n    }\n  }\n\n  public draw(player: Player): void {\n    this.drawCollisionBox(player) // Just for debugging\n    // this.drawRayToPlayer(player) // TODO: Just for debugging\n    // drawPathNodes(this.pathfindingNodes, player, this.getHealthColor()) // TODO: Just for debugging\n\n    // TODO: Just for debugging\n    // this.shortestPath\n    //   .forEach((n, i) => {\n    //     drawNode(n, player, n.visited ? '#FF0000' : '#FF00FF')\n    //   })\n    // if (this.shortestPath.length > 0) {\n    //   this.drawRayToPoint(this.shortestPath[this.shortestPath.length - 1], player)\n    //   this.shortestPath.forEach(node => this.drawRayToPoint(node, player)) // Draw all lines\n    // }\n    this.sprite.draw(this, { x: player.x, y: player.y })\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.alive = false\n  }\n\n  protected advanceAnimation(): void {\n    this.animationInterval = (this.animationInterval + 0.5) % this.sprite.animationPeriods.walking\n  }\n\n  private findPathToPlayer(player: Player): void {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) { // TODO: || this.isStuck()\n      if (this.pathfindingInterval === 0) {\n        this.pathfindingNodes = generatePathNodes(\n          Math.round(Math.abs(player.row + this.row) / 2),\n          Math.round(Math.abs(player.col + this.col) / 2),\n          this.collisionBox,\n        )\n        this.shortestPath = findShortestPath(this, player, this.pathfindingNodes)\n      }\n\n      this.pathfindingInterval = (this.pathfindingInterval + 1) % this.pathfindingPeriod\n\n      if (this.shortestPath.length > 0) {\n        this.followTheShortestPath()\n      }\n    }\n    else {\n      if (this.pathfindingNodes) {\n        this.pathfindingNodes = null\n      }\n      if (this.shortestPath) {\n        this.shortestPath = []\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private followTheShortestPath(): void {\n    // If the enemy is close to the path node, pop that node and move to the next one\n    let nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n    let nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    if (\n      this.shortestPath.length > 1 &&\n      Math.abs(nextNodeX - this.x) < 3 &&\n      Math.abs(nextNodeY - this.y) < 3\n    ) {\n      this.shortestPath.pop()\n      nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n      nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    }\n    this.moveTowards(nextNodeX, nextNodeY)\n  }\n\n  private moveTowardsPlayer(player: Player): void {\n    if (this.distanceFromPlayer > this.collisionBox.width) {\n      this.moveTowards(player.x, player.y)\n    }\n    else {\n      this.resetMoving()\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.resetMoving()\n\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.2\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPoint(p: Point, player: Player) {\n    context.strokeStyle = '#FF00FF'\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x + (p.x - player.x), Canvas.center.y + (p.y - player.y))\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox, { collisionBoxesIntersect } from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport RaycastablePoint from './geometry/RaycastablePoint'\n\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): PathNode[] {\n  const path: PathNode[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!gameObjects[row] || !gameObjects[row][col]) {\n        if (col > 0 && row > 0) {\n          path.push(new PathNode({\n            x: col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n            y: row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n          }, cBox))\n        }\n      }\n    }\n  }\n\n  return path\n}\n\nexport function drawPathNodes(path: PathNode[], player: Player, color: string): void {\n  if (path) {\n    path.forEach(node => drawNode(node, player, color))\n  }\n}\n\nexport function drawNode(node: PathNode, player: Player, color: string): void {\n  context.strokeStyle = color\n  context.lineWidth = 0.1\n  context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // optimize/cache the vertex calculations.\n    context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n  context.stroke()\n\n  context.beginPath()\n    context.arc(\n      Canvas.center.x + (node.x - player.x),\n      Canvas.center.y + (node.y - player.y),\n      1,\n      0,\n      (2 * Math.PI)\n    )\n  context.stroke()\n}\n\nexport function findShortestPath(enemy: Enemy, player: Player, pathfindingNodes: PathNode[]): PathNode[] {\n  const nodeGoal  = new PathNode(player, player.collisionBox)\n  const nodeStart = new PathNode(enemy,  enemy.collisionBox)\n\n  pathfindingNodes.push(nodeGoal)\n\n  nodeStart.f = 0\n  nodeStart.g = nodeStart.heuristic(nodeGoal)\n\n  const nodesNotTested: PathNode[] = [ nodeStart ]\n\n  let nodeCurrent: PathNode\n\n  while (nodesNotTested.length > 0 || nodeCurrent === nodeGoal) {\n    nodesNotTested.sort((a: PathNode, b: PathNode) => a.g - b.g)\n\n    while (nodesNotTested.length > 0 && nodesNotTested[0].visited === true) {\n      nodesNotTested.shift()\n    }\n\n    if (nodesNotTested.length <= 0) {\n      break\n    }\n\n    nodeCurrent = nodesNotTested.shift()\n    nodeCurrent.visited = true\n\n    // Get neighbour nodes.\n    nodeCurrent.neighbourNodes = [ ...pathfindingNodes ]\n      .filter(node => {\n        return (\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row    ) || // Center\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row - 1) || // N\n          (node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row    ) || // E\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row + 1) || // S\n          (node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row    ) || // W\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row - 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col + 1] === null ||\n              !gameObjects[node.row + 1] || gameObjects[node.row + 1][node.col    ] === null\n            )\n          ) || // NW\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row - 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col - 1] === null ||\n              !gameObjects[node.row + 1] || gameObjects[node.row + 1][node.col    ] === null\n            )\n          ) || // NE\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row + 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col - 1] === null ||\n              !gameObjects[node.row - 1] || gameObjects[node.row - 1][node.col    ] === null\n            )\n          ) || // SE\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row + 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col + 1] === null ||\n              !gameObjects[node.row - 1] || gameObjects[node.row - 1][node.col    ] === null\n            )\n          ) // SW\n        )\n      })\n\n    nodeCurrent.neighbourNodes\n      .map(node => {\n        if (node.visited === false) {\n          nodesNotTested.push(node)\n        }\n\n        // Calculate local goal\n        const possiblyLowerLocalGoal = nodeCurrent.f + pointToPointDistance(nodeCurrent, node)\n\n        if (possiblyLowerLocalGoal < node.f) {\n          node.parent = nodeCurrent\n          node.f = possiblyLowerLocalGoal\n          node.g = node.f + node.heuristic(nodeGoal)\n        }\n\n        return node\n      })\n  }\n\n  const path = []\n  if (nodeGoal.parent) {\n    let n: PathNode = nodeGoal\n    while (n.parent) {\n      path.push(n)\n      n = n.parent\n    }\n  }\n  return path\n}\n\nexport class PathNode implements RaycastablePoint {\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  public visited: boolean = false\n  public g: number = Infinity // Global goal\n  public f: number = Infinity // Local goal\n  public parent: PathNode = null\n  public neighbourNodes: PathNode[]\n\n  constructor(coordinates: Point, cBox: CollisionBox) {\n    this.x = coordinates.x\n    this.y = coordinates.y\n    this.collisionBox = new CollisionBox(cBox.width, cBox.height)\n    this.updateTileDeltas()\n    this.updateMapPosition()\n  }\n\n  public heuristic(nodeGoal: PathNode): number {\n    return pointToPointDistance(this, nodeGoal)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Creature from '@app/domain/Creature'\nimport Player from '@app/domain/player/Player'\nimport { PathNode } from '@app/infrastructure/Pathfinding'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport { getEnemiesOnScreen } from '../map/Map'\n\nexport default abstract class Enemy extends Creature {\n  public alive: boolean = true\n  public maxHealth: number = 100\n  public health: number\n\n  protected stuck: boolean\n\n  protected distanceFromPlayer: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathfindingInterval: number = 0\n  protected pathfindingPeriod: number = 30\n  protected pathfindingNodes: PathNode[]\n  protected shortestPath: PathNode[] = []\n\n  protected sprite: CreatureSprite\n\n  constructor(\n    public x: number,\n    public y: number,\n    collisionBox: CollisionBox,\n    maxSpeed: number,\n    healthPercentage: number,\n  ) {\n    super()\n    this.initializeHealth(healthPercentage)\n\n    this.maxSpeed = maxSpeed\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed)\n\n    this.collisionBox = collisionBox\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player, enemies: Enemy[]): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    const offScreenOffset = CONFIG.TILE_SIZE * 2\n    return (\n      Math.abs(this.x - playerX) < (CONFIG.CANVAS_WIDTH  / 2) + offScreenOffset &&\n      Math.abs(this.y - playerY) < (CONFIG.CANVAS_HEIGHT / 2) + offScreenOffset\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n  protected abstract advanceAnimation(): void\n\n  protected checkForCollisionWithPlayer(player: Player): void {\n    const nextEnemyState = { x: this.nextX, y: this.nextY, collisionBox: this.collisionBox }\n    this.checkIfBlockedByCreature(player, nextEnemyState)\n  }\n\n  protected checkForCollisionWithOtherEnemies(player: Player): void {\n    const nextEnemyState = { x: this.nextX, y: this.nextY, collisionBox: this.collisionBox }\n    const enemiesInScreenRangeFromThis = getEnemiesOnScreen(this.x, this.y)\n\n    enemiesInScreenRangeFromThis.forEach(e => {\n      if (this !== e) {\n        this.checkIfBlockedByCreature(e, nextEnemyState)\n      }\n    })\n  }\n\n  protected checkIfStuck(): boolean {\n    const xIsStatic = this.prevX.every(x => x === this.prevX[0])\n    const yIsStatic = this.prevY.every(y => y === this.prevY[0])\n    if (xIsStatic && yIsStatic) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  // TODO: The color strings can be moved to a single hash map in order to optimize & localize the color searches\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.10) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.20) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.30) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.40) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.50) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.60) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.70) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.80) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.90) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n\n  private initializeHealth(healthPercentage: number): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n}\n","export enum Directions {\n  N  = 'N',\n  NE = 'NE',\n  E  = 'E',\n  SE = 'SE',\n  S  = 'S',\n  SW = 'SW',\n  W  = 'W',\n  NW = 'NW',\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playCrateHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox, { collisionBoxesIntersect } from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport Creature from '@app/domain/Creature'\nimport { getEnemiesOnScreen } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player extends Creature {\n  public alive: boolean = true\n  public rotation: number = 0\n  public sightLineLength = 10\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n  )\n  {\n    super()\n\n    this.maxSpeed = 2\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed)\n\n    this.collisionBox = new CollisionBox(12, 12)\n\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n\n    this.checkForCollisionWithEnemies()\n    this.move()\n    this.adjustCollisionWithGameObjects()\n    this.updateMapPosition()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    // this.drawPlayerVisionRay(theta - 0.45)\n    // this.drawPlayerVisionRay(theta - 0.4)\n    // this.drawPlayerVisionRay(theta - 0.35)\n    // this.drawPlayerVisionRay(theta - 0.3)\n    // this.drawPlayerVisionRay(theta - 0.25)\n    // this.drawPlayerVisionRay(theta - 0.2)\n    // this.drawPlayerVisionRay(theta - 0.15)\n    // this.drawPlayerVisionRay(theta - 0.1)\n    // this.drawPlayerVisionRay(theta - 0.05)\n    // this.drawPlayerVisionRay(theta + 0.05)\n    // this.drawPlayerVisionRay(theta + 0.1)\n    // this.drawPlayerVisionRay(theta + 0.15)\n    // this.drawPlayerVisionRay(theta + 0.2)\n    // this.drawPlayerVisionRay(theta + 0.25)\n    // this.drawPlayerVisionRay(theta + 0.3)\n    // this.drawPlayerVisionRay(theta + 0.35)\n    // this.drawPlayerVisionRay(theta + 0.4)\n    // this.drawPlayerVisionRay(theta + 0.45)\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = (Canvas.mousePosition.x - Canvas.center.x)\n      const dy = (Canvas.mousePosition.y - Canvas.center.y)\n      let xVel = dx / ( Math.abs(dx) + Math.abs(dy) )\n      let yVel = dy / ( Math.abs(dx) + Math.abs(dy) )\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  private move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n      context.fillStyle = '#00AA00'\n      context.font = '10px Monospace'\n\n      context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n      context.strokeStyle = '#523DA5'\n      context.lineWidth = 2\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(Canvas.center.x + (this.sightLineLength * Math.cos(theta)), Canvas.center.y + (this.sightLineLength * Math.sin(theta)))\n    context.stroke()\n\n    this.drawCollisionBox() // Just for debugging\n  }\n\n  private drawCollisionBox() {\n    context.lineWidth = 1\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // cache the vertex calculations.\n      context.moveTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach(p => p.draw(this.x, this.y))\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  private checkForCollisionWithEnemies(): void {\n    const nextPlayerState = { x: this.nextX, y: this.nextY, collisionBox: this.collisionBox }\n    const enemiesOnScreen = getEnemiesOnScreen(this.x, this.y)\n\n    if (enemiesOnScreen.some(e => collisionBoxesIntersect(e, nextPlayerState))) {\n      enemiesOnScreen.forEach(e => {\n        this.checkIfBlockedByCreature(e, nextPlayerState)\n      })\n    }\n  }\n\n  private die(): void {\n    this.alive = false\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { gameObjects, enemies } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        o.takeDamage(this.getDamage())\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","\nenum GameAssets {\n  Graphics,\n  Audio,\n}\n\nexport default GameAssets"],"sourceRoot":""}
{"version":3,"file":"app.js","mappings":"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","sources":["webpack://retro-2d-game-engine/./src/app/audio/AudioBufferLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioContext.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/Mixer.ts","webpack://retro-2d-game-engine/./src/app/audio/SoundFX.ts","webpack://retro-2d-game-engine/./src/app/domain/Creature.ts","webpack://retro-2d-game-engine/./src/app/domain/CreatureState.ts","webpack://retro-2d-game-engine/./src/app/domain/Level.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/Enemy.ts","webpack://retro-2d-game-engine/./src/app/domain/map/Map.ts","webpack://retro-2d-game-engine/./src/app/domain/map/MapKeys.ts","webpack://retro-2d-game-engine/./src/app/domain/map/Maps.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/GameObject.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/portal/Portal.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/portal/PortalObject.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/wall/Wall.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/wall/WallFactory.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Crosshair.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Player.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Projectile.ts","webpack://retro-2d-game-engine/./src/app/graphics/GraphicsLoader.ts","webpack://retro-2d-game-engine/./src/app/graphics/Sprites.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/CreatureSprite.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/SpriteZerg.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Canvas.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/CollisionBox.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Directions.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/FrameRate.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/GameAssets.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/GameTime.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Pathfinding.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Raycaster.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/Game.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateGameOver.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateLevelCleared.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateVictory.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStates.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/geometry/Point.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Gamepads.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Keyboard.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Mouse.ts","webpack://retro-2d-game-engine/./src/app/peripherals/constants/KeyCodes.ts","webpack://retro-2d-game-engine/webpack/bootstrap","webpack://retro-2d-game-engine/./src/main.ts"],"sourcesContent":["import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/enemy_hit_1.mp3'),\n      load('./audio/enemy_hit_2.mp3'),\n      load('./audio/enemy_hit_3.mp3'),\n      load('./audio/enemy_hit_4.mp3'),\n      load('./audio/enemy_hit_5.mp3'),\n\n      load('./audio/enemy_die_1.mp3'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.SMG[0] = soundFxFiles[0]\n    this.SMG[1] = soundFxFiles[1]\n    this.SMG[2] = soundFxFiles[2]\n    this.SMG[3] = soundFxFiles[3]\n    this.SMG[4] = soundFxFiles[4]\n\n    this.CRATE_HIT[0] = soundFxFiles[5]\n\n    this.ENEMY_HIT[0] = soundFxFiles[6]\n    this.ENEMY_HIT[1] = soundFxFiles[7]\n    this.ENEMY_HIT[2] = soundFxFiles[8]\n    this.ENEMY_HIT[3] = soundFxFiles[9]\n    this.ENEMY_HIT[4] = soundFxFiles[10]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[11]\n    setLoadedPercentage(1.0)\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playWallHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport GameTime from '@app/infrastructure/GameTime'\nimport CollisionBox, { collisionBoxesIntersect, ICollidable } from '@app/infrastructure/CollisionBox'\n\nimport CreatureState from '@app/domain/CreatureState'\nimport Map from '@app/domain/map/Map'\nimport { Directions } from '@app/infrastructure/Directions'\n\nexport default abstract class Creature {\n  public prevX: number[] = [] // TODO: Make private?\n  public prevY: number[] = [] // TODO: Make private?\n  public nextX: number\n  public nextY: number\n  public row: number\n  public col: number\n  public maxHealth = 100\n  public health: number\n\n  public maxSpeed: number         // Derived from this.speed\n  public maxSpeedDiagonal: number // Derived from this.speed\n\n  public state: CreatureState = CreatureState.Idling\n  public previousState: CreatureState = CreatureState.Idling // TODO: Use `previousState` for something? (Currently it's unused)\n\n  public animationSpritePosition: number = 0\n\n  public direction: Directions\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public blocked = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  \n  constructor(\n    public x: number,\n    public y: number,\n    public collisionBox: CollisionBox,\n    private speed: number,\n    healthPercentage: number,\n  ) {\n    this.maxSpeed = this.speed\n    this.maxSpeedDiagonal = Math.sin(45) * this.maxSpeed\n\n    this.initializeHealth(healthPercentage)\n    this.updateMapPosition()\n  }\n\n  protected resetMoving(): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n  }\n\n  protected resetBlocked(): void {\n    this.blocked.up    = false\n    this.blocked.down  = false\n    this.blocked.left  = false\n    this.blocked.right = false\n  }\n\n  protected calculateNextCoordinates(): void {\n    this.nextX = this.x\n    this.nextY = this.y\n\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX -= this.maxSpeedDiagonal\n      } else {\n        this.nextX -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX += this.maxSpeedDiagonal\n      } else {\n        this.nextX += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY -= this.maxSpeedDiagonal\n      } else {\n        this.nextY -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY += this.maxSpeedDiagonal\n      } else {\n        this.nextY += this.maxSpeed\n      }\n    }\n  }\n\n  protected move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= Math.round(GameTime.elapsedTimeFactor * this.maxSpeedDiagonal)\n      } else {\n        this.x -= Math.round(GameTime.elapsedTimeFactor * this.maxSpeed)\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += Math.round(GameTime.elapsedTimeFactor * this.maxSpeedDiagonal)\n      } else {\n        this.x += Math.round(GameTime.elapsedTimeFactor * this.maxSpeed)\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= Math.round(GameTime.elapsedTimeFactor * this.maxSpeedDiagonal)\n      } else {\n        this.y -= Math.round(GameTime.elapsedTimeFactor * this.maxSpeed)\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += Math.round(GameTime.elapsedTimeFactor * this.maxSpeedDiagonal)\n      } else {\n        this.y += Math.round(GameTime.elapsedTimeFactor * this.maxSpeed)\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  protected updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  protected updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  protected checkIfBlockedByCreature(c: Creature, nextCreatureState: ICollidable) {\n    if (collisionBoxesIntersect(nextCreatureState, c)) {\n      let intersectionX: number\n      let intersectionY: number\n      if (nextCreatureState.x < c.x) {\n        intersectionX = (nextCreatureState.x + nextCreatureState.collisionBox.halfWidth) - (c.x - c.collisionBox.halfWidth)\n      } else if (nextCreatureState.x > c.x) {\n        intersectionX = (c.x + c.collisionBox.halfWidth) - (nextCreatureState.x - nextCreatureState.collisionBox.halfWidth)\n      }\n      if (nextCreatureState.y < c.y) {\n        intersectionY = (nextCreatureState.y + nextCreatureState.collisionBox.halfHeight) - (c.y - c.collisionBox.halfHeight)\n      } else if (nextCreatureState.y > c.y) {\n        intersectionY = (c.y + c.collisionBox.halfHeight) - (nextCreatureState.y - nextCreatureState.collisionBox.halfHeight)\n      }\n      if (!intersectionX || intersectionX >= intersectionY) {\n        if (nextCreatureState.y < c.y) {\n          this.blocked.down = true\n        } else {\n          this.blocked.up = true\n        }\n      } else if (!intersectionY || intersectionX < intersectionY) {\n        if (nextCreatureState.x < c.x) {\n          this.blocked.right = true\n        } else {\n          this.blocked.left = true\n        }\n      }\n    }\n  }\n\n  protected adjustCollisionWithWalls(): void {\n    let wall\n    if (Map.walls[this.row]) {\n      if (this.moving.left) {\n        wall = Map.walls[this.row][this.col - 1] // West\n        if (wall && this.x - this.collisionBox.halfWidth <= wall.mapX + wall.width) {\n          this.x = wall.mapX + wall.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow && SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          wall = Map.walls[SWVertexRow][this.col - 1] // South West\n          if (wall && this.x - this.collisionBox.halfWidth <= wall.mapX + wall.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = wall.mapX + wall.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow && NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          wall = Map.walls[NWVertexRow][this.col - 1] // North West\n          if (wall && this.x - this.collisionBox.halfWidth <= wall.mapX + wall.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = wall.mapX + wall.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        wall = Map.walls[this.row][this.col + 1] // East\n        if (wall && this.x + this.collisionBox.halfWidth >= wall.mapX) {\n          this.x = wall.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          wall = Map.walls[SEVertexRow][this.col + 1] // South East\n          if (wall && this.x + this.collisionBox.halfWidth >= wall.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = wall.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          wall = Map.walls[NEVertexRow][this.col + 1] // North East\n          if (wall && this.x + this.collisionBox.halfWidth >= wall.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = wall.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (Map.walls[this.row - 1]) {\n      if (this.moving.up) {\n        wall = Map.walls[this.row - 1][this.col] // North\n        if (wall && this.y - this.collisionBox.halfHeight <= wall.mapY + wall.height) {\n          this.y = wall.mapY + wall.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol && NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          wall = Map.walls[this.row - 1][NEVertexCol] // North East\n          if (wall && this.y - this.collisionBox.halfHeight <= wall.mapY + wall.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = wall.mapY + wall.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol && NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          wall = Map.walls[this.row - 1][NWVertexCol] // North West\n          if (wall && this.y - this.collisionBox.halfHeight <= wall.mapY + wall.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = wall.mapY + wall.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (Map.walls[this.row + 1]) {\n      if (this.moving.down) {\n        wall = Map.walls[this.row + 1][this.col] // South\n        if (wall && this.y + this.collisionBox.halfHeight >= wall.mapY) {\n          this.y = wall.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol && SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        wall = Map.walls[this.row + 1][SEVertexCol] // South East\n        if (wall && this.y + this.collisionBox.halfHeight >= wall.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = wall.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol && SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        wall = Map.walls[this.row + 1][SWVertexCol] // South West\n        if (wall && this.y + this.collisionBox.halfHeight >= wall.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = wall.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  protected updatePreviousCoordinates(): void {\n    this.prevX.push(this.x)\n    if (this.prevX.length > 5) { this.prevX.shift() }\n\n    this.prevY.push(this.y)\n    if (this.prevY.length > 5) { this.prevY.shift() }\n  }\n\n  protected updateDirection(): void {\n    const direction: string[] = []\n\n    const dx = this.prevX[this.prevX.length - 1] - this.prevX[this.prevX.length - 2]\n    const dy = this.prevY[this.prevY.length - 1] - this.prevY[this.prevY.length - 2]\n\n    if (dy > 0) {\n      direction.push(Directions.S)\n    }\n    else if (dy < 0) {\n      direction.push(Directions.N)\n    }\n\n    if (dx > 0) {\n      direction.push(Directions.E)\n    }\n    else if (dx < 0) {\n      direction.push(Directions.W)\n    }\n\n    const directionString = direction.join('') || this.direction || 'S'\n\n    this.direction = Directions[directionString as keyof typeof Directions]\n  }\n\n  protected checkIfMoving(): boolean {\n    const xUnchanged = this.prevX[this.prevX.length - 1] === this.prevX[this.prevX.length - 2]\n    const yUnchanged = this.prevY[this.prevY.length - 1] === this.prevY[this.prevY.length - 2]\n    if (xUnchanged && yUnchanged) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  protected initializeHealth(healthPercentage: number = 1.0): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n\n  // TODO: The color strings can be moved to a single hash map in order to optimize & localize the color searches\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.1) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.2) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.3) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.4) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.5) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.6) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.7) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.8) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.9) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n}\n","enum CreatureState {\n  Idling,\n  Moving,\n  Attacking,\n  Dying,\n  Decaying,\n}\n\nexport default CreatureState\n","import { totalNumberOfMaps } from '@app/domain/map/Maps'\n\nexport default class Level {\n  public static lastLevel = totalNumberOfMaps\n\n  public static readonly startingLevel = 1\n\n  public static currentLevel = Level.startingLevel\n\n  public static resetToStartingLevel() {\n    Level.currentLevel = Level.startingLevel\n\n    LevelTimer.reset()\n  }\n\n  public static nextLevel() {\n    Level.currentLevel++\n\n    LevelTimer.reset()\n  }\n\n  public static isLastLevel() {\n    return (Level.currentLevel === Level.lastLevel)\n  }\n}\n\nimport * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport GameTime from '@app/infrastructure/GameTime'\n\nexport class LevelTimer {\n  public static timeSpentOnCurrentLevel = 0 // ms\n\n  public static incrementTimeSpentOnCurrentLevel() {\n    LevelTimer.timeSpentOnCurrentLevel += GameTime.frameElapsedTime\n  }\n\n  public static reset() {\n    LevelTimer.timeSpentOnCurrentLevel = 0\n  }\n\n  public static debug_displayTimeSpentOnCurrentLevel() {\n    context.beginPath()\n      context.fillStyle = '#9999ff'\n      context.font = '8px Monospace'\n      const levelTimeInSeconds = Math.round(LevelTimer.timeSpentOnCurrentLevel / 1000)\n      context.fillText(`Level ${Level.currentLevel} Time: ${levelTimeInSeconds}`, 10, CONFIG.CANVAS_HEIGHT - 24)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GameTime from '@app/infrastructure/GameTime'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, findShortestPath, debug_drawPathNodes, drawNode } from '@app/infrastructure/Pathfinding'\n\nimport CreatureState from '@app/domain/CreatureState'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport Sprites from '@app/graphics/Sprites'\n\nexport default class ConcreteEnemy extends Enemy {\n  protected sprite: CreatureSprite = Sprites.Zerg\n  protected target: Point\n\n  // TODO: Extract to CreatureState objects\n  // TODO: Adjust the feeling of enemy attack & animation\n  protected attackSpeed = 0.45 // seconds\n  private animationLengthAttack   = 420 // ms\n  private animationProgressAttack = 0   // ms\n  private animationLengthMove   = 330 // ms\n  private animationProgressMove = 0   // ms\n\n  constructor(\n    x: number,\n    y: number,\n    speed: number,\n    healthPercentage: number,\n  ) {\n    super(x, y, new CollisionBox(14, 14), speed, healthPercentage)\n  }\n\n  public update(player: Player, enemies: Enemy[]): void {\n    if (this.state === CreatureState.Dying) {\n      return\n    }\n    if (this.state === CreatureState.Decaying) {\n      return\n    }\n\n    if (!this.target) {\n      this.target = player\n    }\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n    this.updatePreviousCoordinates()\n\n    this.stuck = this.checkIfStuck() // TODO: Extract to state\n\n    if (\n      this.state !== CreatureState.Idling &&\n      this.state !== CreatureState.Attacking &&\n      this.checkIfMoving() === false\n    ) {\n      this.setState(CreatureState.Idling)\n    }\n\n    this.adjustCollisionWithWalls()\n    this.checkForCollisionWithPlayer(player)\n    this.checkForCollisionWithOtherEnemies(player)\n    this.distanceFromTarget = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   },\n    )\n\n    const targetIsInRange = this.targetInRange(player)\n    if (this.state !== CreatureState.Attacking && targetIsInRange) {\n      this.resetAttackCooldown()\n      this.setState(CreatureState.Attacking)\n    }\n\n    if (this.state === CreatureState.Attacking) {\n      if (targetIsInRange) {\n        this.attack(player)\n      } else {\n        this.setState(CreatureState.Moving)\n      }\n    }\n\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy =\n      Raycaster.determineIfThereAreObstaclesBetweenTwoPathNodes(this, player)\n\n    if ( // TODO: Clean this if statement up, if possible?\n      this.state === CreatureState.Idling ||\n      this.state === CreatureState.Moving\n    ) {\n      this.findPathToPlayer(player, this.thereAreObstaclesBetweenPlayerAndThisEnemy)\n\n      if (\n        this.state !== CreatureState.Moving &&\n        (\n          this.thereAreObstaclesBetweenPlayerAndThisEnemy === false ||\n          this.shortestPath.length > 0\n        )\n      ) {\n        this.setState(CreatureState.Moving)\n      }\n    }\n\n    if (this.state === CreatureState.Moving) {\n      this.move()\n    }\n\n    this.updateDirection() // TODO: This is based on movement, which is incorrect - fix it\n    this.updateTileDeltas()\n\n    if (Game.stateManager.getState() === GAME_STATES.PLAYING) {\n      this.advanceAnimation()\n    }\n  }\n\n  public draw(player: Player): void {\n    if (CONFIG.DEBUG.ENEMY_COLLISION_BOX) {\n      this.debug_drawCollisionBox(player)\n    }\n    if (CONFIG.DEBUG.ENEMY_STATE) {\n      this.debug_drawState(player)\n    }\n    if (CONFIG.DEBUG.RAY_TO_PLAYER) {\n      this.debug_drawRayToPlayer(player)\n    }\n    if (CONFIG.DEBUG.PATHFINDING_NODES) {\n      debug_drawPathNodes(this.pathfindingNodes, player, this.getHealthColor())\n    }\n\n    if (CONFIG.DEBUG.SHORTEST_PATH_TO_PLAYER) {\n      this.debug_drawShortestPathToPlayer(player)\n    }\n    this.sprite.draw(this, { x: player.x, y: player.y })\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.setState(CreatureState.Decaying)\n  }\n\n  protected advanceAnimation(): void {\n    // TODO: Extract to CreatureState objects\n    if (this.state === CreatureState.Attacking) {\n      this.animationProgressAttack = (this.animationProgressAttack + GameTime.elapsedTimeFactor) % this.animationLengthAttack\n      this.animationSpritePosition = Math.round((this.animationProgressAttack / this.animationLengthAttack) * this.sprite.numberOfSpritesInAnimation.attacking) % this.sprite.numberOfSpritesInAnimation.attacking\n    } else if (this.state === CreatureState.Moving) {\n      this.animationProgressMove = (this.animationProgressMove + GameTime.elapsedTimeFactor) % this.animationLengthMove\n      this.animationSpritePosition = Math.round((this.animationProgressMove / this.animationLengthMove) * this.sprite.numberOfSpritesInAnimation.walking) % this.sprite.numberOfSpritesInAnimation.walking\n    }\n  }\n\n  // TODO: Move to Enemy\n  private findPathToPlayer(player: Player, thereAreObstaclesBetweenPlayerAndThisEnemy: boolean) {\n    if (thereAreObstaclesBetweenPlayerAndThisEnemy) { // TODO: || this.isStuck()\n      if (this.pathfindingTimer === 0) {\n        this.pathfindingNodes = generatePathNodes(\n          Math.round(Math.abs(player.row + this.row) / 2),\n          Math.round(Math.abs(player.col + this.col) / 2),\n          this.collisionBox,\n        )\n        this.shortestPath = findShortestPath(this, player, this.pathfindingNodes)\n      }\n\n      this.pathfindingTimer += GameTime.elapsedTimeFactor\n      if (this.pathfindingTimer > this.pathfindingInterval) {\n        this.pathfindingTimer = 0\n      }\n\n      if (this.shortestPath.length > 0) {\n        this.followTheShortestPath()\n      }\n    }\n    else { // Target is in line of sight\n      if (this.pathfindingNodes) {\n        this.pathfindingNodes = null\n      }\n      if (this.shortestPath) {\n        this.shortestPath = []\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private followTheShortestPath(): void {\n    // If the enemy is close to the path node, pop that node and move to the next one\n    let nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n    let nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    if (\n      this.shortestPath.length > 1 &&\n      Math.abs(nextNodeX - this.x) < 3 &&\n      Math.abs(nextNodeY - this.y) < 3\n    ) {\n      this.shortestPath.pop()\n      nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n      nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    }\n    this.moveTowards(nextNodeX, nextNodeY)\n  }\n\n  private moveTowardsPlayer(player: Point): void {\n    if (this.distanceFromTarget > this.collisionBox.width) {\n      this.moveTowards(player.x, player.y)\n    }\n    else {\n      this.resetMoving()\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.resetMoving()\n\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Move to Creature since it's shared between enemies and player\n  private debug_drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.2\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  private debug_drawState(player: Player) {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n      context.fillText(\n        this.state.toString(),\n        Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,\n        Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight\n      )\n    context.stroke()\n  }\n\n  private debug_drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n\n  private debug_drawShortestPathToPlayer(p: Player) {\n    this.shortestPath\n      .forEach((n, i) => {\n        drawNode(n, p, n.visited ? '#FF0000' : '#FF00FF')\n      })\n    if (this.shortestPath.length > 0) {\n      this.shortestPath.forEach((node, i) => {\n        this.debug_drawRayFromPointToPoint(node, this.shortestPath[i - 1] || p, p)\n      })\n    }\n  }\n\n  private debug_drawRayFromPointToPoint(p1: Point, p2: Point, player: Player) {\n    context.strokeStyle = '#FF00FF'\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (p2.x - player.x), Canvas.center.y + (p2.y - player.y))\n      context.lineTo(Canvas.center.x + (p1.x - player.x), Canvas.center.y + (p1.y - player.y))\n    context.stroke()\n  }\n\n  // Move to Animation objects\n  protected resetAnimation() {\n    this.animationSpritePosition = 0\n    this.animationProgressAttack = 0\n    this.animationProgressMove = 0\n  }\n\n  public setState(newState: CreatureState) {\n    this.previousState = this.state\n    this.state = newState\n    this.resetAnimation()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport GameTime from '@app/infrastructure/GameTime'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport { PathNode } from '@app/infrastructure/Pathfinding'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport Creature from '@app/domain/Creature'\nimport Player from '@app/domain/player/Player'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Map from '../map/Map'\n\nexport default abstract class Enemy extends Creature {\n  protected stuck: boolean // TODO: Use stuck for something?\n\n  protected distanceFromTarget: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathfindingTimer: number = 0\n  protected pathfindingInterval: number = 500 // ms\n  protected pathfindingNodes: PathNode[]\n  protected shortestPath: PathNode[] = []\n\n  protected sprite: CreatureSprite\n\n  // TODO: Move this to Weapon\n  protected readonly attackSpeed: number // seconds\n  protected attackCooldown: number       // milliseconds\n\n  constructor(\n    x: number,\n    y: number,\n    collisionBox: CollisionBox,\n    speed: number,\n    healthPercentage: number,\n  ) {\n    super(x, y, collisionBox, speed, healthPercentage)\n\n    // TODO: Move this function to Weapon\n    this.resetAttackCooldown()\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player, enemies: Enemy[]): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    const offScreenOffset = CONFIG.TILE_SIZE * 2\n    return (\n      Math.abs(this.x - playerX) < CONFIG.CANVAS_WIDTH / 2 + offScreenOffset &&\n      Math.abs(this.y - playerY) < CONFIG.CANVAS_HEIGHT / 2 + offScreenOffset\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n  protected abstract advanceAnimation(): void\n\n  protected checkForCollisionWithPlayer(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    this.checkIfBlockedByCreature(player, nextEnemyState)\n  }\n\n  protected checkForCollisionWithOtherEnemies(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesInScreenRangeFromThis = Map.getEnemiesOnScreen(this.x, this.y)\n\n    enemiesInScreenRangeFromThis.forEach((e) => {\n      if (this !== e) {\n        this.checkIfBlockedByCreature(e, nextEnemyState)\n      }\n    })\n  }\n\n  protected targetInRange(target: Creature) {\n    const sumOfCollisionBoxHalfDiagonals = (target.collisionBox.halfWidth + this.collisionBox.halfWidth) * Math.sqrt(2)\n    return this.distanceFromTarget < sumOfCollisionBoxHalfDiagonals\n  }\n\n  protected checkIfStuck(): boolean {\n    const xIsStatic = this.prevX.every((x) => x === this.prevX[0])\n    const yIsStatic = this.prevY.every((y) => y === this.prevY[0])\n    if (xIsStatic && yIsStatic) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  protected attack(p: Player): void {\n    if (this.attackCooldown <= 0) {\n      this.resetAttackCooldown()\n\n      SoundFX.playSMG() // TODO: Change the SFX\n      this.dealDamage(p)\n    } else {\n      this.attackCooldown -= GameTime.frameElapsedTime\n    }\n  }\n\n  protected resetAttackCooldown() {\n    this.attackCooldown = (1000 * this.attackSpeed) / CONFIG.GAME_SPEED\n  }\n\n  protected dealDamage(p: Player) {\n    p.takeDamage(this.getDamage())\n  }\n\n  // TODO: Implement damage range\n  protected getDamage() {\n    return 10\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Player from '@app/domain/player/Player'\nimport CreatureState from '@app/domain/CreatureState'\nimport ConcreteEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport MapKeys, { isWall } from '@app/domain/map/MapKeys'\nimport Wall from '@app/domain/objects/wall/Wall'\nimport WallFactory from '@app/domain/objects/wall/WallFactory'\nimport Portal from '@app/domain/objects/portal/Portal'\n\nimport IMap from './IMap'\nimport getMapData from '@app/domain/map/Maps'\nimport Level from '@app/domain/Level'\n\nexport default class Map {\n  public static walls: Wall[][] = []\n  public static enemies: Enemy[] = []\n  public static exitPortal: Portal\n\n  public player: Player\n\n  public static getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n    return Map.enemies.filter(e => e.isOnScreen(playerX, playerY))\n  }\n\n  public static enemiesRemaining(): number {\n    return Map.enemies.length\n  }\n\n  constructor() {\n    const mapData = getMapData(Level.currentLevel)\n    this.loadMap(mapData)\n    this.player = new Player(mapData.player.x, mapData.player.y)\n  }\n\n  public destroy() {\n    while (Map.enemies.length) {\n      Map.enemies.pop()\n    }\n  }\n\n  public update(): void {\n    Map.enemies.forEach((e, i) => {\n      e.update(this.player, Map.enemies)\n      if (e.state === CreatureState.Decaying) {\n        Map.enemies.splice(i, 1) // Remove the enemy\n        this.openPortalWhenAllEnemiesAreKilled()\n      }\n    })\n  }\n\n  private openPortalWhenAllEnemiesAreKilled() {\n    if (Map.exitPortal.isOpen === false && Map.enemies.length === 0) {\n      Map.exitPortal.open()\n    }\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    Map.getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n\n    // Limits the rendering range to only what is visible on the screen\n    let wall\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (Map.walls[row] && Map.walls[row][col]) {\n          wall = Map.walls[row][col]\n          wall.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          wall.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          wall.draw()\n        }\n        if (Map.exitPortal.row === row && Map.exitPortal.col === col) {\n          Map.exitPortal.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          Map.exitPortal.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          Map.exitPortal.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    this.loadGameObjects(map)\n    this.loadEnemies(map)\n  }\n\n  // Inefficient - provides clearer separation (loading happens once - so it's not a big deal)\n  private loadGameObjects(map: IMap) {\n    this.loadWalls(map)\n    this.loadExitPortal(map)\n  }\n\n  private loadWalls(map: IMap) {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      Map.walls[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        const mapKey = map.gameObjects[row][col] \n        Map.walls[row][col] = null\n        if (isWall(mapKey)) {\n          Map.walls[row][col] = WallFactory.createWall(row, col, mapKey)\n        }\n      }\n    }\n  }\n\n  private loadExitPortal(map: IMap) {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        const mapKey = map.gameObjects[row][col] \n        if (mapKey === MapKeys.ExitPortal) {\n          Map.exitPortal = new Portal(row, col)\n        }\n      }\n    }\n  }\n\n  private loadEnemies(map: IMap) {\n    map.enemies.forEach(e => {\n      Map.enemies.push(new ConcreteEnemy(e.x, e.y, 0.125, e.healthPercentage))\n    })\n  }\n}\n","enum MapKeys {\n  Empty      = 0,\n  WallGray   = 1,\n  WallGreen  = 2,\n  WallBlue   = 3,\n  ExitPortal = 9,\n}\n\nexport function isWall(mapKey: MapKeys) {\n  return (\n    mapKey ===  MapKeys.WallGray  ||\n    mapKey ===  MapKeys.WallGreen ||\n    mapKey ===  MapKeys.WallBlue\n  )\n}\n\nexport default MapKeys\n","import IMap from './IMap'\n\nimport * as Map01 from '@app/resources/maps/Map-01.json'\nimport * as Map02 from '@app/resources/maps/Map-02.json'\n\nconst Maps: { [key: string]: IMap } = {\n  Map01,\n  Map02,\n}\n\nexport const totalNumberOfMaps = Object.keys(Maps).length\n\nexport default function getMapData(levelNumber: number): IMap {\n  const zeroPaddedLevelNumber = String(levelNumber).padStart(2, '0')\n  return Maps[`Map${zeroPaddedLevelNumber}`]\n}","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport PortalObject from './PortalObject'\n\nexport default class Portal extends PortalObject {\n  public isOpen = false\n\n  protected static openColor   = 'rgba(50, 120, 50, 0.2)'\n  protected static closedColor = 'rgba(180, 50, 50, 0.2)'\n\n  draw(): void {\n    context.fillStyle = this.getColor()\n    context.beginPath()\n      context.rect(\n        this.x,\n        this.y,\n        CONFIG.TILE_SIZE,\n        CONFIG.TILE_SIZE\n      );\n    context.fill()\n  }\n\n  public open() {\n    this.isOpen = true\n  }\n\n  private getColor(): string {\n    if (this.isOpen) {\n      return Portal.openColor\n    }\n    else {\n      return Portal.closedColor\n    }\n  }\n}\n","export default abstract class GameObject {\n  public x: number\n  public y: number\n\n  public isOpen: boolean\n\n  protected static openColor   : string\n  protected static closedColor : string\n\n  constructor(\n    public row: number,\n    public col: number,\n  ) {\n  }\n\n  public abstract draw(): void\n  public abstract open(): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Wall extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw the 'x'\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playWallHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Wall from '@app/domain/objects/wall/Wall'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class WallFactory {\n  public static createWall(row: number, col: number, mapKey: MapKeys): Wall {\n    switch (mapKey) {\n      case MapKeys.WallGray:\n        return new Wall(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.WallGreen:\n        return new Wall(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.WallBlue:\n        return new Wall(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such Wall!')\n    }\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport GameTime from '@app/infrastructure/GameTime'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox, {\n  collisionBoxesIntersect,\n} from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport Creature from '@app/domain/Creature'\nimport Map from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player extends Creature {\n  public alive: boolean = true\n  public rotation: number = 0\n  public sightLineLength = 10\n  private shooting = false\n\n  // TODO: Adjust for attack feeling\n  private attackSpeed = 0.1 // seconds\n  private attackCooldown = 0\n\n  private projectiles: Projectile[] = []\n\n  constructor(public x: number, public y: number) {\n    super(x, y, new CollisionBox(12, 12), 0.18, 1)\n  }\n\n  public update(): void {\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n\n    this.checkForCollisionWithEnemies()\n    this.move()\n    this.adjustCollisionWithWalls()\n    this.updateMapPosition()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    if (CONFIG.DEBUG.PLAYER_VISION_RAY_SHOTGUN) {\n      this.drawPlayerVisionRay(theta - 0.45)\n      this.drawPlayerVisionRay(theta - 0.4)\n      this.drawPlayerVisionRay(theta - 0.35)\n      this.drawPlayerVisionRay(theta - 0.3)\n      this.drawPlayerVisionRay(theta - 0.25)\n      this.drawPlayerVisionRay(theta - 0.2)\n      this.drawPlayerVisionRay(theta - 0.15)\n      this.drawPlayerVisionRay(theta - 0.1)\n      this.drawPlayerVisionRay(theta - 0.05)\n      this.drawPlayerVisionRay(theta + 0.05)\n      this.drawPlayerVisionRay(theta + 0.1)\n      this.drawPlayerVisionRay(theta + 0.15)\n      this.drawPlayerVisionRay(theta + 0.2)\n      this.drawPlayerVisionRay(theta + 0.25)\n      this.drawPlayerVisionRay(theta + 0.3)\n      this.drawPlayerVisionRay(theta + 0.35)\n      this.drawPlayerVisionRay(theta + 0.4)\n      this.drawPlayerVisionRay(theta + 0.45)\n    }\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  public keydownHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.w:\n        this.moving.up = true\n        break\n      case KEYBOARD_KEYS.a:\n        this.moving.left = true\n        break\n      case KEYBOARD_KEYS.s:\n        this.moving.down = true\n        break\n      case KEYBOARD_KEYS.d:\n        this.moving.right = true\n        break\n    }\n  }\n  public keyupHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.w:\n        this.moving.up = false\n        break\n      case KEYBOARD_KEYS.a:\n        this.moving.left = false\n        break\n      case KEYBOARD_KEYS.s:\n        this.moving.down = false\n        break\n      case KEYBOARD_KEYS.d:\n        this.moving.right = false\n        break\n      }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public shoot(): void {\n    if (this.shooting === false) {\n      return\n    }\n    if (this.attackCooldown <= 0) {\n      const dx = Canvas.mousePosition.x - Canvas.center.x\n      const dy = Canvas.mousePosition.y - Canvas.center.y\n      let xVel = dx / (Math.abs(dx) + Math.abs(dy))\n      let yVel = dy / (Math.abs(dx) + Math.abs(dy))\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      if (CONFIG.FEATURES.SCATTER_PROJECTILES) {\n        const randomFactorX = Math.random() * 0.1 - 0.05\n        const randomFactorY = Math.random() * 0.1 - 0.05\n        xVel += randomFactorX\n        yVel += randomFactorY\n      }\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.resetAttackCooldown()\n\n      SoundFX.playSMG()\n    } else {\n      this.attackCooldown -= GameTime.frameElapsedTime\n    }\n  }\n\n  protected resetAttackCooldown() {\n    this.attackCooldown = (1000 * this.attackSpeed) / CONFIG.GAME_SPEED\n  }\n\n  public takeDamage(damageAmount: number): void {\n    this.health = this.health - damageAmount\n    if (this.health <= 0) {\n      this.die()\n    }\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(` = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n    context.fillStyle = '#00AA00'\n    context.font = '10px Monospace'\n\n    context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n    context.strokeStyle = '#523DA5'\n    context.lineWidth = 2\n    context.moveTo(Canvas.center.x, Canvas.center.y)\n    context.lineTo(\n      Canvas.center.x + this.sightLineLength * Math.cos(theta),\n      Canvas.center.y + this.sightLineLength * Math.sin(theta),\n    )\n    context.stroke()\n\n    if (CONFIG.DEBUG.PLAYER_COLLISION_BOX) {\n      this.debug_drawCollisionBox()\n    }\n  }\n\n  private debug_drawCollisionBox() {\n    context.strokeStyle = this.getHealthColor()\n\n    context.lineWidth = 0.5\n    context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // cache the vertex calculations.\n    context.moveTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, wallHit } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (wallHit) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach((p) => p.draw(this.x, this.y))\n  }\n\n  private checkForCollisionWithEnemies(): void { // TODO: Extract to Creature?\n    const nextPlayerState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesOnScreen = Map.getEnemiesOnScreen(this.x, this.y)\n\n    if (\n      enemiesOnScreen.some((e) => collisionBoxesIntersect(e, nextPlayerState))\n    ) {\n      enemiesOnScreen.forEach((e) => {\n        this.checkIfBlockedByCreature(e, nextPlayerState)\n      })\n    }\n  }\n\n  private die(): void {\n    // TODO: Re-use CreatureState\n    this.alive = false\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Map from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithWall(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithWall()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...Map.enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithWall(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const wall = Map.walls[point.row][point.col]\n    if (wall) {\n        wall.takeDamage(this.getDamage())\n        this.alive = false\n        if (wall.destructable) {\n          Map.walls[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import Sprites from './Sprites'\n\nexport default class GraphicsLoader {\n  public static async load(setLoadedPercentage: (percentage: number) => void) {\n    Sprites.load(setLoadedPercentage)\n  }\n}","import CreatureSprite from './sprites/CreatureSprite'\nimport SpriteZerg from './sprites/SpriteZerg'\n\nexport default class Sprites {\n  public static Zerg: CreatureSprite = new SpriteZerg()\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    await Sprites.Zerg.load(() => setLoadedPercentage(1.0))\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default abstract class CreatureSprite {\n  public spriteSheet: HTMLImageElement\n\n  public abstract numberOfSpritesInAnimation: { [animation: string]: number }\n\n  protected abstract url: string\n  public abstract draw(e: Enemy, playerCoordinates: Point): void\n\n  public load(callback: () => void): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      this.spriteSheet = new Image()\n      this.spriteSheet.src = this.url\n      this.spriteSheet.onload = () => {\n        callback()\n        resolve()\n      }\n    })\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport CreatureState from '@app/domain/CreatureState'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nimport CreatureSprite from './CreatureSprite'\n\nexport default class SpriteZerg extends CreatureSprite {\n  public url: string = './graphics/spritesheets/zergling.png'\n\n  public numberOfSpritesInAnimation = {\n    walking: 7,\n    attacking: 5,\n  }\n\n  private spriteLocations: { [key: string]: { col: number, flip: boolean } } = {\n    N : { col: 0, flip: false },\n    NE: { col: 2, flip: false },\n    E : { col: 4, flip: false },\n    SE: { col: 6, flip: false },\n    S : { col: 8, flip: false },\n    SW: { col: 6, flip: true  },\n    W : { col: 4, flip: true  },\n    NW: { col: 2, flip: true  },\n  }\n  private spriteSize = 32\n  private spriteStep: Point\n\n  constructor() {\n    super()\n    this.spriteStep = { x: this.spriteSize + 11, y: this.spriteSize + 10 }\n  }\n\n  public draw(enemy: Enemy, playerCoordinates: Point) {\n    const spriteOffsets: Point = this.getSpriteOffsets(enemy.state, this.spriteStep)\n\n    const spriteLocation = this.spriteLocations[enemy.direction]\n\n    this.drawSprite(enemy, playerCoordinates, spriteOffsets, spriteLocation)\n  }\n\n  private getSpriteOffsets(enemyState: CreatureState, SPRITE_STEP: Point) {\n    switch (enemyState) {\n      case CreatureState.Moving:\n      case CreatureState.Idling:\n        return {\n          x: 7,\n          y: 5\n        }\n      case CreatureState.Attacking:\n        const ATTACK_SPRITES_ROW = 7\n        return {\n          x: 7,\n          y: 5 + (ATTACK_SPRITES_ROW * SPRITE_STEP.y)\n        }\n    }\n  }\n\n  private drawSprite(\n    enemy: Enemy,\n    playerCoordinates: Point,\n    spriteOffsets: Point,\n    spriteLocation: { col: number, flip: boolean },\n  ) {\n\n    const { x, y, collisionBox: cBox } = enemy\n    const { x: px, y: py } = playerCoordinates\n\n    if (spriteLocation.flip) {\n      context.save()\n      context.translate(\n        Canvas.center.x + (x - px - cBox.halfWidth),\n        Canvas.center.y + (y - py - cBox.halfHeight),\n      )\n      context.scale(-1, 1)\n    }\n\n    context.drawImage(\n      this.spriteSheet,\n      spriteOffsets.x + this.spriteStep.x * spriteLocation.col,\n      spriteOffsets.y + this.spriteStep.y * Math.floor(enemy.animationSpritePosition),\n      this.spriteSize,\n      this.spriteSize,\n      spriteLocation.flip ? 0 - this.spriteSize / 2 : Canvas.center.x + (x - px - cBox.halfWidth),  // Canvas Desination X\n      spriteLocation.flip ? 0                       : Canvas.center.y + (y - py - cBox.halfHeight), // Canvas Desination Y\n      enemy.collisionBox.width  + 2, // Draw width\n      enemy.collisionBox.height + 2, // Draw height\n    )\n\n    if (spriteLocation.flip) {\n      context.restore()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    // TODO: Just a development warning, remove this in production\n    if (CONFIG.THROW_DEVELOPMENT_ERRORS) {\n      if (width % 2 !== 0 || height % 2 !== 0) {\n        throw new Error('Always use even numbers for collision box dimensions!')\n      }\n    }\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n\nexport interface ICollidable {\n  x: number\n  y: number\n  collisionBox: CollisionBox\n}\n\nexport function collisionBoxesIntersect(a: ICollidable, b: ICollidable): boolean {\n  return (\n    a.x - a.collisionBox.halfWidth  < b.x + b.collisionBox.halfWidth  &&\n    a.x + a.collisionBox.halfWidth  > b.x - b.collisionBox.halfWidth  &&\n    a.y - a.collisionBox.halfHeight < b.y + b.collisionBox.halfHeight &&\n    a.y + a.collisionBox.halfHeight > b.y - b.collisionBox.halfHeight\n  )\n}","export enum Directions {\n  N  = 'N',\n  NE = 'NE',\n  E  = 'E',\n  SE = 'SE',\n  S  = 'S',\n  SW = 'SW',\n  W  = 'W',\n  NW = 'NW',\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\n\nexport default class FrameRate {\n\n  public static restart() {\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(lastFrameTime: number, frameElapsedTime: number): void {\n    if (!lastFrameTime) {\n      FPS = 0\n    } else {\n      FPS_ARR.unshift(1000 / frameElapsedTime)\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n    }\n  }\n\n  public static debug_drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","\nenum GameAssets {\n  Graphics,\n  Audio,\n}\n\nexport default GameAssets","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class GameTime {\n  public static readonly ONE_SECOND = 1000\n\n  public static previousTimestamp = 0 // Milliseconds\n  public static frameElapsedTime  = 0 // Milliseconds\n\n  // Determines the game & animation speed\n  public static elapsedTimeFactor: number\n\n  public static setFrameElapsedTime(t: number) {\n    GameTime.frameElapsedTime  = t\n    GameTime.elapsedTimeFactor = CONFIG.GAME_SPEED * GameTime.frameElapsedTime\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport RaycastablePoint from './geometry/RaycastablePoint'\n\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): PathNode[] {\n  const path: PathNode[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!Map.walls[row] || !Map.walls[row][col]) {\n        if (col > 0 && row > 0) {\n          path.push(new PathNode({\n            x: col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n            y: row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n          }, cBox))\n        }\n      }\n    }\n  }\n\n  return path\n}\n\nexport function debug_drawPathNodes(path: PathNode[], player: Player, color: string): void {\n  if (path) {\n    path.forEach(node => drawNode(node, player, color))\n  }\n}\n\nexport function drawNode(node: PathNode, player: Player, color: string): void {\n  context.strokeStyle = color\n  context.lineWidth = 0.1\n  context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // optimize/cache the vertex calculations.\n    context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n  context.stroke()\n\n  context.beginPath()\n    context.arc(\n      Canvas.center.x + (node.x - player.x),\n      Canvas.center.y + (node.y - player.y),\n      1,\n      0,\n      (2 * Math.PI)\n    )\n  context.stroke()\n}\n\nexport function findShortestPath(enemy: Enemy, player: Player, pathfindingNodes: PathNode[]): PathNode[] {\n  const nodeGoal  = new PathNode(player, player.collisionBox)\n  const nodeStart = new PathNode(enemy,  enemy.collisionBox)\n\n  pathfindingNodes.push(nodeGoal)\n\n  nodeStart.f = 0\n  nodeStart.g = nodeStart.heuristic(nodeGoal)\n\n  const nodesNotTested: PathNode[] = [ nodeStart ]\n\n  let nodeCurrent: PathNode\n\n  while (nodesNotTested.length > 0 || nodeCurrent === nodeGoal) {\n    nodesNotTested.sort((a: PathNode, b: PathNode) => a.g - b.g)\n\n    while (nodesNotTested.length > 0 && nodesNotTested[0].visited === true) {\n      nodesNotTested.shift()\n    }\n\n    if (nodesNotTested.length <= 0) {\n      break\n    }\n\n    nodeCurrent = nodesNotTested.shift()\n    nodeCurrent.visited = true\n\n    // Get neighbour nodes.\n    nodeCurrent.neighbourNodes = [ ...pathfindingNodes ]\n      .filter(node => {\n        return (\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row    ) || // Center\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row - 1) || // N\n          (node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row    ) || // E\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row + 1) || // S\n          (node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row    ) || // W\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row - 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col + 1] === null ||\n              !Map.walls[node.row + 1] || Map.walls[node.row + 1][node.col    ] === null\n            )\n          ) || // NW\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row - 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col - 1] === null ||\n              !Map.walls[node.row + 1] || Map.walls[node.row + 1][node.col    ] === null\n            )\n          ) || // NE\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row + 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col - 1] === null ||\n              !Map.walls[node.row - 1] || Map.walls[node.row - 1][node.col    ] === null\n            )\n          ) || // SE\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row + 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col + 1] === null ||\n              !Map.walls[node.row - 1] || Map.walls[node.row - 1][node.col    ] === null\n            )\n          ) // SW\n        )\n      })\n\n    nodeCurrent.neighbourNodes\n      .map(node => {\n        if (node.visited === false) {\n          nodesNotTested.push(node)\n        }\n\n        // Calculate local goal\n        const possiblyLowerLocalGoal = nodeCurrent.f + pointToPointDistance(nodeCurrent, node)\n\n        if (possiblyLowerLocalGoal < node.f) {\n          node.parent = nodeCurrent\n          node.f = possiblyLowerLocalGoal\n          node.g = node.f + node.heuristic(nodeGoal)\n        }\n\n        return node\n      })\n  }\n\n  const path = []\n  if (nodeGoal.parent) {\n    let n: PathNode = nodeGoal\n    while (n.parent) {\n      path.push(n)\n      n = n.parent\n    }\n  }\n  return path\n}\n\nexport class PathNode implements RaycastablePoint {\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  public visited: boolean = false\n  public g: number = Infinity // Global goal\n  public f: number = Infinity // Local goal\n  public parent: PathNode = null\n  public neighbourNodes: PathNode[]\n\n  constructor(coordinates: Point, cBox: CollisionBox) {\n    this.x = coordinates.x\n    this.y = coordinates.y\n    this.collisionBox = new CollisionBox(cBox.width, cBox.height)\n    this.updateTileDeltas()\n    this.updateMapPosition()\n  }\n\n  public heuristic(nodeGoal: PathNode): number {\n    return pointToPointDistance(this, nodeGoal)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\nimport Wall from '@app/domain/objects/wall/Wall'\nimport Map from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport RaycastablePoint from './geometry/RaycastablePoint'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { PathNode } from './Pathfinding'\nimport Player from '@app/domain/player/Player'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   wallHit, // the wall that has been hit. If no walls are hit - wallHit is `null`\n   *   hitPoint // can be either a point where the ray intersects a wall, or a just a point outside the screen if no wall is hit\n   * }\n   */\n  public static cast(\n    p: RaycastablePoint,\n    theta: number,\n    pEnd?: RaycastablePoint\n  ): { hitPoint: Point, wallHit: Wall } {\n    if (theta >= 0) { // South\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta, pEnd)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta, pEnd)\n      }\n    } else { // North\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta, pEnd)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta, pEnd)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  public static determineIfThereAreObstaclesBetweenTwoPoints(p1: RaycastablePoint, p2: RaycastablePoint): boolean {\n    const angleBetweenTwoGivenPoints = angleBetweenPoints(p2, p1)\n    const results = Raycaster.cast(p1, angleBetweenTwoGivenPoints, p2)\n\n    // I have to check if results exist because sometimes .cast() can return 'undefined'..\n    // Why .cast() sometimes returns 'undefined' could be worth investigating in the future..\n    if (results) {\n      return results.wallHit !== null\n    }\n    else {\n      return true\n    }\n  }\n\n  // This function is very computationaly expensive, see if it can be optimized\n  public static determineIfThereAreObstaclesBetweenTwoPathNodes(n1: PathNode | Enemy, n2: PathNode | Player) {\n    const angleBetweenNodes: number = +angleBetweenPoints(n2, n1).toFixed(2)\n\n    if (angleBetweenNodes === 0) { // 0deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > 0 && angleBetweenNodes < Math.PI / 2) { // between 0deg and 90deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === (Math.PI / 2)) { // 90deg\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > Math.PI / 2 && angleBetweenNodes < Math.PI) { // between 90deg and 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (Math.abs(angleBetweenNodes) === 3.14) { // 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI && angleBetweenNodes < -Math.PI / 2) { // between 180deg and 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === -1.57) { // 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI / 2 && angleBetweenNodes < 0) { // between 270deg and 360deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n  }\n\n  private static outsideOfScreenOffset = CONFIG.TILE_SIZE * 2\n  private static rangeHorizontal: number = Canvas.halfWidth  + Raycaster.outsideOfScreenOffset\n  private static rangeVertical: number   = Canvas.halfHeight + Raycaster.outsideOfScreenOffset * 2\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalSE(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyBottom > (pEnd.y - p.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalSE(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        wallHit : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        wallHit : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalNE(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y - tileStepY - p.deltas.dyTop,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalNE(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        wallHit : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        wallHit : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalNW(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (p.x - pEnd.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - xIntercept,\n            y: Canvas.center.y - p.deltas.dyTop - tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalNW(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        wallHit : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        wallHit : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalSW(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (-xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if ((tileStepY + p.deltas.dyBottom > (pEnd.y - p.y)) || (-xIntercept > (p.x - pEnd.x))) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalSW(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit wall\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint : hitPointVertical,\n        wallHit  : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint : hitPointHorizontal,\n        wallHit  : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint : hitPointHorizontal,\n          wallHit  : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint : hitPointVertical,\n          wallHit  : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkWallCollisionVerticalSE(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile]) {\n      if (Map.walls[yTile][xTile]) {\n        wallHit = Map.walls[yTile][xTile]\n      }\n      else if (Map.walls[yTile_aboveByOnePixel][xTile]) {\n        wallHit = Map.walls[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalSE(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n\n  private static checkWallCollisionVerticalNE(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalNE(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const xTile_leftByOnePixel = p.col + Math.floor((p.deltas.dxLeft + xIntercept - 1) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let wallHit = null\n    if (Map.walls[yTile]) {\n      if (Map.walls[yTile][xTile]) {\n        wallHit = Map.walls[yTile][xTile]\n      }\n      else if (Map.walls[yTile][xTile_leftByOnePixel]) {\n        wallHit = Map.walls[yTile][xTile_leftByOnePixel]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n\n  private static checkWallCollisionVerticalNW(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalNW(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n\n  private static checkWallCollisionVerticalSW(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile]) {\n      if (Map.walls[yTile][xTile]) {\n        wallHit = Map.walls[yTile][xTile]\n      }\n      else if (Map.walls[yTile_aboveByOnePixel][xTile]) {\n        wallHit = Map.walls[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalSW(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n}\n\nconst blankVertex: Point = {\n  x: 0,\n  y: 0,\n  deltas: {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  },\n}\nconst vertexNW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\n\nfunction getVerticesNW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexNW1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNW1.row = Math.floor(vertexNW1.y / CONFIG.TILE_SIZE)\n  vertexNW1.col = Math.floor(vertexNW1.x / CONFIG.TILE_SIZE)\n  vertexNW1.deltas.dyTop = vertexNW1.y % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW1.deltas.dyTop\n  vertexNW1.deltas.dxLeft = vertexNW1.x % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW1.deltas.dxLeft\n\n  vertexNW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexNW2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNW2.row = Math.floor(vertexNW2.y / CONFIG.TILE_SIZE)\n  vertexNW2.col = Math.floor(vertexNW2.x / CONFIG.TILE_SIZE)\n  vertexNW2.deltas.dyTop = vertexNW2.y % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW2.deltas.dyTop\n  vertexNW2.deltas.dxLeft = vertexNW2.x % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW2.deltas.dxLeft\n\n  return [ vertexNW1, vertexNW2 ]\n}\n\nfunction getVerticesNE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexNE1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNE1.row = Math.floor(vertexNE1.y / CONFIG.TILE_SIZE)\n  vertexNE1.col = Math.floor(vertexNE1.x / CONFIG.TILE_SIZE)\n  vertexNE1.deltas.dyTop = vertexNE1.y % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE1.deltas.dyTop\n  vertexNE1.deltas.dxLeft = vertexNE1.x % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE1.deltas.dxLeft\n\n  vertexNE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexNE2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNE2.row = Math.floor(vertexNE2.y / CONFIG.TILE_SIZE)\n  vertexNE2.col = Math.floor(vertexNE2.x / CONFIG.TILE_SIZE)\n  vertexNE2.deltas.dyTop = vertexNE2.y % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE2.deltas.dyTop\n  vertexNE2.deltas.dxLeft = vertexNE2.x % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE2.deltas.dxLeft\n\n  return [ vertexNE1, vertexNE2 ]\n}\n\nfunction getVerticesSW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexSW1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSW1.row = Math.floor(vertexSW1.y / CONFIG.TILE_SIZE)\n  vertexSW1.col = Math.floor(vertexSW1.x / CONFIG.TILE_SIZE)\n  vertexSW1.deltas.dyTop = vertexSW1.y % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW1.deltas.dyTop\n  vertexSW1.deltas.dxLeft = vertexSW1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW1.deltas.dxLeft\n\n  vertexSW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexSW2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSW2.row = Math.floor(vertexSW2.y / CONFIG.TILE_SIZE)\n  vertexSW2.col = Math.floor(vertexSW2.x / CONFIG.TILE_SIZE)\n  vertexSW2.deltas.dyTop = vertexSW2.y % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW2.deltas.dyTop\n  vertexSW2.deltas.dxLeft = vertexSW2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW2.deltas.dxLeft\n\n  return [ vertexSW1, vertexSW2 ]\n}\n\nfunction getVerticesSE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexSE1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSE1.row = Math.floor(vertexSE1.y / CONFIG.TILE_SIZE)\n  vertexSE1.col = Math.floor(vertexSE1.x / CONFIG.TILE_SIZE)\n  vertexSE1.deltas.dyTop = vertexSE1.y % CONFIG.TILE_SIZE\n  vertexSE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE1.deltas.dyTop\n  vertexSE1.deltas.dxLeft = vertexSE1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE1.deltas.dxLeft\n\n  vertexSE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexSE2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSE2.row = Math.floor(vertexSE2.y / CONFIG.TILE_SIZE)\n  vertexSE2.col = Math.floor(vertexSE2.x / CONFIG.TILE_SIZE)\n  vertexSE2.deltas.dyTop = vertexSE2.y % CONFIG.TILE_SIZE\n  vertexSE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE2.deltas.dyTop\n  vertexSE2.deltas.dxLeft = vertexSE2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE2.deltas.dxLeft\n\n  return [ vertexSE1, vertexSE2 ]\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport AudioLoader from '@app/audio/AudioLoader'\nimport GraphicsLoader from '@app/graphics/GraphicsLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\nimport GameTime from '../GameTime'\nimport FrameRate from '../FrameRate'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0\n  public static loadedPercentages: Map<GameAssets, { loaded: number, weight: number }> = new Map()\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n\n    Game.loadedPercentages.set(GameAssets.Graphics, { weight: 0.3, loaded: 0.0 })\n    Game.loadedPercentages.set(GameAssets.Audio,    { weight: 0.7, loaded: 0.0 })\n\n    AudioLoader.load(   percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n    GraphicsLoader.load(percentage => this.gameAssetLoaded(GameAssets.Graphics, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop(0)\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const assetValue = Game.loadedPercentages.get(asset)\n    assetValue.loaded = percentage\n    Game.loadedPercentages.set(asset, assetValue)\n\n    Game.loadedPercentage = 0\n    for (const [_key, value] of Game.loadedPercentages) {\n      Game.loadedPercentage += value.loaded * value.weight\n    }\n\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(timestamp: number): void {\n\n    if (GameTime.previousTimestamp === undefined) {\n      GameTime.previousTimestamp = timestamp\n    }\n    GameTime.setFrameElapsedTime(timestamp - GameTime.previousTimestamp)\n  \n    this.update()\n    this.render()\n    FrameRate.calculateFrameRate(GameTime.previousTimestamp, GameTime.frameElapsedTime)\n  \n    GameTime.previousTimestamp = timestamp\n    window.requestAnimationFrame((ts) => this.gameLoop(ts))\n  }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    if (CONFIG.DEBUG.FPS) {\n      FrameRate.debug_drawFPS()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateGameOver implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.handleEnterPress)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleEnterPress)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawGameOverScreen()\n  }\n\n  private handleEnterPress = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ENTER:\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n        break\n    }\n  }\n\n  private drawGameOverScreen(): void {\n    context.beginPath()\n      context.fillStyle = '#dd0000'\n      context.font = '32px Monospace'\n      context.fillText(\n        'YOU DIED!',\n        CONFIG.CANVAS_WIDTH / 2 - 80,\n        (CONFIG.CANVAS_HEIGHT / 2) + 10\n      )\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nimport Level, { LevelTimer } from '@app/domain/Level'\n\nexport default class GameStateLevelCleared implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.handleEnterPress)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleEnterPress)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLevelClearedStatistics()\n  }\n\n  private handleEnterPress = (e: KeyboardEvent) => {\n    if (e.keyCode === KEYBOARD_KEYS.ENTER) {\n      if (Level.isLastLevel()) {\n        Level.resetToStartingLevel()\n        Game.stateManager.setState(GAME_STATES.VICTORY)  \n      } else {\n        Level.nextLevel()\n        Game.stateManager.setState(GAME_STATES.PLAYING)\n      }\n    }\n  }\n\n  private drawLevelClearedStatistics(): void {\n    context.beginPath()\n      // Title\n      context.fillStyle = '#5555ff'\n      context.font = '22px Monospace'\n      context.fillText(\n        `Level ${Level.currentLevel} Cleared!`,\n        CONFIG.CANVAS_WIDTH / 2 - 100,\n        (CONFIG.CANVAS_HEIGHT / 2)\n      )\n      \n      // Level Time\n      context.font = '16px Monospace'\n      context.fillStyle = '#9999ff'\n      context.fillText(\n        `Time: ${Math.round(LevelTimer.timeSpentOnCurrentLevel / 1000)} seconds`,\n        CONFIG.CANVAS_WIDTH / 2 - 100,\n        (CONFIG.CANVAS_HEIGHT / 2) + 30\n      )\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GameTime from '@app/infrastructure/GameTime'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationProgress: number = 0\n  private animationLength: number = GameTime.ONE_SECOND\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationProgress = (this.animationProgress + GameTime.frameElapsedTime) % this.animationLength\n    if (this.animationProgress >= this.animationLength / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press Enter to start', CONFIG.CANVAS_WIDTH / 2 - 118, CONFIG.CANVAS_HEIGHT / 2 + 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ENTER:\n        Game.stateManager.setState(GAME_STATES.PLAYING)\n        break\n    }\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport Game from '@app/infrastructure/game/Game'\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.pauseHandler)\n  }\n\n  public exit(): void {\n    window.removeEventListener('keydown', this.pauseHandler)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private pauseHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ESC:\n        e.preventDefault()\n        GAME_STATES.PLAYING.destroyGame()\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n        break\n      case KEYBOARD_KEYS.p:\n        Game.stateManager.setState(GAME_STATES.PLAYING)\n        break\n    }\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Level, { LevelTimer } from '@app/domain/Level'\n\nexport default class GameStatePlaying implements IGameState {\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n    this.setupOwnEventListeners()\n  }\n\n  private setupOwnEventListeners() {\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n    window.addEventListener('keydown', this.pauseHandler)\n  }\n\n  public exit(nextState: IGameState): void {\n    this.clearOwnEventListeners()\n    if (nextState !== GAME_STATES.PAUSED) {\n      this.destroyGame()\n    }\n  }\n\n  private clearOwnEventListeners() {\n    window.onblur = null\n    window.removeEventListener('keydown', this.pauseHandler)\n  }\n\n  public update(): void {\n    if (this.player.alive) {\n      Canvas.updateMousePosition()\n      Gamepads.update(this.player)\n      this.player.update()\n      this.map.update()\n      this.checkForLevelClearedCondition()\n\n      LevelTimer.incrementTimeSpentOnCurrentLevel()\n    } else {\n      Level.resetToStartingLevel()\n      Game.stateManager.setState(GAME_STATES.GAME_OVER)\n    }\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n    if (CONFIG.DEBUG.SHOW_LEVEL_TIME) {\n      LevelTimer.debug_displayTimeSpentOnCurrentLevel()\n    }\n  }\n\n  private startNewGame(): void {\n    this.map = new Map()\n    this.player = this.map.player\n\n    Keyboard.addListenerKeydown(this.player.keydownHandler)\n    Keyboard.addListenerKeyup(this.player.keyupHandler)\n\n    Mouse.init(this.playerSetShootingTrue, this.playerSetShootingFalse)\n  }\n\n  private checkForLevelClearedCondition() {\n    if ( // TODO: Extract Level Cleared conditions (they won't be the same for every level)\n      Map.enemiesRemaining() === 0 &&\n      this.checkIfPlayerIsInsideExitPortal()\n    ) {\n        Game.stateManager.setState(GAME_STATES.LEVEL_CLEARED)  \n    }\n  }\n\n  private checkIfPlayerIsInsideExitPortal(): boolean {\n    return (\n      this.player.row === Map.exitPortal.row &&\n      this.player.col === Map.exitPortal.col\n    )\n  }\n\n  public destroyGame(): void {\n    Keyboard.removeKeydownAndKeyupListeners(this.player.keydownHandler)\n    Mouse.removeMouseLeftClickListeners(this.playerSetShootingTrue, this.playerSetShootingFalse)\n\n    this.map.destroy()\n    this.map = null\n    this.player = null\n  }\n\n  public playerSetShootingTrue = (e: MouseEvent) => {\n    this.player.setShooting(true) // TODO: Move to state: player.setState(CreatureState.Attacking)\n  }\n  public playerSetShootingFalse = (e: MouseEvent) => {\n    this.player.setShooting(false)\n  }\n\n  private pauseHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ESC:\n      case KEYBOARD_KEYS.p:\n        e.preventDefault()\n        Game.stateManager.setState(GAME_STATES.PAUSED)\n        break\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateVictory implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.handleEnterPress)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleEnterPress)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawVictoryScreen()\n  }\n\n  private handleEnterPress = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ENTER:\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n        break\n    }\n  }\n\n  private drawVictoryScreen(): void {\n    context.beginPath()\n      context.fillStyle = '#00dd00'\n      context.font = '32px Monospace'\n      context.fillText(\n        'VICTORY!',\n        CONFIG.CANVAS_WIDTH / 2 - 80,\n        (CONFIG.CANVAS_HEIGHT / 2) + 10\n      )\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\nimport GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStateLevelCleared from './GameStateLevelCleared'\nimport GameStatePaused from './GameStatePaused'\nimport GameStateGameOver from './GameStateGameOver'\nimport GameStateVictory from './GameStateVictory'\n\nconst GAME_STATES: {[ key: string ]: IGameState } = {\n  LOADING       : new GameStateLoading(),\n  MAIN_MENU     : new GameStateMainMenu(),\n  PLAYING       : new GameStatePlaying(),\n  LEVEL_CLEARED : new GameStateLevelCleared(),\n  PAUSED        : new GameStatePaused(),\n  GAME_OVER     : new GameStateGameOver(),\n  VICTORY       : new GameStateVictory(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nexport default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}\n\nexport function updatePointRowAndColValues(p: Point): void {\n  p.row = Math.floor(p.y / CONFIG.TILE_SIZE)\n  p.col = Math.floor(p.x / CONFIG.TILE_SIZE)\n}\n\nexport function updatePointDeltas(p: Point): void {\n  p.deltas.dyTop = p.y % CONFIG.TILE_SIZE\n  p.deltas.dyBottom = CONFIG.TILE_SIZE - p.deltas.dyTop\n  p.deltas.dxLeft = p.x % CONFIG.TILE_SIZE\n  p.deltas.dxRight = CONFIG.TILE_SIZE - p.deltas.dxLeft\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","type KeyboardEventListener = ((e: KeyboardEvent) => void)\n\nexport default class Keyboard {\n  public static addListenerKeydown(listener: KeyboardEventListener) {\n    document.addEventListener('keydown', listener)\n  }\n  public static addListenerKeyup(listener: KeyboardEventListener) {\n    document.addEventListener('keyup', listener)\n  }\n\n  public static removeKeydownAndKeyupListeners(listener: KeyboardEventListener): void {\n    document.removeEventListener('keyup', listener)\n    document.removeEventListener('keydown', listener)\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\n\ntype MouseEventHandler = (e: MouseEvent) => void\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(mouseDownListener: MouseEventHandler, mouseUpListener: MouseEventHandler) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(mouseDownListener, mouseUpListener)\n  }\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(mouseDownListener: MouseEventHandler, mouseUpListener: MouseEventHandler): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', mouseDownListener, false)\n    canvas.addEventListener('mouseup', mouseUpListener, false)\n  }\n\n  public static removeMouseLeftClickListeners(mouseDownListener: MouseEventHandler, mouseUpListener: MouseEventHandler) {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.removeEventListener('mousedown', mouseDownListener)\n    canvas.removeEventListener('mouseup', mouseUpListener)\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n"],"names":["URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","buffer","send","context","AudioContext","static","loadCallback","load","Mixer","musicVolume","this","_musicVolume","vol","soundFxVolume","_soundFxVolume","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","all","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","SMG_INDEX","gainNode","createGain","gain","value","connect","destination","start","length","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","constructor","x","y","collisionBox","speed","healthPercentage","prevX","prevY","maxHealth","state","Idling","previousState","animationSpritePosition","moving","left","right","up","down","blocked","deltas","dyTop","dyBottom","dxLeft","dxRight","maxSpeed","maxSpeedDiagonal","Math","sin","initializeHealth","updateMapPosition","resetMoving","resetBlocked","calculateNextCoordinates","nextX","nextY","move","round","elapsedTimeFactor","row","floor","CONFIG","TILE_SIZE","col","updateTileDeltas","checkIfBlockedByCreature","c","nextCreatureState","collisionBoxesIntersect","intersectionX","intersectionY","halfWidth","halfHeight","adjustCollisionWithWalls","wall","walls","mapX","width","SWVertexRow","NWVertexRow","SEVertexRow","NEVertexRow","mapY","height","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","updatePreviousCoordinates","push","shift","updateDirection","direction","dx","dy","Directions","S","N","E","W","directionString","join","checkIfMoving","xUnchanged","yUnchanged","health","getHealthColor","CreatureState","Level","currentLevel","startingLevel","LevelTimer","reset","lastLevel","totalNumberOfMaps","timeSpentOnCurrentLevel","frameElapsedTime","beginPath","fillStyle","font","levelTimeInSeconds","fillText","CANVAS_HEIGHT","stroke","ConcreteEnemy","super","sprite","Zerg","attackSpeed","animationLengthAttack","animationProgressAttack","animationLengthMove","animationProgressMove","update","player","enemies","Dying","Decaying","target","stuck","checkIfStuck","Attacking","setState","checkForCollisionWithPlayer","checkForCollisionWithOtherEnemies","distanceFromTarget","pointToPointDistance","targetIsInRange","targetInRange","resetAttackCooldown","attack","Moving","thereAreObstaclesBetweenPlayerAndThisEnemy","determineIfThereAreObstaclesBetweenTwoPathNodes","findPathToPlayer","shortestPath","stateManager","getState","PLAYING","advanceAnimation","draw","DEBUG","ENEMY_COLLISION_BOX","debug_drawCollisionBox","ENEMY_STATE","debug_drawState","RAY_TO_PLAYER","debug_drawRayToPlayer","PATHFINDING_NODES","debug_drawPathNodes","pathfindingNodes","SHORTEST_PATH_TO_PLAYER","debug_drawShortestPathToPlayer","takeDamage","damageAmount","playEnemyHit","die","playEnemyDeath","numberOfSpritesInAnimation","attacking","walking","pathfindingTimer","generatePathNodes","abs","findShortestPath","pathfindingInterval","followTheShortestPath","moveTowardsPlayer","nextNodeX","nextNodeY","pop","moveTowards","strokeStyle","lineWidth","moveTo","center","lineTo","toString","p","forEach","n","i","drawNode","visited","node","debug_drawRayFromPointToPoint","p1","p2","resetAnimation","newState","Enemy","isOnScreen","playerX","playerY","offScreenOffset","CANVAS_WIDTH","nextEnemyState","getEnemiesOnScreen","e","sumOfCollisionBoxHalfDiagonals","sqrt","xIsStatic","every","yIsStatic","attackCooldown","playSMG","dealDamage","GAME_SPEED","getDamage","Map","mapData","loadMap","filter","destroy","splice","openPortalWhenAllEnemiesAreKilled","exitPortal","isOpen","drawGameObjects","offsetLeft","colRemainder","offsetTop","rowRemainder","rowStart","halfRows","colStart","halfCols","rows","cols","map","loadGameObjects","loadEnemies","loadWalls","loadExitPortal","gameObjects","mapKey","isWall","createWall","ExitPortal","MapKeys","WallGray","WallGreen","WallBlue","Maps","Map01","Map02","Object","keys","levelNumber","zeroPaddedLevelNumber","String","padStart","color","destructable","Portal","getColor","rect","fill","openColor","closedColor","Wall","playWallHit","Error","canvasX","mousePosition","canvasY","offsetX","offsetY","Player","alive","rotation","sightLineLength","shooting","projectiles","keydownHandler","keyCode","KEYBOARD_KEYS","w","a","s","d","keyupHandler","checkForCollisionWithEnemies","shoot","theta","calculateTheta","drawPlayer","drawPlayerVisionRay","PLAYER_VISION_RAY_SHOTGUN","drawProjectiles","setShooting","isShooting","xVel","yVel","FEATURES","SCATTER_PROJECTILES","randomFactorX","random","randomFactorY","angleBetweenPoints","toFixed","cos","PLAYER_COLLISION_BOX","hitPoint","wallHit","cast","drawRay","nextPlayerState","enemiesOnScreen","some","directionX","directionY","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithWall","arc","PI","intermediateIntervalX","intermediateIntervalY","point","Sprites","callback","_reject","spriteSheet","Image","src","url","SpriteZerg","spriteLocations","flip","NE","SE","SW","NW","spriteSize","spriteStep","enemy","playerCoordinates","spriteOffsets","getSpriteOffsets","spriteLocation","drawSprite","enemyState","SPRITE_STEP","cBox","px","py","save","translate","scale","drawImage","restore","canvas","document","getElementById","style","SCALE","getContext","Canvas","clearRect","getCanvasDomElement","THROW_DEVELOPMENT_ERRORS","b","FPS_ARR","FPS","lastFrameTime","unshift","reduce","sum","current","GameAssets","GameTime","t","ONE_SECOND","previousTimestamp","startRow","startCol","path","rowEnd","colEnd","PathNode","nodeGoal","nodeStart","f","g","heuristic","nodesNotTested","nodeCurrent","sort","neighbourNodes","possiblyLowerLocalGoal","parent","coordinates","Infinity","Raycaster","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","angleBetweenTwoGivenPoints","results","n1","n2","angleBetweenNodes","vNE1","vNE2","getVerticesNE","determineIfThereAreObstaclesBetweenTwoPoints","vSE1","vSE2","getVerticesSE","vSW1","vSW2","getVerticesSW","vNW1","vNW2","getVerticesNW","yIntercept","tileStepX","hitPointVertical","wallHitVertical","rangeHorizontal","rangeVertical","RAYCASTER","checkWallCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","wallHitHorizontal","j","checkWallCollisionHorizontalSE","pow","checkWallCollisionVerticalNE","checkWallCollisionHorizontalNE","checkWallCollisionVerticalNW","checkWallCollisionHorizontalNW","checkWallCollisionVerticalSW","checkWallCollisionHorizontalSW","xTile","yTile","yTile_aboveByOnePixel","xTile_leftByOnePixel","outsideOfScreenOffset","blankVertex","vertexNW1","vertexNW2","vertexNE1","vertexNE2","vertexSW1","vertexSW2","vertexSE1","vertexSE2","Game","window","onfocus","restart","loadedPercentages","set","Graphics","weight","loaded","Audio","percentage","gameAssetLoaded","loadInterval","setInterval","clearInterval","MAIN_MENU","gameLoop","asset","assetValue","get","loadedPercentage","_key","timestamp","undefined","setFrameElapsedTime","render","calculateFrameRate","requestAnimationFrame","ts","clear","debug_drawFPS","handleEnterPress","ENTER","enter","addEventListener","exit","removeEventListener","drawGameOverScreen","isLastLevel","resetToStartingLevel","VICTORY","nextLevel","drawLevelClearedStatistics","drawLoadingDialog","animationProgress","animationLength","instructionsVisible","handleMenuSelection","drawMainMenu","currentState","LOADING","nextState","pauseHandler","ESC","preventDefault","destroyGame","drawPauseMenu","playerSetShootingTrue","playerSetShootingFalse","PAUSED","startNewGame","setupOwnEventListeners","onblur","clearOwnEventListeners","updateMousePosition","checkForLevelClearedCondition","incrementTimeSpentOnCurrentLevel","GAME_OVER","SHOW_LEVEL_TIME","debug_displayTimeSpentOnCurrentLevel","addListenerKeydown","addListenerKeyup","init","enemiesRemaining","checkIfPlayerIsInsideExitPortal","LEVEL_CLEARED","removeKeydownAndKeyupListeners","removeMouseLeftClickListeners","drawVictoryScreen","GAME_STATES","atan2","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","listener","Mouse","mouseDownListener","mouseUpListener","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","pageX","pageY","innerWidth","innerHeight","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}
{"version":3,"file":"app.js","mappings":"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","sources":["webpack://retro-2d-game-engine/./src/app/audio/AudioBufferLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioContext.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/Mixer.ts","webpack://retro-2d-game-engine/./src/app/audio/SoundFX.ts","webpack://retro-2d-game-engine/./src/app/domain/Creature.ts","webpack://retro-2d-game-engine/./src/app/domain/Grid.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/Enemy.ts","webpack://retro-2d-game-engine/./src/app/domain/map/Map.ts","webpack://retro-2d-game-engine/./src/app/domain/map/MapKeys.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/GameObject.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/GameObjectFactory.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/box/Box.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/box/BoxFactory.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Crosshair.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Player.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Projectile.ts","webpack://retro-2d-game-engine/./src/app/graphics/GraphicsLoader.ts","webpack://retro-2d-game-engine/./src/app/graphics/Sprites.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/CreatureSprite.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/SpriteZerg.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Canvas.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/CollisionBox.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Directions.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/FrameRate.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/GameAssets.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Pathfinding.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Raycaster.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/Game.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStates.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/geometry/Point.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Gamepads.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Keyboard.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Mouse.ts","webpack://retro-2d-game-engine/./src/app/peripherals/constants/KeyCodes.ts","webpack://retro-2d-game-engine/webpack/bootstrap","webpack://retro-2d-game-engine/./src/main.ts"],"sourcesContent":["import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/enemy_hit_1.mp3'),\n      load('./audio/enemy_hit_2.mp3'),\n      load('./audio/enemy_hit_3.mp3'),\n      load('./audio/enemy_hit_4.mp3'),\n      load('./audio/enemy_hit_5.mp3'),\n\n      load('./audio/enemy_die_1.mp3'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.SMG[0] = soundFxFiles[0]\n    this.SMG[1] = soundFxFiles[1]\n    this.SMG[2] = soundFxFiles[2]\n    this.SMG[3] = soundFxFiles[3]\n    this.SMG[4] = soundFxFiles[4]\n\n    this.CRATE_HIT[0] = soundFxFiles[5]\n\n    this.ENEMY_HIT[0] = soundFxFiles[6]\n    this.ENEMY_HIT[1] = soundFxFiles[7]\n    this.ENEMY_HIT[2] = soundFxFiles[8]\n    this.ENEMY_HIT[3] = soundFxFiles[9]\n    this.ENEMY_HIT[4] = soundFxFiles[10]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[11]\n    setLoadedPercentage(1.0)\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playCrateHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox, { collisionBoxesIntersect, ICollidable } from '@app/infrastructure/CollisionBox'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport { Directions } from '@app/infrastructure/Directions'\n\nexport default abstract class Creature {\n  public prevX: number[] = [] // TODO: Make private?\n  public prevY: number[] = [] // TODO: Make private?\n  public x: number\n  public y: number\n  public nextX: number\n  public nextY: number\n  public row: number\n  public col: number\n  public maxHealth = 100\n  public health: number\n\n  public maxSpeed: number\n  public maxSpeedDiagonal: number\n\n  public animationInterval: number = 0\n\n  public direction: Directions\n  public isMoving: boolean = false\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public blocked = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  protected resetMoving(): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n  }\n\n  protected resetBlocked(): void {\n    this.blocked.up    = false\n    this.blocked.down  = false\n    this.blocked.left  = false\n    this.blocked.right = false\n  }\n\n  protected calculateNextCoordinates(): void {\n    this.nextX = this.x\n    this.nextY = this.y\n\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX -= this.maxSpeedDiagonal\n      } else {\n        this.nextX -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.nextX += this.maxSpeedDiagonal\n      } else {\n        this.nextX += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY -= this.maxSpeedDiagonal\n      } else {\n        this.nextY -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.nextY += this.maxSpeedDiagonal\n      } else {\n        this.nextY += this.maxSpeed\n      }\n    }\n  }\n\n  protected checkIfBlockedByCreature(c: Creature, nextCreatureState: ICollidable) {\n    if (collisionBoxesIntersect(nextCreatureState, c)) {\n      let intersectionX: number\n      let intersectionY: number\n      if (nextCreatureState.x < c.x) {\n        intersectionX = (nextCreatureState.x + nextCreatureState.collisionBox.halfWidth) - (c.x - c.collisionBox.halfWidth)\n      } else if (nextCreatureState.x > c.x) {\n        intersectionX = (c.x + c.collisionBox.halfWidth) - (nextCreatureState.x - nextCreatureState.collisionBox.halfWidth)\n      }\n      if (nextCreatureState.y < c.y) {\n        intersectionY = (nextCreatureState.y + nextCreatureState.collisionBox.halfHeight) - (c.y - c.collisionBox.halfHeight)\n      } else if (nextCreatureState.y > c.y) {\n        intersectionY = (c.y + c.collisionBox.halfHeight) - (nextCreatureState.y - nextCreatureState.collisionBox.halfHeight)\n      }\n      if (!intersectionX || intersectionX >= intersectionY) {\n        if (nextCreatureState.y < c.y) {\n          this.blocked.down = true\n        } else {\n          this.blocked.up = true\n        }\n      } else if (!intersectionY || intersectionX < intersectionY) {\n        if (nextCreatureState.x < c.x) {\n          this.blocked.right = true\n        } else {\n          this.blocked.left = true\n        }\n      }\n    }\n  }\n\n  protected adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow && SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow && NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol && NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol && NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol && SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol && SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  protected updatePreviousCoordinates(): void {\n    this.prevX.push(this.x)\n    if (this.prevX.length > 5) { this.prevX.shift() }\n\n    this.prevY.push(this.y)\n    if (this.prevY.length > 5) { this.prevY.shift() }\n  }\n\n  protected updateDirection(): void {\n    const direction: string[] = []\n\n    const dx = this.prevX[this.prevX.length - 1] - this.prevX[this.prevX.length - 2]\n    const dy = this.prevY[this.prevY.length - 1] - this.prevY[this.prevY.length - 2]\n\n    if (dy > 0) {\n      direction.push(Directions.S)\n    }\n    else if (dy < 0) {\n      direction.push(Directions.N)\n    }\n\n    if (dx > 0) {\n      direction.push(Directions.E)\n    }\n    else if (dx < 0) {\n      direction.push(Directions.W)\n    }\n\n    const directionString = direction.join('') || this.direction || 'S'\n\n    this.direction = Directions[directionString as keyof typeof Directions]\n  }\n\n  protected checkIfMoving(): boolean {\n    const xUnchanged = this.prevX[this.prevX.length - 1] === this.prevX[this.prevX.length - 2]\n    const yUnchanged = this.prevY[this.prevY.length - 1] === this.prevY[this.prevY.length - 2]\n    if (xUnchanged && yUnchanged) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  protected initializeHealth(healthPercentage: number = 1.0): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n\n  // TODO: The color strings can be moved to a single hash map in order to optimize & localize the color searches\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.1) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.2) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.3) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.4) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.5) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.6) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.7) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.8) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.9) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\n// TODO: This class is useless?\nexport default class Grid {\n  public rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  public cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n\nexport interface NeighbourTiles {\n    N  : (any | null)\n    NE : (any | null)\n    E  : (any | null)\n    SE : (any | null)\n    S  : (any | null)\n    SW : (any | null)\n    W  : (any | null)\n    NW : (any | null)\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, findShortestPath, drawPathNodes, drawNode } from '@app/infrastructure/Pathfinding'\n\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport Sprites from '@app/graphics/Sprites'\n\nexport default class ConcreteEnemy extends Enemy {\n  protected sprite: CreatureSprite = Sprites.Zerg\n  protected target: Point\n\n  protected attackSpeed = 60\n\n  constructor(\n    x: number,\n    y: number,\n    healthPercentage: number,\n    protected pathfindingInterval: number\n  ) {\n    super(x, y, new CollisionBox(14, 14), 1, healthPercentage)\n    this.updateMapPosition()\n  }\n\n  public update(player: Player, enemies: Enemy[]): void {\n    if (!this.target) {\n      this.target = player\n    }\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n    this.updatePreviousCoordinates()\n\n    this.stuck    = this.checkIfStuck()\n    this.isMoving = this.checkIfMoving()\n\n    this.adjustCollisionWithGameObjects()\n    this.checkForCollisionWithPlayer(player)\n    this.checkForCollisionWithOtherEnemies(player)\n    this.distanceFromPlayer = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   }\n    )\n    if (this.checkIfShouldAttack(player)) {\n      this.attacking = true\n      this.attack(player)\n    } else {\n      this.attacking = false\n      this.resetAttackCooldown()\n    }\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy =\n      Raycaster.determineIfThereAreObstaclesBetweenTwoPathNodes(this, player)\n    this.findPathToPlayer(player)\n\n    this.move()\n    this.updateDirection()\n    this.updateTileDeltas()\n\n    if (Game.stateManager.getState() !== GAME_STATES.PAUSED) {\n      this.advanceAnimation()\n    }\n  }\n\n  public draw(player: Player): void {\n    if (CONFIG.DEBUG.ENEMY_COLLISION_BOX) {\n      this.drawCollisionBox(player)\n    }\n    if (CONFIG.DEBUG.RAY_TO_PLAYER) {\n      this.drawRayToPlayer(player)\n    }\n    if (CONFIG.DEBUG.PATHFINDING_NODES) {\n      drawPathNodes(this.pathfindingNodes, player, this.getHealthColor())\n    }\n\n    if (CONFIG.DEBUG.SHORTEST_PATH_TO_PLAYER) {\n      this.drawShortestPathToPlayer(player)\n    }\n    this.sprite.draw(this, { x: player.x, y: player.y })\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.alive = false\n  }\n\n  protected advanceAnimation(): void {\n    this.animationInterval = (this.animationInterval + 0.5) % this.sprite.animationPeriods.walking\n  }\n\n  private findPathToPlayer(player: Player): void {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) { // TODO: || this.isStuck()\n      if (this.pathfindingInterval === 0) {\n        this.pathfindingNodes = generatePathNodes(\n          Math.round(Math.abs(player.row + this.row) / 2),\n          Math.round(Math.abs(player.col + this.col) / 2),\n          this.collisionBox,\n        )\n        this.shortestPath = findShortestPath(this, player, this.pathfindingNodes)\n      }\n\n      this.pathfindingInterval = (this.pathfindingInterval + 1) % this.pathfindingPeriod\n\n      if (this.shortestPath.length > 0) {\n        this.followTheShortestPath()\n      }\n    }\n    else { // Target is in line of sight\n      if (this.pathfindingNodes) {\n        this.pathfindingNodes = null\n      }\n      if (this.shortestPath) {\n        this.shortestPath = []\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private followTheShortestPath(): void {\n    // If the enemy is close to the path node, pop that node and move to the next one\n    let nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n    let nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    if (\n      this.shortestPath.length > 1 &&\n      Math.abs(nextNodeX - this.x) < 3 &&\n      Math.abs(nextNodeY - this.y) < 3\n    ) {\n      this.shortestPath.pop()\n      nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n      nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    }\n    this.moveTowards(nextNodeX, nextNodeY)\n  }\n\n  private moveTowardsPlayer(player: Point): void {\n    if (this.distanceFromPlayer > this.collisionBox.width) {\n      this.moveTowards(player.x, player.y)\n    }\n    else {\n      this.resetMoving()\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.resetMoving()\n\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.2\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawShortestPathToPlayer(p: Player) {\n    this.shortestPath\n      .forEach((n, i) => {\n        drawNode(n, p, n.visited ? '#FF0000' : '#FF00FF')\n      })\n    if (this.shortestPath.length > 0) {\n      this.shortestPath.forEach((node, i) => {\n        this.drawRayFromPointToPoint(node, this.shortestPath[i - 1] || p, p)\n      })\n    }\n  }\n\n  // TODO: Just for debugging\n  private drawRayFromPointToPoint(p1: Point, p2: Point, player: Player) {\n    context.strokeStyle = '#FF00FF'\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (p2.x - player.x), Canvas.center.y + (p2.y - player.y))\n      context.lineTo(Canvas.center.x + (p1.x - player.x), Canvas.center.y + (p1.y - player.y))\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Creature from '@app/domain/Creature'\nimport Player from '@app/domain/player/Player'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport { PathNode } from '@app/infrastructure/Pathfinding'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport SoundFX from '@app/audio/SoundFX'\n\nimport { getEnemiesOnScreen } from '../map/Map'\n\nexport default abstract class Enemy extends Creature {\n  public alive: boolean = true\n\n  protected stuck: boolean\n\n  protected distanceFromPlayer: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathfindingInterval: number = 0\n  protected pathfindingPeriod: number = 30\n  protected pathfindingNodes: PathNode[]\n  protected shortestPath: PathNode[] = []\n\n  protected sprite: CreatureSprite\n\n  protected attacking = false\n  protected readonly attackSpeed: number // Frames\n  protected attackCooldown: number\n\n  constructor(\n    public x: number,\n    public y: number,\n    collisionBox: CollisionBox,\n    maxSpeed: number,\n    healthPercentage: number,\n  ) {\n    super()\n    this.initializeHealth(healthPercentage)\n\n    this.maxSpeed = maxSpeed\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed)\n\n    this.collisionBox = collisionBox\n\n    this.attackCooldown = this.attackSpeed // TODO: Extract to initializeAttackParameters() or somehting...\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player, enemies: Enemy[]): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    const offScreenOffset = CONFIG.TILE_SIZE * 2\n    return (\n      Math.abs(this.x - playerX) < CONFIG.CANVAS_WIDTH / 2 + offScreenOffset &&\n      Math.abs(this.y - playerY) < CONFIG.CANVAS_HEIGHT / 2 + offScreenOffset\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n  protected abstract advanceAnimation(): void\n\n  protected checkForCollisionWithPlayer(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    this.checkIfBlockedByCreature(player, nextEnemyState)\n  }\n\n  protected checkForCollisionWithOtherEnemies(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesInScreenRangeFromThis = getEnemiesOnScreen(this.x, this.y)\n\n    enemiesInScreenRangeFromThis.forEach((e) => {\n      if (this !== e) {\n        this.checkIfBlockedByCreature(e, nextEnemyState)\n      }\n    })\n  }\n\n  protected checkIfShouldAttack(p: Player) {\n    const diagonalOfCollisionBoxHalves = (p.collisionBox.halfWidth + this.collisionBox.halfWidth) * Math.sqrt(2)\n    return this.distanceFromPlayer < diagonalOfCollisionBoxHalves\n  }\n  \n  protected resetAttackCooldown() {\n    this.attackCooldown = this.attackSpeed\n  }\n\n  protected checkIfStuck(): boolean {\n    const xIsStatic = this.prevX.every((x) => x === this.prevX[0])\n    const yIsStatic = this.prevY.every((y) => y === this.prevY[0])\n    if (xIsStatic && yIsStatic) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  protected attack(p: Player): void {\n    if (this.attacking && this.attackCooldown <= 0) {\n      this.resetAttackCooldown()\n\n      SoundFX.playSMG() // TODO: Change the SFX\n      p.takeDamage(this.getDamage())\n    } else {\n      --this.attackCooldown\n    }\n  }\n\n  // TODO: Implement damage range\n  protected getDamage() {\n    return 10\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport ConcreteEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport IMap from './IMap'\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\nexport const enemies: Enemy[] = []\n\nexport function getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n  return enemies.filter(e => e.isOnScreen(playerX, playerY))\n}\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public update(): void {\n    enemies.forEach((e, i) => {\n      e.update(this.player, enemies)\n      if (e.alive === false) {\n        enemies.splice(i, 1) // Remove the enemy\n      }\n    })\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map.gameObjects[row][col])\n      }\n    }\n\n    map.enemies.forEach((e, i) => {\n      enemies.push(new ConcreteEnemy(e.x, e.y, e.healthPercentage, i))\n    })\n  }\n}\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playCrateHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox, {\n  collisionBoxesIntersect,\n} from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport Creature from '@app/domain/Creature'\nimport { getEnemiesOnScreen } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player extends Creature {\n  public alive: boolean = true\n  public rotation: number = 0\n  public sightLineLength = 10\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(public x: number, public y: number) {\n    super()\n    this.initializeHealth()\n\n    this.maxSpeed = 2\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed) // TODO: Extract function\n\n    this.collisionBox = new CollisionBox(12, 12)\n\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n\n    this.checkForCollisionWithEnemies()\n    this.move()\n    this.adjustCollisionWithGameObjects()\n    this.updateMapPosition()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    if (CONFIG.DEBUG.PLAYER_VISION_RAY_SHOTGUN) {\n      this.drawPlayerVisionRay(theta - 0.45)\n      this.drawPlayerVisionRay(theta - 0.4)\n      this.drawPlayerVisionRay(theta - 0.35)\n      this.drawPlayerVisionRay(theta - 0.3)\n      this.drawPlayerVisionRay(theta - 0.25)\n      this.drawPlayerVisionRay(theta - 0.2)\n      this.drawPlayerVisionRay(theta - 0.15)\n      this.drawPlayerVisionRay(theta - 0.1)\n      this.drawPlayerVisionRay(theta - 0.05)\n      this.drawPlayerVisionRay(theta + 0.05)\n      this.drawPlayerVisionRay(theta + 0.1)\n      this.drawPlayerVisionRay(theta + 0.15)\n      this.drawPlayerVisionRay(theta + 0.2)\n      this.drawPlayerVisionRay(theta + 0.25)\n      this.drawPlayerVisionRay(theta + 0.3)\n      this.drawPlayerVisionRay(theta + 0.35)\n      this.drawPlayerVisionRay(theta + 0.4)\n      this.drawPlayerVisionRay(theta + 0.45)\n    }\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = Canvas.mousePosition.x - Canvas.center.x\n      const dy = Canvas.mousePosition.y - Canvas.center.y\n      let xVel = dx / (Math.abs(dx) + Math.abs(dy))\n      let yVel = dy / (Math.abs(dx) + Math.abs(dy))\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      if (CONFIG.FEATURES.SCATTER_PROJECTILES) {\n        const randomFactorX = Math.random() * 0.1 - 0.05\n        const randomFactorY = Math.random() * 0.1 - 0.05\n        xVel += randomFactorX\n        yVel += randomFactorY\n      }\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public takeDamage(damageAmount: number): void {\n    this.health = this.health - damageAmount\n    if (this.health <= 0) {\n      // TODO: Implement lose condition\n    }\n  }\n\n  private move(): void {\n    if (this.moving.left && !this.blocked.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right && !this.blocked.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up && !this.blocked.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down && !this.blocked.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n    context.fillStyle = '#00AA00'\n    context.font = '10px Monospace'\n\n    context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n    context.strokeStyle = '#523DA5'\n    context.lineWidth = 2\n    context.moveTo(Canvas.center.x, Canvas.center.y)\n    context.lineTo(\n      Canvas.center.x + this.sightLineLength * Math.cos(theta),\n      Canvas.center.y + this.sightLineLength * Math.sin(theta),\n    )\n    context.stroke()\n\n    if (CONFIG.DEBUG.PLAYER_COLLISION_BOX) {\n      this.drawCollisionBox()\n    }\n  }\n\n  private drawCollisionBox() {\n    context.strokeStyle = this.getHealthColor()\n\n    context.lineWidth = 0.5\n    context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // cache the vertex calculations.\n    context.moveTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach((p) => p.draw(this.x, this.y))\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  private checkForCollisionWithEnemies(): void {\n    const nextPlayerState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesOnScreen = getEnemiesOnScreen(this.x, this.y)\n\n    if (\n      enemiesOnScreen.some((e) => collisionBoxesIntersect(e, nextPlayerState))\n    ) {\n      enemiesOnScreen.forEach((e) => {\n        this.checkIfBlockedByCreature(e, nextPlayerState)\n      })\n    }\n  }\n\n  private die(): void {\n    this.alive = false\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { gameObjects, enemies } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        o.takeDamage(this.getDamage())\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import Sprites from './Sprites'\n\nexport default class GraphicsLoader {\n  public static async load(setLoadedPercentage: (percentage: number) => void) {\n    Sprites.load(setLoadedPercentage)\n  }\n}","import CreatureSprite from './sprites/CreatureSprite'\nimport SpriteZerg from './sprites/SpriteZerg'\n\nexport default class Sprites {\n  public static Zerg: CreatureSprite = new SpriteZerg()\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    await Sprites.Zerg.load(() => setLoadedPercentage(1.0))\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default abstract class CreatureSprite {\n  public spriteSheet: HTMLImageElement\n\n  public abstract animationPeriods: { [animation: string]: number }\n\n  protected abstract url: string\n  public abstract draw(e: Enemy, playerCoordinates: Point): void\n\n  public load(callback: () => void): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      this.spriteSheet = new Image()\n      this.spriteSheet.src = this.url\n      this.spriteSheet.onload = () => {\n        callback()\n        resolve()\n      }\n    })\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nimport CreatureSprite from './CreatureSprite'\n\nexport default class SpriteZerg extends CreatureSprite {\n  public url: string = './graphics/spritesheets/zergling.png'\n\n  public animationPeriods = {\n    walking: 8,\n  }\n\n  public draw(enemy: Enemy, playerCoordinates: Point) {\n\n    const SPRITE_LOCATIONS: { [key: string]: { col: number, flip: boolean } } = {\n      N : { col: 0, flip: false },\n      NE: { col: 2, flip: false },\n      E : { col: 4, flip: false },\n      SE: { col: 6, flip: false },\n      S : { col: 8, flip: false },\n      SW: { col: 6, flip: true  },\n      W : { col: 4, flip: true  },\n      NW: { col: 2, flip: true  },\n    }\n\n    const spriteLocation = SPRITE_LOCATIONS[enemy.direction]\n\n    const SPRITE_SIZE = 32\n    const SPRITE_OFFSETS = {\n      INITIAL: { x: 7, y: 5 },\n      STEP: { x: SPRITE_SIZE + 11, y: SPRITE_SIZE + 10 }\n    }\n    const { x, y, collisionBox: cBox } = enemy\n    const { x: px, y: py } = playerCoordinates\n\n    if (enemy.isMoving === false) {\n      enemy.animationInterval = 0\n    }\n\n    if (spriteLocation.flip) {\n      context.save()\n      context.translate(\n        Canvas.center.x + (x - px - cBox.halfWidth),\n        Canvas.center.y + (y - py - cBox.halfHeight),\n      )\n      context.scale(-1, 1)\n    }\n\n    context.drawImage(\n      this.spriteSheet,\n      SPRITE_OFFSETS.INITIAL.x + SPRITE_OFFSETS.STEP.x * spriteLocation.col,\n      SPRITE_OFFSETS.INITIAL.y + SPRITE_OFFSETS.STEP.y * Math.floor(enemy.animationInterval / 2),\n      SPRITE_SIZE,\n      SPRITE_SIZE,\n      spriteLocation.flip ? 0 - SPRITE_SIZE / 2 : Canvas.center.x + (x - px - cBox.halfWidth),\n      spriteLocation.flip ? 0                   : Canvas.center.y + (y - py - cBox.halfHeight),\n      enemy.collisionBox.width + 2,\n      enemy.collisionBox.height + 2,\n    )\n    if (spriteLocation.flip) {\n      context.restore()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    // TODO: Just a development warning, remove this in production\n    if (CONFIG.THROW_DEVELOPMENT_ERRORS) {\n      if (width % 2 !== 0 || height % 2 !== 0) {\n        throw new Error('Always use even numbers for collision box dimensions!')\n      }\n    }\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n\nexport interface ICollidable {\n  x: number\n  y: number\n  collisionBox: CollisionBox\n}\n\nexport function collisionBoxesIntersect(a: ICollidable, b: ICollidable): boolean {\n  return (\n    a.x - a.collisionBox.halfWidth  < b.x + b.collisionBox.halfWidth  &&\n    a.x + a.collisionBox.halfWidth  > b.x - b.collisionBox.halfWidth  &&\n    a.y - a.collisionBox.halfHeight < b.y + b.collisionBox.halfHeight &&\n    a.y + a.collisionBox.halfHeight > b.y - b.collisionBox.halfHeight\n  )\n}","export enum Directions {\n  N  = 'N',\n  NE = 'NE',\n  E  = 'E',\n  SE = 'SE',\n  S  = 'S',\n  SW = 'SW',\n  W  = 'W',\n  NW = 'NW',\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nlet lastFrameTime: number\nlet frameElapsedTime: number\n\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\n\nexport default class FrameRate {\n\n  public static restart() {\n    lastFrameTime = null\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(): void {\n    if (!lastFrameTime) {\n      lastFrameTime = performance.now()\n      FPS = 0\n    } else {\n      const now = performance.now()\n      frameElapsedTime = (now - lastFrameTime)\n\n      FPS_ARR.unshift(1000 / frameElapsedTime)\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n\n      lastFrameTime = now\n    }\n  }\n\n  public static drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","\nenum GameAssets {\n  Graphics,\n  Audio,\n}\n\nexport default GameAssets","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox, { collisionBoxesIntersect } from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport RaycastablePoint from './geometry/RaycastablePoint'\n\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): PathNode[] {\n  const path: PathNode[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!gameObjects[row] || !gameObjects[row][col]) {\n        if (col > 0 && row > 0) {\n          path.push(new PathNode({\n            x: col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n            y: row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n          }, cBox))\n        }\n      }\n    }\n  }\n\n  return path\n}\n\nexport function drawPathNodes(path: PathNode[], player: Player, color: string): void {\n  if (path) {\n    path.forEach(node => drawNode(node, player, color))\n  }\n}\n\nexport function drawNode(node: PathNode, player: Player, color: string): void {\n  context.strokeStyle = color\n  context.lineWidth = 0.1\n  context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // optimize/cache the vertex calculations.\n    context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n  context.stroke()\n\n  context.beginPath()\n    context.arc(\n      Canvas.center.x + (node.x - player.x),\n      Canvas.center.y + (node.y - player.y),\n      1,\n      0,\n      (2 * Math.PI)\n    )\n  context.stroke()\n}\n\nexport function findShortestPath(enemy: Enemy, player: Player, pathfindingNodes: PathNode[]): PathNode[] {\n  const nodeGoal  = new PathNode(player, player.collisionBox)\n  const nodeStart = new PathNode(enemy,  enemy.collisionBox)\n\n  pathfindingNodes.push(nodeGoal)\n\n  nodeStart.f = 0\n  nodeStart.g = nodeStart.heuristic(nodeGoal)\n\n  const nodesNotTested: PathNode[] = [ nodeStart ]\n\n  let nodeCurrent: PathNode\n\n  while (nodesNotTested.length > 0 || nodeCurrent === nodeGoal) {\n    nodesNotTested.sort((a: PathNode, b: PathNode) => a.g - b.g)\n\n    while (nodesNotTested.length > 0 && nodesNotTested[0].visited === true) {\n      nodesNotTested.shift()\n    }\n\n    if (nodesNotTested.length <= 0) {\n      break\n    }\n\n    nodeCurrent = nodesNotTested.shift()\n    nodeCurrent.visited = true\n\n    // Get neighbour nodes.\n    nodeCurrent.neighbourNodes = [ ...pathfindingNodes ]\n      .filter(node => {\n        return (\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row    ) || // Center\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row - 1) || // N\n          (node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row    ) || // E\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row + 1) || // S\n          (node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row    ) || // W\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row - 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col + 1] === null ||\n              !gameObjects[node.row + 1] || gameObjects[node.row + 1][node.col    ] === null\n            )\n          ) || // NW\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row - 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col - 1] === null ||\n              !gameObjects[node.row + 1] || gameObjects[node.row + 1][node.col    ] === null\n            )\n          ) || // NE\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row + 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col - 1] === null ||\n              !gameObjects[node.row - 1] || gameObjects[node.row - 1][node.col    ] === null\n            )\n          ) || // SE\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row + 1\n            && (\n              !gameObjects[node.row    ] || gameObjects[node.row    ][node.col + 1] === null ||\n              !gameObjects[node.row - 1] || gameObjects[node.row - 1][node.col    ] === null\n            )\n          ) // SW\n        )\n      })\n\n    nodeCurrent.neighbourNodes\n      .map(node => {\n        if (node.visited === false) {\n          nodesNotTested.push(node)\n        }\n\n        // Calculate local goal\n        const possiblyLowerLocalGoal = nodeCurrent.f + pointToPointDistance(nodeCurrent, node)\n\n        if (possiblyLowerLocalGoal < node.f) {\n          node.parent = nodeCurrent\n          node.f = possiblyLowerLocalGoal\n          node.g = node.f + node.heuristic(nodeGoal)\n        }\n\n        return node\n      })\n  }\n\n  const path = []\n  if (nodeGoal.parent) {\n    let n: PathNode = nodeGoal\n    while (n.parent) {\n      path.push(n)\n      n = n.parent\n    }\n  }\n  return path\n}\n\nexport class PathNode implements RaycastablePoint {\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  public visited: boolean = false\n  public g: number = Infinity // Global goal\n  public f: number = Infinity // Local goal\n  public parent: PathNode = null\n  public neighbourNodes: PathNode[]\n\n  constructor(coordinates: Point, cBox: CollisionBox) {\n    this.x = coordinates.x\n    this.y = coordinates.y\n    this.collisionBox = new CollisionBox(cBox.width, cBox.height)\n    this.updateTileDeltas()\n    this.updateMapPosition()\n  }\n\n  public heuristic(nodeGoal: PathNode): number {\n    return pointToPointDistance(this, nodeGoal)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { angleBetweenPoints, updatePointRowAndColValues, updatePointDeltas } from '@app/infrastructure/geometry/Point'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport RaycastablePoint from './geometry/RaycastablePoint'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { PathNode } from './Pathfinding'\nimport Player from '@app/domain/player/Player'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(\n    p: RaycastablePoint,\n    theta: number,\n    pEnd?: RaycastablePoint\n  ): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta, pEnd)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta, pEnd)\n      }\n    } else { // North\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta, pEnd)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta, pEnd)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  public static determineIfThereAreObstaclesBetweenTwoPoints(p1: RaycastablePoint, p2: RaycastablePoint): boolean {\n    const angleBetweenTwoGivenPoints = angleBetweenPoints(p2, p1)\n    const results = Raycaster.cast(p1, angleBetweenTwoGivenPoints, p2)\n\n    // I have to check if results exist because sometimes .cast() can return 'undefined'..\n    // Why .cast() sometimes returns 'undefined' could be worth investigating in the future..\n    if (results) {\n      return results.hitObject !== null\n    }\n    else {\n      return true\n    }\n  }\n\n  // This function is very computationaly expensive, see if it can be optimized\n  public static determineIfThereAreObstaclesBetweenTwoPathNodes(n1: PathNode | Enemy, n2: PathNode | Player) {\n    const angleBetweenNodes: number = +angleBetweenPoints(n2, n1).toFixed(2)\n\n    if (angleBetweenNodes === 0) { // 0deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > 0 && angleBetweenNodes < Math.PI / 2) { // between 0deg and 90deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === (Math.PI / 2)) { // 90deg\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > Math.PI / 2 && angleBetweenNodes < Math.PI) { // between 90deg and 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (Math.abs(angleBetweenNodes) === 3.14) { // 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI && angleBetweenNodes < -Math.PI / 2) { // between 180deg and 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === -1.57) { // 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Math.PI / 2 && angleBetweenNodes < 0) { // between 270deg and 360deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n  }\n\n  private static outsideOfScreenOffset = CONFIG.TILE_SIZE * 2\n  private static rangeHorizontal: number = Canvas.halfWidth  + Raycaster.outsideOfScreenOffset\n  private static rangeVertical: number   = Canvas.halfHeight + Raycaster.outsideOfScreenOffset * 2\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyBottom > (pEnd.y - p.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y - tileStepY - p.deltas.dyTop,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (p.x - pEnd.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - xIntercept,\n            y: Canvas.center.y - p.deltas.dyTop - tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (-xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if ((tileStepY + p.deltas.dyBottom > (pEnd.y - p.y)) || (-xIntercept > (p.x - pEnd.x))) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const xTile_leftByOnePixel = p.col + Math.floor((p.deltas.dxLeft + xIntercept - 1) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile][xTile_leftByOnePixel]) {\n        gameObjectHit = gameObjects[yTile][xTile_leftByOnePixel]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n\nconst blankVertex: Point = {\n  x: 0,\n  y: 0,\n  deltas: {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  },\n}\nconst vertexNW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\n\nfunction getVerticesNW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexNW1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNW1.row = Math.floor(vertexNW1.y / CONFIG.TILE_SIZE)\n  vertexNW1.col = Math.floor(vertexNW1.x / CONFIG.TILE_SIZE)\n  vertexNW1.deltas.dyTop = vertexNW1.y % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW1.deltas.dyTop\n  vertexNW1.deltas.dxLeft = vertexNW1.x % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW1.deltas.dxLeft\n\n  vertexNW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexNW2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNW2.row = Math.floor(vertexNW2.y / CONFIG.TILE_SIZE)\n  vertexNW2.col = Math.floor(vertexNW2.x / CONFIG.TILE_SIZE)\n  vertexNW2.deltas.dyTop = vertexNW2.y % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW2.deltas.dyTop\n  vertexNW2.deltas.dxLeft = vertexNW2.x % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW2.deltas.dxLeft\n\n  return [ vertexNW1, vertexNW2 ]\n}\n\nfunction getVerticesNE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexNE1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNE1.row = Math.floor(vertexNE1.y / CONFIG.TILE_SIZE)\n  vertexNE1.col = Math.floor(vertexNE1.x / CONFIG.TILE_SIZE)\n  vertexNE1.deltas.dyTop = vertexNE1.y % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE1.deltas.dyTop\n  vertexNE1.deltas.dxLeft = vertexNE1.x % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE1.deltas.dxLeft\n\n  vertexNE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexNE2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNE2.row = Math.floor(vertexNE2.y / CONFIG.TILE_SIZE)\n  vertexNE2.col = Math.floor(vertexNE2.x / CONFIG.TILE_SIZE)\n  vertexNE2.deltas.dyTop = vertexNE2.y % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE2.deltas.dyTop\n  vertexNE2.deltas.dxLeft = vertexNE2.x % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE2.deltas.dxLeft\n\n  return [ vertexNE1, vertexNE2 ]\n}\n\nfunction getVerticesSW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexSW1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSW1.row = Math.floor(vertexSW1.y / CONFIG.TILE_SIZE)\n  vertexSW1.col = Math.floor(vertexSW1.x / CONFIG.TILE_SIZE)\n  vertexSW1.deltas.dyTop = vertexSW1.y % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW1.deltas.dyTop\n  vertexSW1.deltas.dxLeft = vertexSW1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW1.deltas.dxLeft\n\n  vertexSW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexSW2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSW2.row = Math.floor(vertexSW2.y / CONFIG.TILE_SIZE)\n  vertexSW2.col = Math.floor(vertexSW2.x / CONFIG.TILE_SIZE)\n  vertexSW2.deltas.dyTop = vertexSW2.y % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW2.deltas.dyTop\n  vertexSW2.deltas.dxLeft = vertexSW2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW2.deltas.dxLeft\n\n  return [ vertexSW1, vertexSW2 ]\n}\n\nfunction getVerticesSE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexSE1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSE1.row = Math.floor(vertexSE1.y / CONFIG.TILE_SIZE)\n  vertexSE1.col = Math.floor(vertexSE1.x / CONFIG.TILE_SIZE)\n  vertexSE1.deltas.dyTop = vertexSE1.y % CONFIG.TILE_SIZE\n  vertexSE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE1.deltas.dyTop\n  vertexSE1.deltas.dxLeft = vertexSE1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE1.deltas.dxLeft\n\n  vertexSE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexSE2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSE2.row = Math.floor(vertexSE2.y / CONFIG.TILE_SIZE)\n  vertexSE2.col = Math.floor(vertexSE2.x / CONFIG.TILE_SIZE)\n  vertexSE2.deltas.dyTop = vertexSE2.y % CONFIG.TILE_SIZE\n  vertexSE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE2.deltas.dyTop\n  vertexSE2.deltas.dxLeft = vertexSE2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE2.deltas.dxLeft\n\n  return [ vertexSE1, vertexSE2 ]\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport AudioLoader from '@app/audio/AudioLoader'\nimport GraphicsLoader from '@app/graphics/GraphicsLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport FrameRate from '../FrameRate'\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0\n  public static loadedPercentages: Map<GameAssets, { loaded: number, weight: number }> = new Map()\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  public static togglePause(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PAUSED) {\n      Game.stateManager.setState(GAME_STATES.PLAYING)\n    } else {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n  }\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n\n    Game.loadedPercentages.set(GameAssets.Graphics, { weight: 0.3, loaded: 0.0 })\n    Game.loadedPercentages.set(GameAssets.Audio,    { weight: 0.7, loaded: 0.0 })\n\n    AudioLoader.load(   percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n    GraphicsLoader.load(percentage => this.gameAssetLoaded(GameAssets.Graphics, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop()\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const assetValue = Game.loadedPercentages.get(asset)\n    assetValue.loaded = percentage\n    Game.loadedPercentages.set(asset, assetValue)\n\n    Game.loadedPercentage = 0\n    for (const [_key, value] of Game.loadedPercentages) {\n      Game.loadedPercentage += value.loaded * value.weight\n    }\n\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(): void {\n    this.update()\n    this.render()\n\n    FrameRate.calculateFrameRate()\n\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    if (CONFIG.DEBUG.FPS) {\n      FrameRate.drawFPS()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationCounter: number = 0\n  private animationInterval: number = 100\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationCounter = (this.animationCounter + 1) % this.animationInterval\n    if (this.animationCounter >= this.animationInterval / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press any key to start', CONFIG.CANVAS_WIDTH / 2 - 132, CONFIG.CANVAS_HEIGHT / 2 - 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection(): void {\n    Game.stateManager.setState(GAME_STATES.PLAYING)\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePlaying implements IGameState {\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n  }\n\n  public exit(nextState: IGameState): void {\n    if (nextState !== GAME_STATES.PAUSED) {\n      window.onblur = null\n    }\n  }\n\n  public update(): void {\n    Canvas.updateMousePosition()\n    Gamepads.update(this.player)\n    this.player.update()\n    this.map.update()\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n  }\n\n  private startNewGame(): void {\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n}\n","import GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStatePaused from './GameStatePaused'\n\n// TODO: Add a IGameState type definition\nconst GAME_STATES = {\n  LOADING   : new GameStateLoading(),\n  MAIN_MENU : new GameStateMainMenu(),\n  PLAYING   : new GameStatePlaying(),\n  PAUSED    : new GameStatePaused(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nexport default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}\n\nexport function updatePointRowAndColValues(p: Point): void {\n  p.row = Math.floor(p.y / CONFIG.TILE_SIZE)\n  p.col = Math.floor(p.x / CONFIG.TILE_SIZE)\n}\n\nexport function updatePointDeltas(p: Point): void {\n  p.deltas.dyTop = p.y % CONFIG.TILE_SIZE\n  p.deltas.dyBottom = CONFIG.TILE_SIZE - p.deltas.dyTop\n  p.deltas.dxLeft = p.x % CONFIG.TILE_SIZE\n  p.deltas.dxRight = CONFIG.TILE_SIZE - p.deltas.dxLeft\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","import Game from '@app/infrastructure/game/Game'\nimport FrameRate from '@app/infrastructure/FrameRate'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    document.addEventListener('keydown', e => {\n      // TODO: Move Player logic to Player class\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.ESC:\n        case KEYBOARD_KEYS.p:\n          Game.togglePause()\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n"],"names":["URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","buffer","send","context","AudioContext","static","loadCallback","load","Mixer","musicVolume","this","_musicVolume","vol","soundFxVolume","_soundFxVolume","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","all","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","SMG_INDEX","gainNode","createGain","gain","value","connect","destination","start","length","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","prevX","prevY","maxHealth","animationInterval","isMoving","moving","left","right","up","down","blocked","deltas","dyTop","dyBottom","dxLeft","dxRight","resetMoving","resetBlocked","calculateNextCoordinates","nextX","x","nextY","y","maxSpeedDiagonal","maxSpeed","checkIfBlockedByCreature","c","nextCreatureState","collisionBoxesIntersect","intersectionX","intersectionY","collisionBox","halfWidth","halfHeight","adjustCollisionWithGameObjects","o","gameObjects","row","col","mapX","width","SWVertexRow","Math","floor","CONFIG","TILE_SIZE","NWVertexRow","SEVertexRow","NEVertexRow","mapY","height","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","updatePreviousCoordinates","push","shift","updateDirection","direction","dx","dy","Directions","S","N","E","W","directionString","join","checkIfMoving","xUnchanged","yUnchanged","initializeHealth","healthPercentage","health","getHealthColor","rows","CANVAS_HEIGHT","cols","CANVAS_WIDTH","ConcreteEnemy","constructor","pathfindingInterval","super","sprite","Zerg","attackSpeed","updateMapPosition","update","player","enemies","target","stuck","checkIfStuck","checkForCollisionWithPlayer","checkForCollisionWithOtherEnemies","distanceFromPlayer","pointToPointDistance","checkIfShouldAttack","attacking","attack","resetAttackCooldown","thereAreObstaclesBetweenPlayerAndThisEnemy","determineIfThereAreObstaclesBetweenTwoPathNodes","findPathToPlayer","move","updateTileDeltas","stateManager","getState","PAUSED","advanceAnimation","draw","DEBUG","ENEMY_COLLISION_BOX","drawCollisionBox","RAY_TO_PLAYER","drawRayToPlayer","PATHFINDING_NODES","drawPathNodes","pathfindingNodes","SHORTEST_PATH_TO_PLAYER","drawShortestPathToPlayer","takeDamage","damageAmount","playEnemyHit","die","playEnemyDeath","alive","animationPeriods","walking","generatePathNodes","round","abs","shortestPath","findShortestPath","pathfindingPeriod","followTheShortestPath","moveTowardsPlayer","nextNodeX","nextNodeY","pop","moveTowards","strokeStyle","lineWidth","beginPath","moveTo","center","lineTo","stroke","p","forEach","n","i","drawNode","visited","node","drawRayFromPointToPoint","p1","p2","Enemy","sin","attackCooldown","isOnScreen","playerX","playerY","offScreenOffset","nextEnemyState","getEnemiesOnScreen","e","diagonalOfCollisionBoxHalves","sqrt","xIsStatic","every","yIsStatic","playSMG","getDamage","filter","grid","loadMap","Map01","splice","drawGameObjects","offsetLeft","colRemainder","offsetTop","rowRemainder","rowStart","halfRows","colStart","halfCols","gameObject","map","createGameObject","MapKeys","mapKey","startsWith","color","destructable","isBox","createBox","Box","playCrateHit","BoxGray","BoxGreen","BoxBlue","Error","canvasX","mousePosition","canvasY","offsetX","offsetY","Player","rotation","sightLineLength","shooting","shootingCooldown","projectiles","checkForCollisionWithEnemies","shoot","theta","calculateTheta","drawPlayer","drawPlayerVisionRay","PLAYER_VISION_RAY_SHOTGUN","drawProjectiles","xVel","yVel","FEATURES","SCATTER_PROJECTILES","randomFactorX","random","randomFactorY","setShooting","isShooting","angleBetweenPoints","fillStyle","fillText","toFixed","font","cos","PLAYER_COLLISION_BOX","hitPoint","hitObject","cast","drawRay","nextPlayerState","enemiesOnScreen","some","directionX","directionY","speed","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithGameObject","arc","PI","intermediateIntervalX","intermediateIntervalY","point","Sprites","callback","_reject","spriteSheet","Image","src","url","SpriteZerg","enemy","playerCoordinates","spriteLocation","flip","NE","SE","SW","NW","SPRITE_OFFSETS","SPRITE_SIZE","cBox","px","py","save","translate","scale","drawImage","restore","canvas","document","getElementById","style","SCALE","getContext","Canvas","clearRect","getCanvasDomElement","THROW_DEVELOPMENT_ERRORS","a","b","lastFrameTime","frameElapsedTime","FPS_ARR","FPS","now","performance","unshift","reduce","sum","current","GameAssets","startRow","startCol","path","rowEnd","colEnd","PathNode","nodeGoal","nodeStart","f","g","heuristic","nodesNotTested","nodeCurrent","sort","neighbourNodes","possiblyLowerLocalGoal","parent","coordinates","Infinity","Raycaster","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","angleBetweenTwoGivenPoints","results","n1","n2","angleBetweenNodes","vNE1","vNE2","getVerticesNE","determineIfThereAreObstaclesBetweenTwoPoints","vSE1","vSE2","getVerticesSE","vSW1","vSW2","getVerticesSW","vNW1","vNW2","getVerticesNW","yIntercept","tileStepX","hitPointVertical","objectHitVertical","rangeHorizontal","rangeVertical","RAYCASTER","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","checkGameObjectCollisionHorizontalSE","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","yTile_aboveByOnePixel","gameObjectHit","xTile_leftByOnePixel","outsideOfScreenOffset","blankVertex","vertexNW1","vertexNW2","vertexNE1","vertexNE2","vertexSW1","vertexSW2","vertexSE1","vertexSE2","Game","window","onfocus","restart","loadedPercentages","set","Graphics","weight","loaded","Audio","percentage","gameAssetLoaded","setState","PLAYING","loadInterval","setInterval","clearInterval","MAIN_MENU","gameLoop","asset","assetValue","get","loadedPercentage","_key","render","calculateFrameRate","requestAnimationFrame","clear","drawFPS","Map","enter","exit","drawLoadingDialog","animationCounter","instructionsVisible","addEventListener","handleMenuSelection","removeEventListener","drawMainMenu","currentState","LOADING","nextState","previousState","drawPauseMenu","startNewGame","onblur","updateMousePosition","init","GAME_STATES","atan2","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","keyCode","KEYBOARD_KEYS","w","s","d","ESC","togglePause","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","preventDefault","pageX","pageY","innerWidth","innerHeight","ENTER","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__"],"sourceRoot":""}
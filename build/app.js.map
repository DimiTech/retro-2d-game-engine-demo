{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/infrastructure/Canvas.ts","webpack:///./src/app/domain/map/Map.ts","webpack:///./src/app/peripherals/Mouse.ts","webpack:///./src/app/infrastructure/Game.ts","webpack:///./src/app/audio/SoundFX.ts","webpack:///./src/app/audio/AudioContext.ts","webpack:///./src/app/domain/map/MapKeys.ts","webpack:///./src/main.ts","webpack:///./src/app/audio/AudioLoader.ts","webpack:///./src/app/audio/Mixer.ts","webpack:///./src/app/audio/AudioBufferLoader.ts","webpack:///./src/app/domain/Grid.ts","webpack:///./src/app/domain/objects/GameObjectFactory.ts","webpack:///./src/app/domain/objects/box/BoxFactory.ts","webpack:///./src/app/domain/objects/box/Box.ts","webpack:///./src/app/domain/objects/GameObject.ts","webpack:///./src/app/domain/player/Player.ts","webpack:///./src/app/infrastructure/Raycaster.ts","webpack:///./src/app/domain/player/Crosshair.ts","webpack:///./src/app/domain/player/Projectile.ts","webpack:///./src/app/peripherals/Keyboard.ts","webpack:///./src/app/peripherals/constants/KeyCodes.ts","webpack:///./src/app/peripherals/Gamepads.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","Mouse_1","canvas","document","getElementById","width","CANVAS_WIDTH","height","CANVAS_HEIGHT","style","SCALE","context","getContext","Canvas","[object Object]","clearRect","this","mousePosition","x","Math","floor","default","offsetLeft","y","offsetTop","rows","TILE_SIZE","cols","halfRows","halfCols","rowRemainder","colRemainder","center","getCanvasDomElement","Canvas_1","GameObjectFactory_1","Map01","gameObjects","grid","player","loadMap","deltas","dxLeft","dyTop","rowStart","row","colStart","col","gameObject","draw","map","length","createGameObject","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","window","addEventListener","e","preventDefault","pageX","pageY","setShooting","innerWidth","innerHeight","AudioLoader_1","Grid_1","Map_1","Player_1","Keyboard_1","Gamepads_1","Game","load","init","requestAnimationFrame","gameLoop","paused","update","render","clear","Mixer_1","AudioContext_1","AudioBufferLoader_1","SoundFX","SMG","playSound","createBufferSource","buffer","SMG_INDEX","gainNode","createGain","gain","soundFxVolume","connect","destination","start","AudioContext","MapKeys","isBox","mapKey","startsWith","SoundFX_1","Mixer","musicVolume","_musicVolume","vol","_soundFxVolume","URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send","MapKeys_1","BoxFactory_1","createBox","Box_1","BoxGray","BoxGreen","BoxBlue","Error","GameObject_1","strokeStyle","color","lineWidth","beginPath","moveTo","lineTo","stroke","destructable","mapX","mapY","Raycaster_1","Crosshair_1","Projectile_1","rotation","moving","left","right","up","down","sightLineLength","dyBottom","dxRight","maxSpeed","shooting","shootingCooldown","projectiles","updateMapPosition","move","updateTileDeltas","shoot","forEach","alive","splice","adjustCollisionWithGameObjects","dx","dy","xVel","abs","yVel","randomFactorX","random","randomFactorY","push","playSMG","isShooting","theta","calculateTheta","drawPlayer","drawPlayerVisionRay","drawProjectiles","atan2","fillStyle","fillText","font","cos","sin","arc","PI","hitPoint","hitObject","cast","drawRay","Raycaster","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","yIntercept","tileStepX","hitPointVertical","objectHitVertical","RAYCASTER","DEBUG","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","checkGameObjectCollisionHorizontalSE","sqrt","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","gameObjectHit","canvasX","canvasY","offsetX","offsetY","directionX","directionY","speed","numberOfIntermediatePositions","intermediatePositions","playerX","playerY","previousX","previousY","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithGameObject","intermediateIntervalX","intermediateIntervalY","point","Game_1","KeyCodes_1","keyCode","KEYBOARD_KEYS","w","a","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","toFixed","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static update() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public draw(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: number[][]): void {\n    for (let row = 0; row < map.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map[row][col])\n      }\n    }\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","import AudioLoader from '@app/audio/AudioLoader'\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Canvas from '@app/infrastructure/Canvas'\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nexport default class Game {\n  public static paused: boolean = false\n\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  constructor() {\n    AudioLoader.load()\n\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n\n  public start(): void {\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private gameLoop(): void {\n    if (Game.paused === false) {\n      this.update()\n      this.render()\n    }\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private update(): void {\n    Gamepads.update(this.player)\n    Canvas.update()\n    this.player.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    this.map.draw()\n    this.player.draw()\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  public static async load(): Promise<void> {\n    this.SMG[0] = await load('./audio/smg_1.wav')\n    this.SMG[1] = await load('./audio/smg_2.wav')\n    this.SMG[2] = await load('./audio/smg_3.wav')\n    this.SMG[3] = await load('./audio/smg_4.wav')\n    this.SMG[4] = await load('./audio/smg_5.wav')\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import Game from '@app/infrastructure/Game'\n\nconst game: Game = new Game()\ngame.start()\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load() {\n    await SoundFX.load()\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class Grid {\n  rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player {\n  public rotation: number = 0\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public row: number\n  public col: number\n  public sightLineLength = 10\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  private maxSpeed = 4\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n  )\n  {\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.move()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public move(): void {\n    if (this.moving.left) {\n      this.x -= this.maxSpeed\n    }\n    if (this.moving.right) {\n      this.x += this.maxSpeed\n    }\n    if (this.moving.up) {\n      this.y -= this.maxSpeed\n    }\n    if (this.moving.down) {\n      this.y += this.maxSpeed\n    }\n    this.adjustCollisionWithGameObjects()\n    this.updateMapPosition()\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = (Canvas.mousePosition.x - Canvas.center.x)\n      const dy = (Canvas.mousePosition.y - Canvas.center.y)\n      let xVel = dx / ( Math.abs(dx) + Math.abs(dy) )\n      let yVel = dy / ( Math.abs(dx) + Math.abs(dy) )\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    // this.drawPlayerVisionRay(theta - 0.45)\n    // this.drawPlayerVisionRay(theta - 0.4)\n    // this.drawPlayerVisionRay(theta - 0.35)\n    // this.drawPlayerVisionRay(theta - 0.3)\n    // this.drawPlayerVisionRay(theta - 0.25)\n    // this.drawPlayerVisionRay(theta - 0.2)\n    // this.drawPlayerVisionRay(theta - 0.15)\n    // this.drawPlayerVisionRay(theta - 0.1)\n    // this.drawPlayerVisionRay(theta - 0.05)\n    // this.drawPlayerVisionRay(theta + 0.05)\n    // this.drawPlayerVisionRay(theta + 0.1)\n    // this.drawPlayerVisionRay(theta + 0.15)\n    // this.drawPlayerVisionRay(theta + 0.2)\n    // this.drawPlayerVisionRay(theta + 0.25)\n    // this.drawPlayerVisionRay(theta + 0.3)\n    // this.drawPlayerVisionRay(theta + 0.35)\n    // this.drawPlayerVisionRay(theta + 0.4)\n    // this.drawPlayerVisionRay(theta + 0.45)\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  private calculateTheta(): number {\n    const theta = Math.atan2(\n      (Canvas.mousePosition.y - Canvas.center.y),\n      (Canvas.mousePosition.x - Canvas.center.x)\n    )\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n      context.fillStyle = '#00AA00'\n      context.font = \"10px Monospace\"\n\n      context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n      context.strokeStyle = '#523DA5'\n      context.lineWidth = 2\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(Canvas.center.x + (this.sightLineLength * Math.cos(theta)), Canvas.center.y + (this.sightLineLength * Math.sin(theta)))\n    context.stroke()\n\n    // Draw circle around player\n    context.beginPath()\n      context.lineWidth = 1\n      context.arc(\n        Canvas.center.x,\n        Canvas.center.y,\n        10,\n        0,\n        (2 * Math.PI)\n      )\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach(p => p.draw(this.x, this.y))\n  }\n\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Generalize collision physics\n  private adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (o = gameObjects[this.row][this.col - 1]) { // West\n        if (this.x <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + 1\n        }\n      }\n      if (o = gameObjects[this.row][this.col + 1]) { // East\n        if (this.x >= o.mapX) {\n          this.x = o.mapX - 1\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (o = gameObjects[this.row - 1][this.col]) { // North\n        if (this.y <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + 1\n        }\n      }\n      if (o = gameObjects[this.row - 1][this.col + 1]) { // North East\n        if (this.y <= o.mapY + o.height && this.x >= o.mapX) {\n          this.y = o.mapY + o.height + 1\n        }\n      }\n      if (o = gameObjects[this.row - 1][this.col - 1]) { // North West\n        if (this.y <= o.mapY + o.height && this.x <= o.mapX + o.width) {\n          this.y = o.mapY + o.height + 1\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (o = gameObjects[this.row + 1][this.col]) { // South\n        if (this.y >= o.mapY) {\n          this.y = o.mapY - 1\n        }\n      }\n      if (o = gameObjects[this.row + 1][this.col + 1]) { // South East\n        if (this.x >= o.mapX && this.y >= o.mapY) {\n          this.y = o.mapY - 1\n        }\n      }\n      if (o = gameObjects[this.row + 1][this.col - 1]) { // South West\n        if (this.x <= o.mapX + o.width && this.y >= o.mapY) {\n          this.y = o.mapY - 1\n        }\n      }\n    }\n  }\n\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Player from '@app/domain/player/Player'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Raycaster {\n  /**\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   // TODO: Make the hit point the edge of the screen in worst case so the player can't see what's beyond (+ some offset maybe if you want the player to see beyond)\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const yInt = p.deltas.dyBottom\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta)\n      }\n    } else { // North\n      const yInt = p.deltas.dyTop\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(\n        Canvas.center.x + hitPoint.x,\n        Canvas.center.y + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + p.deltas.dxRight + tileStepX,\n          Canvas.center.y + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + tileStepX + p.deltas.dxRight,\n          Canvas.center.y - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static getInterceptPointNW(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - tileStepX - p.deltas.dxLeft,\n          Canvas.center.y - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.center.y) || (xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - xIntercept,\n          Canvas.center.y - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Player, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.center.x) || (yIntercept > Canvas.center.y)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.center.x - p.deltas.dxLeft - tileStepX,\n          Canvas.center.y + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.center.y) || (-xIntercept > Canvas.center.x)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.center.x + xIntercept,\n          Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Player, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Player, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport { gameObjects } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x || this.x > playerX + Canvas.center.x ||\n      this.y < playerY - Canvas.center.y || this.y > playerY + Canvas.center.y\n    )\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n}\n","import Game from '@app/infrastructure/Game'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    // TODO: Move Player logic to Player class\n    document.addEventListener('keydown', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.p: // Pause, only for debugging\n          Game.paused = !Game.paused\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","export const KEYBOARD_KEYS = {\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n"],"sourceRoot":""}
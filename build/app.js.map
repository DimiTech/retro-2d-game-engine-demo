{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/infrastructure/Canvas.ts","webpack:///./src/app/infrastructure/game/Game.ts","webpack:///./src/app/infrastructure/game/game_states/GameStates.ts","webpack:///./src/app/domain/map/Map.ts","webpack:///./src/app/audio/SoundFX.ts","webpack:///./src/app/peripherals/Mouse.ts","webpack:///./src/app/audio/AudioContext.ts","webpack:///./src/app/infrastructure/geometry/Point.ts","webpack:///./src/app/infrastructure/CollisionBox.ts","webpack:///./src/app/infrastructure/Raycaster.ts","webpack:///./src/app/domain/map/MapKeys.ts","webpack:///./src/main.ts","webpack:///./src/app/audio/AudioLoader.ts","webpack:///./src/app/audio/Mixer.ts","webpack:///./src/app/audio/AudioBufferLoader.ts","webpack:///./src/app/infrastructure/FrameRate.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack:///./src/app/peripherals/Keyboard.ts","webpack:///./src/app/peripherals/constants/KeyCodes.ts","webpack:///./src/app/peripherals/Gamepads.ts","webpack:///./src/app/domain/Grid.ts","webpack:///./src/app/domain/enemies/ConcreteEnemy.ts","webpack:///./src/app/infrastructure/Pathfinding.ts","webpack:///./src/app/domain/enemies/Enemy.ts","webpack:///./src/app/domain/objects/GameObjectFactory.ts","webpack:///./src/app/domain/objects/box/BoxFactory.ts","webpack:///./src/app/domain/objects/box/Box.ts","webpack:///./src/app/domain/objects/GameObject.ts","webpack:///./src/app/domain/player/Player.ts","webpack:///./src/app/domain/player/Crosshair.ts","webpack:///./src/app/domain/player/Projectile.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack:///./src/app/infrastructure/GameAssets.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","Mouse_1","canvas","document","getElementById","width","CANVAS_WIDTH","height","CANVAS_HEIGHT","style","SCALE","context","getContext","Canvas","[object Object]","clearRect","this","mousePosition","x","Math","floor","default","offsetLeft","y","offsetTop","halfWidth","halfHeight","rows","TILE_SIZE","cols","halfRows","halfCols","rowRemainder","colRemainder","center","getCanvasDomElement","AudioLoader_1","Canvas_1","FrameRate_1","GameStates_1","GameStateManager_1","GameAssets_1","Game","window","onfocus","restart","load","percentage","gameAssetLoaded","Audio","stateManager","getState","PAUSED","setState","PLAYING","loadInterval","setInterval","loaded","clearInterval","MAIN_MENU","gameLoop","asset","loadedPercentage","update","nextFrameRenderingShouldBeSkipped","render","calculateFrameRate","requestAnimationFrame","clear","drawFPS","GameStateLoading_1","GameStateMainMenu_1","GameStatePlaying_1","GameStatePaused_1","GAME_STATES","LOADING","ConcreteEnemy_1","GameObjectFactory_1","Map01","getEnemiesOnScreen","playerX","playerY","enemies","filter","e","isOnScreen","gameObjects","grid","player","loadMap","forEach","alive","splice","drawGameObjects","draw","deltas","dxLeft","dyTop","rowStart","row","colStart","col","gameObject","map","length","createGameObject","push","healthPercentage","Mixer_1","AudioContext_1","AudioBufferLoader_1","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","Promise","all","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","buffer","SMG_INDEX","gainNode","createGain","gain","soundFxVolume","connect","destination","start","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","addEventListener","preventDefault","pageX","pageY","setShooting","innerWidth","innerHeight","AudioContext","pointToPointDistance","p1","p2","sqrt","angleBetweenPoints","atan2","Map_1","Raycaster","theta","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","dyBottom","getInterceptPointSE","getInterceptPointSW","hitPoint","color","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","yIntercept","tileStepX","hitPointVertical","objectHitVertical","dxRight","RAYCASTER","DEBUG","arc","PI","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","checkGameObjectCollisionHorizontalSE","hitObject","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","gameObjectHit","fillText","MapKeys","isBox","mapKey","startsWith","SoundFX_1","loadCallback","Mixer","musicVolume","_musicVolume","vol","_soundFxVolume","URI","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send","lastFrameTime","frameDeltaTime","frameOverstepTime","ONE_FRAME_LENGTH_IN_SECONDS","FPS_ARR","FPS","skipNextFrameRendering","now","performance","unshift","pop","reduce","sum","current","fillStyle","font","toFixed","Game_1","drawLoadingDialog","animationCounter","animationInterval","instructionsVisible","handleMenuSelection","removeEventListener","drawMainMenu","Keyboard_1","Gamepads_1","Grid_1","Player_1","previousState","startNewGame","nextState","onblur","updateMousePosition","init","KeyCodes_1","keyCode","KEYBOARD_KEYS","w","moving","up","a","left","down","right","ESC","togglePause","ENTER","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","Point_1","CollisionBox_1","Raycaster_1","Pathfinding_1","Enemy_1","super","updateMapPosition","adjustCollisionWithGameObjects","adjustCollisionWithOtherEnemies","distanceFromPlayer","determineIfThereAreObstaclesBetweenThisEnemyAndThePlayer","findPathToPlayer","move","updateTileDeltas","drawCollisionBox","drawPath","pathToPlayer","collisionBox","getHealthColor","damageAmount","playEnemyHit","health","die","playEnemyDeath","mapX","SWVertexRow","NWVertexRow","SEVertexRow","NEVertexRow","mapY","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","thereAreObstaclesBetweenPlayerAndThisEnemy","generatePathNodes","moveTowardsPlayer","moveTowards","maxSpeedDiagonal","maxSpeed","angleBetweenPlayerAndEnemy","cast","generateNodeAroundGameObject","path","cBox","neighbours","N","NE","E","SE","S","SW","W","NW","nodeNE","generateNodeNE","nodeSE","generateNodeSE","nodeSW","generateNodeSW","nodeNW","generateNodeNW","node","startRow","startCol","rowEnd","colEnd","drawNode","findShortestPath","maxHealth","initializeHealth","round","sin","abs","playerCollisionBox","enemyX","enemyY","enemyCollisionBox","collidesWithEnemy","intersectionX","intersectionY","MapKeys_1","BoxFactory_1","createBox","Box_1","BoxGray","BoxGreen","BoxBlue","Error","GameObject_1","playCrateHit","destructable","Crosshair_1","Projectile_1","rotation","sightLineLength","shooting","shootingCooldown","projectiles","shoot","dx","dy","xVel","yVel","randomFactorX","random","randomFactorY","playSMG","isShooting","calculateTheta","drawPlayer","drawPlayerVisionRay","drawProjectiles","checkForCollisionWithEnemies","cos","drawRay","collidesWithPlayer","canvasX","canvasY","offsetX","offsetY","directionX","directionY","speed","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithGameObject","intermediateIntervalX","intermediateIntervalY","point","takeDamage","getDamage","drawPauseMenu","currentState","exit","enter","GameAssets"],"mappings":"aACA,IAAAA,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,GAAA,CACAG,EAAAH,EACAI,GAAA,EACAH,QAAA,IAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,oFClFA,MAAAC,EAAApC,EAAA,GAGAqC,EAAArC,EAAA,GAEMsC,EAASC,SAASC,eAAe,UACvCF,EAAOG,MAASL,EAAOM,aACvBJ,EAAOK,OAASP,EAAOQ,cACvBN,EAAOO,MAAMJ,MAA0B,IAAjBL,EAAOU,MAAeV,EAAOU,MAAQV,EAAOM,aAAiB,KAAO,OAC1FJ,EAAOO,MAAMF,OAA0B,IAAjBP,EAAOU,MAAeV,EAAOU,MAAQV,EAAOQ,cAAiB,KAAO,OAC7E1C,EAAA6C,QAAUT,EAAOU,WAAW,MAEzC,MAAqBC,EAgBZC,eACLhD,EAAA6C,QAAQI,UAAU,EAAG,EAAGb,EAAOG,MAAOH,EAAOK,QAKxCO,6BACLE,KAAKC,cAAgB,CACnBC,EAAGC,KAAKC,OAAOnB,EAAAoB,QAAMH,EAAIhB,EAAOoB,YAActB,EAAOU,OACrDa,EAAGJ,KAAKC,OAAOnB,EAAAoB,QAAME,EAAIrB,EAAOsB,WAAcxB,EAAOU,SAxB3CG,EAAAY,UAAavB,EAAOG,MAAS,EAC7BQ,EAAAa,WAAaxB,EAAOK,OAAS,EAC7BM,EAAAc,KAAOR,KAAKC,MAAMlB,EAAOK,OAASP,EAAO4B,WACzCf,EAAAgB,KAAOV,KAAKC,MAAMlB,EAAOG,MAASL,EAAO4B,WACzCf,EAAAiB,SAAWX,KAAKC,MAAOlB,EAAOK,OAAS,EAAKP,EAAO4B,WACnDf,EAAAkB,SAAWZ,KAAKC,MAAOlB,EAAOG,MAAS,EAAKL,EAAO4B,WACnDf,EAAAmB,aAAgB9B,EAAOK,OAAS,EAAKP,EAAO4B,UAC5Cf,EAAAoB,aAAgB/B,EAAOG,MAAS,EAAKL,EAAO4B,UAG5Cf,EAAAqB,OAAgB,CAC5BhB,EAAGlB,EAAOM,aAAgB,EAC1BiB,EAAGvB,EAAOQ,cAAgB,GAOdK,EAAAsB,oBAAsB,KAAyBjC,GApB/DpC,EAAAuD,QAAAR,uLCZA,MAAAuB,EAAAxE,EAAA,IACAyE,EAAAzE,EAAA,GAEA0E,EAAA1E,EAAA,IACA2E,EAAA3E,EAAA,GACA4E,EAAA5E,EAAA,IACA6E,EAAA7E,EAAA,IAEA,MAAqB8E,EAcnB5B,cACE6B,OAAOC,QAAU,MACfN,EAAAjB,QAAUwB,YAEZT,EAAAf,QAAYyB,KAAKC,GAAc/B,KAAKgC,gBAAgBP,EAAApB,QAAW4B,MAAOF,IAZjEjC,qBACD4B,EAAKQ,aAAaC,aAAeZ,EAAAlB,QAAY+B,OAC/CV,EAAKQ,aAAaG,SAASd,EAAAlB,QAAYiC,SAEvCZ,EAAKQ,aAAaG,SAASd,EAAAlB,QAAY+B,QAWpCtC,QACL,MAAMyC,EAAeC,YAAY,KAC3Bd,EAAKe,SACPC,cAAcH,GACdb,EAAKQ,aAAaG,SAASd,EAAAlB,QAAYsC,aAExC,KAEH3C,KAAK4C,WAGC9C,gBAAgB+C,EAAmBd,GAErCc,IAAUpB,EAAApB,QAAW4B,QACvBP,EAAKoB,iBAFa,EAEoBf,GAEV,IAA1BL,EAAKoB,mBACPpB,EAAKe,QAAS,GAIV3C,WACNE,KAAK+C,UAEiD,IAAlDzB,EAAAjB,QAAU2C,qCACZhD,KAAKiD,SAGP3B,EAAAjB,QAAU6C,qBAEVvB,OAAOwB,sBAAsB,IAAMnD,KAAK4C,YAGlC9C,SACN4B,EAAKQ,aAAaa,SAGZjD,SACNuB,EAAAhB,QAAO+C,QACP1B,EAAKQ,aAAae,SAClB3B,EAAAjB,QAAUgD,WA5DE3B,EAAAe,QAAkB,EAClBf,EAAAoB,iBAA2B,EAE3BpB,EAAAQ,aAAiC,IAAIV,EAAAnB,QAJrDvD,EAAAuD,QAAAqB,iFCRA,MAAA4B,EAAA1G,EAAA,IACA2G,EAAA3G,EAAA,IACA4G,EAAA5G,EAAA,IACA6G,EAAA7G,EAAA,IAGM8G,EAAc,CAClBC,QAAY,IAAIL,EAAAjD,QAChBsC,UAAY,IAAIY,EAAAlD,QAChBiC,QAAY,IAAIkB,EAAAnD,QAChB+B,OAAY,IAAIqB,EAAApD,SAGlBvD,EAAAuD,QAAeqD,iFCbf,MAAA1E,EAAApC,EAAA,GAKAgH,EAAAhH,EAAA,IAEAyE,EAAAzE,EAAA,GAEAiH,EAAAjH,EAAA,IAGAkH,EAAAlH,EAAA,IAKA,SAAgBmH,EAAmBC,EAAiBC,GAClD,OAAOnH,EAAAoH,QAAQC,OAAOC,GAAKA,EAAEC,WAAWL,EAASC,IAJtCnH,EAAAwH,YAA8B,GAC9BxH,EAAAoH,QAAmB,GAEhCpH,EAAAiH,qBAIAjH,EAAAuD,QAAA,MACEP,YAAoByE,EAAoBC,GAApBxE,KAAAuE,OAAoBvE,KAAAwE,SACtCxE,KAAKyE,QAAQX,GAGRhE,SACLhD,EAAAoH,QAAQQ,QAAQ,CAACN,EAAGpH,KAClBoH,EAAErB,OAAO/C,KAAKwE,OAAQ1H,EAAAoH,UACN,IAAZE,EAAEO,OACJ7H,EAAAoH,QAAQU,OAAO5H,EAAG,KAKjB8C,OACLE,KAAK6E,kBACLd,EAAmB/D,KAAKwE,OAAOtE,EAAGF,KAAKwE,OAAOjE,GAC3CmE,QAAQN,GAAKA,EAAEU,KAAK9E,KAAKwE,SAGtB1E,kBACN,MAAMQ,EAAaN,KAAKwE,OAAOO,OAAOC,OAAS3D,EAAAhB,QAAOY,aAChDT,EAAaR,KAAKwE,OAAOO,OAAOE,MAAS5D,EAAAhB,QAAOW,aAEhDkE,EAAWlF,KAAKwE,OAAOW,IAAM9D,EAAAhB,QAAOS,SACpCsE,EAAWpF,KAAKwE,OAAOa,IAAMhE,EAAAhB,QAAOU,SAC1C,IAAIuE,EACJ,IAAK,IAAIH,EAAMD,EAAUC,EAAMD,EAAW7D,EAAAhB,QAAOM,KAAO,IAAKwE,EAC3D,IAAK,IAAIE,EAAMD,EAAW,EAAGC,EAAMD,EAAW/D,EAAAhB,QAAOQ,KAAO,IAAKwE,EAC3DvI,EAAAwH,YAAYa,IAAQrI,EAAAwH,YAAYa,GAAKE,MACvCC,EAAaxI,EAAAwH,YAAYa,GAAKE,IACnBnF,GAAKmF,EAAMD,GAAYpG,EAAO4B,UAAYN,EACrDgF,EAAW/E,GAAK4E,EAAMD,GAAYlG,EAAO4B,UAAYJ,EACrD8E,EAAWR,QAMXhF,QAAQyF,GACd,IAAK,IAAIJ,EAAM,EAAGA,EAAMI,EAAIjB,YAAYkB,SAAUL,EAAK,CACrDrI,EAAAwH,YAAYa,GAAO,GACnB,IAAK,IAAIE,EAAM,EAAGA,EAAME,EAAIjB,YAAYa,GAAKK,SAAUH,EACrDvI,EAAAwH,YAAYa,GAAKE,GAAOxB,EAAAxD,QAAkBoF,iBAAiBN,EAAKE,EAAKE,EAAIjB,YAAYa,GAAKE,IAI9FE,EAAIrB,QAAQQ,QAAQN,GAAKtH,EAAAoH,QAAQwB,KAAK,IAAI9B,EAAAvD,QAAe+D,EAAElE,EAAGkE,EAAE7D,EAAG6D,EAAEuB,qGCpEzE,MAAAC,EAAAhJ,EAAA,IACAiJ,EAAAjJ,EAAA,GACAkJ,EAAAlJ,EAAA,IAEA,MAAqBmJ,EAYZjG,kBAAkBkG,GACvB,MAAMC,EAAsB,CAC1BH,EAAAhE,KAAK,qBACLgE,EAAAhE,KAAK,qBACLgE,EAAAhE,KAAK,qBACLgE,EAAAhE,KAAK,qBACLgE,EAAAhE,KAAK,qBAELgE,EAAAhE,KAAK,2BAELgE,EAAAhE,KAAK,2BACLgE,EAAAhE,KAAK,2BACLgE,EAAAhE,KAAK,2BACLgE,EAAAhE,KAAK,2BACLgE,EAAAhE,KAAK,2BAELgE,EAAAhE,KAAK,4BAIDoE,QAAqBC,QAAQC,IAAIH,GAEvCjG,KAAKqG,IAAI,GAAKH,EAAa,GAC3BlG,KAAKqG,IAAI,GAAKH,EAAa,GAC3BlG,KAAKqG,IAAI,GAAKH,EAAa,GAC3BlG,KAAKqG,IAAI,GAAKH,EAAa,GAC3BlG,KAAKqG,IAAI,GAAKH,EAAa,GAE3BlG,KAAKsG,UAAU,GAAKJ,EAAa,GAEjClG,KAAKuG,UAAU,GAAKL,EAAa,GACjClG,KAAKuG,UAAU,GAAKL,EAAa,GACjClG,KAAKuG,UAAU,GAAKL,EAAa,GACjClG,KAAKuG,UAAU,GAAKL,EAAa,GACjClG,KAAKuG,UAAU,GAAKL,EAAa,IAEjClG,KAAKwG,YAAY,GAAKN,EAAa,IACnCF,EAAoB,GAGflG,iBACL,MAAM2G,EAAYZ,EAAAxF,QAAQqG,qBAC1BD,EAAUE,OAAS3G,KAAKqG,IAAIrG,KAAK4G,WAEjC,MAAMC,EAAWhB,EAAAxF,QAAQyG,aACzBD,EAASE,KAAK9I,MAA8B,GAAtB2H,EAAAvF,QAAM2G,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQpB,EAAAxF,QAAQ6G,aAEzBT,EAAUU,QACVnH,KAAK4G,YAAc5G,KAAK4G,UAAY5G,KAAKqG,IAAIb,OAGxC1F,sBACL,IAA6B,IAAzBE,KAAKoH,gBACP,OAEF,MAAMX,EAAYZ,EAAAxF,QAAQqG,qBAC1BD,EAAUE,OAAS3G,KAAKuG,UAAUvG,KAAKqH,iBAEvC,MAAMR,EAAWhB,EAAAxF,QAAQyG,aACzBD,EAASE,KAAK9I,MAAQ2H,EAAAvF,QAAM2G,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQpB,EAAAxF,QAAQ6G,aAEzBT,EAAUU,QACVnH,KAAKqH,kBAAoBrH,KAAKqH,gBAAkBrH,KAAKuG,UAAUf,OAE/DxF,KAAKoH,iBAAkB,EACvBE,WAAW,KAAQtH,KAAKoH,iBAAkB,GAAQ,KAG7CtH,wBACL,MAAM2G,EAAYZ,EAAAxF,QAAQqG,qBAC1BD,EAAUE,OAAS3G,KAAKwG,YAAY,GAEpC,MAAMK,EAAWhB,EAAAxF,QAAQyG,aACzBD,EAASE,KAAK9I,MAAQ2H,EAAAvF,QAAM2G,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQpB,EAAAxF,QAAQ6G,aAEzBT,EAAUU,QAGLrH,sBACL,MAAM2G,EAAYZ,EAAAxF,QAAQqG,qBAC1BD,EAAUE,OAAS3G,KAAKsG,UAAU,GAElC,MAAMO,EAAWhB,EAAAxF,QAAQyG,aACzBD,EAASE,KAAK9I,MAAQ2H,EAAAvF,QAAM2G,cAC5BP,EAAUQ,QAAQJ,GAElBA,EAASI,QAAQpB,EAAAxF,QAAQ6G,aAEzBT,EAAUU,SA5GGpB,EAAAM,IAAqB,GACrBN,EAAAa,UAAY,EAEZb,EAAAO,UAA2B,GAE3BP,EAAAQ,UAA2B,GAC3BR,EAAAsB,gBAAkB,EAClBtB,EAAAqB,iBAA2B,EAE3BrB,EAAAS,YAA6B,GAV9C1J,EAAAuD,QAAA0F,iFCJA,MAAA1E,EAAAzE,EAAA,GAGA,MAAqB2K,EAGZzH,YAAY0E,GACjBxE,KAAKwH,mBACLxH,KAAKyH,qBACLzH,KAAK0H,oBAAoBlD,GAGnB1E,0BACN6B,OAAOgG,iBAAiB,cAAevD,IACrCA,EAAEwD,mBACD,GAGG9H,4BAC4BuB,EAAAhB,QAAOc,sBAClCwG,iBAAiB,YAAavD,IACnCpE,KAAKE,EAAIkE,EAAEyD,MACX7H,KAAKO,EAAI6D,EAAE0D,QACV,GAGGhI,2BAA2B0E,GACjC,MAAMtF,EAA4BmC,EAAAhB,QAAOc,sBACzCjC,EAAOyI,iBAAiB,YAAavD,IACnCI,EAAOuD,aAAY,KAClB,GACH7I,EAAOyI,iBAAiB,UAAWvD,IACjCI,EAAOuD,aAAY,KAClB,IA7BSR,EAAArH,EAAYyB,OAAOqG,WAAc,EAAI,IACrCT,EAAAhH,EAAYoB,OAAOsG,YAAc,EAAI,GAFrDnL,EAAAuD,QAAAkH,iFCHA,MAAM5H,EAAwB,IAAIuI,aAElCpL,EAAAuD,QAAeV,iFCWf7C,EAAAqL,qBAAA,SAAqCC,EAAWC,GAC9C,OAAOlI,KAAKmI,MAAMD,EAAGnI,EAAIkI,EAAGlI,IAAMmI,EAAGnI,EAAIkI,EAAGlI,IAAMmI,EAAG9H,EAAI6H,EAAG7H,IAAM8H,EAAG9H,EAAI6H,EAAG7H,KAG9EzD,EAAAyL,mBAAA,SAAmCH,EAAWC,GAE5C,OADclI,KAAKqI,MAAOJ,EAAG7H,EAAI8H,EAAG9H,EAAK6H,EAAGlI,EAAImI,EAAGnI,mFClBrDpD,EAAAuD,QAAA,MAGEP,YACST,EACAE,GADAS,KAAAX,QACAW,KAAAT,SAEPS,KAAKS,UAAaT,KAAKX,MAAS,EAChCW,KAAKU,WAAaV,KAAKT,OAAS,mFCRpC,MAAAP,EAAApC,EAAA,GAIA6L,EAAA7L,EAAA,GAEAyE,EAAAzE,EAAA,GAEA,MAAqB8L,EAYZ5I,YAAYhB,EAAU6J,EAAeC,GAC1C,KAAID,GAAS,GAUN,CACQ7J,EAAEiG,OAAOE,MAAtB,MACM4D,EAAO/J,EAAEiG,OAAOE,MAAQ9E,KAAK2I,KAAKH,GAGlCI,EAAkB,EAAIF,EAAQ,EAEpC,OAAIA,GAAQ,GAAKE,EACRL,EAAUM,oBAAoBlK,EAAG6J,GAGjCD,EAAUO,oBAAoBnK,EAAG6J,GArB5B,CACD7J,EAAEiG,OAAOmE,SAAtB,MACML,EAAO/J,EAAEiG,OAAOmE,SAAW/I,KAAK2I,IAAIH,GAE1C,GAAIE,GAAQ,EACV,OAAOH,EAAUS,oBAAoBrK,EAAG6J,GAErC,GAAIE,EAAO,EACd,OAAOH,EAAUU,oBAAoBtK,EAAG6J,IAkBvC7I,eAAeuJ,EAAiBC,EAAgB,WACrDjI,EAAA1B,QAAQ4J,YAAcD,EACtBjI,EAAA1B,QAAQ6J,UAAY,GACpBnI,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQ+J,OAAOrI,EAAAhB,QAAOI,UAAWY,EAAAhB,QAAOK,YACxCW,EAAA1B,QAAQgK,OACNtI,EAAAhB,QAAOI,UAAY4I,EAASnJ,EAC5BmB,EAAAhB,QAAOK,WAAa2I,EAAS9I,GAEjCc,EAAA1B,QAAQiK,SACRvI,EAAA1B,QAAQ6J,UAAY,EAId1J,2BAA2BhB,EAAU6J,GAI3C,IAIIkB,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhChN,EAAI,EAIR,KACE8M,EAAY9M,EAAIgC,EAAO4B,UAErBiJ,EADY,IAAVlB,EACW,GAEC7J,EAAEiG,OAAOkF,QAAUH,GAAa3J,KAAK2I,IAAIH,KAIpDmB,EAAYhL,EAAEiG,OAAOkF,QAAU5I,EAAAhB,QAAOI,WAAeoJ,EAAaxI,EAAAhB,QAAOK,aATnE,CAyBX,GAZI1B,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAY3B,EAAEiG,OAAOkF,QAAUH,EACtCzI,EAAAhB,QAAOK,WAAamJ,EACpB,EAAG,EAAI,EAAI1J,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAGVI,EAAoBtB,EAAU4B,mCAAmCtN,EAAG8B,EAAG+K,GAEhD,CACrBE,EAAmB,CAAE7J,EAAG4J,EAAYhL,EAAEiG,OAAOkF,QAAS1J,EAAGsJ,GACzD,QAEA7M,EAMJ,IAIIuN,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAI3L,EAAO4B,UACT,IAAV+H,IAGF4B,GAAczL,EAAEiG,OAAOmE,SAAWsB,GAAarK,KAAK2I,IAAIH,GAIrD6B,EAAY1L,EAAEiG,OAAOmE,SAAW7H,EAAAhB,QAAOK,YAAgB6J,EAAalJ,EAAAhB,QAAOI,aAI5EzB,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAY8J,EACnBlJ,EAAAhB,QAAOK,WAAa5B,EAAEiG,OAAOmE,SAAWsB,EACxC,EAAG,EAAI,EAAIrK,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAINC,EAAaW,KAzBN,CA+BX,GAFAE,EAAsBhC,EAAUkC,qCAAqCD,EAAG7L,EAAGyL,GAElD,CACvBE,EAAqB,CAAEvK,EAAGqK,EAAYhK,EAAGiK,EAAY1L,EAAEiG,OAAOmE,UAC9D,QAEAyB,EAOJ,GAAIZ,GAA2C,OAAvBU,EACtB,MAAO,CACLpB,SAAYU,EACZc,UAAYb,GAGX,GAAIS,GAA2C,OAArBV,EAC7B,MAAO,CACLV,SAAYoB,EACZI,UAAYH,GAGX,GAAID,GAAsBV,EAAkB,CAG/C,OAFwC5J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,GAIb,GAA2B,OAAvBS,GAAoD,OAArBV,EAA2B,CAEjE,MAAMU,EAAqB,CAAEvK,EAAGqK,EAAYhK,EAAGiK,EAAY1L,EAAEiG,OAAOmE,UAC9Da,EAAqB,CAAE7J,EAAG4J,EAAYhL,EAAEiG,OAAOkF,QAAS1J,EAAGsJ,GAGjE,OAFwC1J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,IAOZlK,2BAA2BhB,EAAU6J,GAI3C,IAIIkB,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhChN,EAAI,EAIR,KACE8M,EAAY9M,EAAIgC,EAAO4B,UAErBiJ,EADY,IAAVlB,EACW,GAEC7J,EAAEiG,OAAOkF,QAAUH,GAAa3J,KAAK2I,KAAKH,KAIrDmB,EAAYhL,EAAEiG,OAAOkF,QAAU5I,EAAAhB,QAAOI,WAAeoJ,EAAaxI,EAAAhB,QAAOK,aATnE,CAyBX,GAZI1B,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAYqJ,EAAYhL,EAAEiG,OAAOkF,QACxC5I,EAAAhB,QAAOK,WAAamJ,EACpB,EAAG,EAAI,EAAI1J,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAGVI,EAAoBtB,EAAUqC,mCAAmC/N,EAAG8B,EAAG+K,GAEhD,CACrBE,EAAmB,CAAE7J,EAAG4J,EAAYhL,EAAEiG,OAAOkF,QAAS1J,GAAIsJ,GAC1D,QAEA7M,EAMJ,IAIIuN,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAI3L,EAAO4B,UACT,IAAV+H,IAGF4B,GAAczL,EAAEiG,OAAOE,MAAQuF,GAAarK,KAAK2I,KAAKH,GAInD6B,EAAY1L,EAAEiG,OAAOE,MAAQ5D,EAAAhB,QAAOK,YAAgB6J,EAAalJ,EAAAhB,QAAOI,aAIzEzB,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAY8J,EACnBlJ,EAAAhB,QAAOK,WAAa8J,EAAY1L,EAAEiG,OAAOE,MACzC,EAAG,EAAI,EAAI9E,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAINC,EAAaW,KAzBN,CA+BX,GAFAE,EAAsBhC,EAAUsC,qCAAqCL,EAAG7L,EAAGyL,GAElD,CACvBE,EAAqB,CAAEvK,EAAGqK,EAAYhK,GAAIiK,EAAY1L,EAAEiG,OAAOE,OAC/D,QAEA0F,EAOJ,GAAIZ,GAA2C,OAAvBU,EACtB,MAAO,CACLpB,SAAYU,EACZc,UAAYb,GAGX,GAAIS,GAA2C,OAArBV,EAC7B,MAAO,CACLV,SAAYoB,EACZI,UAAYH,GAGX,GAAID,GAAsBV,EAAkB,CAG/C,OAFwC5J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,GAIb,GAA2B,OAAvBS,GAAoD,OAArBV,EAA2B,CAEjE,MAAMU,EAAqB,CAAEvK,EAAGqK,EAAYhK,GAAIiK,EAAY1L,EAAEiG,OAAOE,OAC/D8E,EAAqB,CAAE7J,EAAG4J,EAAYhL,EAAEiG,OAAOkF,QAAS1J,GAAIsJ,GAGlE,OAFwC1J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,IAMZlK,2BAA2BhB,EAAU6J,GAI3C,IAIIkB,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhChN,EAAI,EAIR,KACE8M,EAAY9M,EAAIgC,EAAO4B,UAErBiJ,EADY,IAAVlB,EACW,GAEC7J,EAAEiG,OAAOC,OAAS8E,GAAa3J,KAAK2I,IAAI3I,KAAKkK,KAAO1B,KAI/DmB,EAAYhL,EAAEiG,OAAOC,OAAS3D,EAAAhB,QAAOI,WAAeoJ,EAAaxI,EAAAhB,QAAOK,aATlE,CAyBX,GAZI1B,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAYqJ,EAAYhL,EAAEiG,OAAOC,OACxC3D,EAAAhB,QAAOK,WAAamJ,EACpB,EAAG,EAAI,EAAI1J,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAGVI,EAAoBtB,EAAUuC,mCAAmCjO,EAAG8B,EAAG+K,GAEhD,CACrBE,EAAmB,CAAE7J,GAAK4J,EAAYhL,EAAEiG,OAAOC,OAAQzE,GAAIsJ,GAC3D,QAEA7M,EAMJ,IAIIuN,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAI3L,EAAO4B,UACT,IAAV+H,IAGF4B,GAAczL,EAAEiG,OAAOE,MAAQuF,GAAarK,KAAK2I,IAAI3I,KAAKkK,KAAO1B,GAI9D6B,EAAY1L,EAAEiG,OAAOE,MAAQ5D,EAAAhB,QAAOK,YAAgB6J,EAAalJ,EAAAhB,QAAOI,aAIzEzB,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAY8J,EACnBlJ,EAAAhB,QAAOK,WAAa8J,EAAY1L,EAAEiG,OAAOE,MACzC,EAAG,EAAI,EAAI9E,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAINC,EAAaW,KAzBN,CA+BX,GAFAE,EAAsBhC,EAAUwC,qCAAqCP,EAAG7L,EAAGyL,GAElD,CACvBE,EAAqB,CAAEvK,GAAIqK,EAAYhK,GAAIiK,EAAY1L,EAAEiG,OAAOE,OAChE,QAEA0F,EAOJ,GAAIZ,GAA2C,OAAvBU,EACtB,MAAO,CACLpB,SAAYU,EACZc,UAAYb,GAGX,GAAIS,GAA2C,OAArBV,EAC7B,MAAO,CACLV,SAAYoB,EACZI,UAAYH,GAGX,GAAID,GAAsBV,EAAkB,CAG/C,OAFwC5J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,GAIb,GAA2B,OAAvBS,GAAoD,OAArBV,EAA2B,CAEjE,MAAMU,EAAqB,CAAEvK,GAAIqK,EAAYhK,GAAIiK,EAAY1L,EAAEiG,OAAOE,OAChE8E,EAAqB,CAAE7J,GAAK4J,EAAYhL,EAAEiG,OAAOC,OAAQzE,GAAIsJ,GAGnE,OAFwC1J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,IAOZlK,2BAA2BhB,EAAU6J,GAI3C,IAIIkB,EACAC,EALAC,EAA0B,KAC1BC,EAAgC,KAEhChN,EAAI,EAIR,KACE8M,EAAY9M,EAAIgC,EAAO4B,UAErBiJ,EADY,IAAVlB,EACW,GAEC7J,EAAEiG,OAAOC,OAAS8E,GAAa3J,KAAK2I,IAAI3I,KAAKkK,GAAK1B,KAI7DmB,EAAYhL,EAAEiG,OAAOC,OAAS3D,EAAAhB,QAAOI,WAAeoJ,EAAaxI,EAAAhB,QAAOK,aATlE,CAyBX,GAZI1B,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAY3B,EAAEiG,OAAOC,OAAS8E,EACrCzI,EAAAhB,QAAOK,WAAamJ,EACpB,EAAG,EAAI,EAAI1J,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAGVI,EAAoBtB,EAAUyC,mCAAmCnO,EAAG8B,EAAG+K,GAEhD,CACrBE,EAAmB,CAAE7J,GAAI4J,EAAYhL,EAAEiG,OAAOC,OAAQzE,EAAGsJ,GACzD,QAEA7M,EAMJ,IAIIuN,EACAC,EALAC,EAA4B,KAC5BC,EAAkC,KAElCC,EAAI,EAIR,OACEH,EAAYG,EAAI3L,EAAO4B,UACT,IAAV+H,IAGF4B,GAAczL,EAAEiG,OAAOmE,SAAWsB,GAAarK,KAAK2I,IAAIH,GAIrD6B,EAAY1L,EAAEiG,OAAOmE,SAAW7H,EAAAhB,QAAOK,aAAiB6J,EAAalJ,EAAAhB,QAAOI,aAI7EzB,EAAOkL,UAAUC,QACnB9I,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACN/I,EAAAhB,QAAOI,UAAY8J,EACnBlJ,EAAAhB,QAAOK,WAAa5B,EAAEiG,OAAOmE,SAAWsB,EACxC,EAAG,EAAI,EAAIrK,KAAKkK,IAElBhJ,EAAA1B,QAAQiK,UAINC,EAAaW,KAzBN,CA+BX,GAFAE,EAAsBhC,EAAU0C,qCAAqCT,EAAG7L,EAAGyL,GAElD,CACvBE,EAAqB,CAAEvK,EAAGqK,EAAYhK,EAAGiK,EAAY1L,EAAEiG,OAAOmE,UAC9D,QAEAyB,EAOJ,GAAIZ,GAA2C,OAAvBU,EACtB,MAAO,CACLpB,SAAYU,EACZc,UAAYb,GAGX,GAAIS,GAA2C,OAArBV,EAC7B,MAAO,CACLV,SAAYoB,EACZI,UAAYH,GAGX,GAAID,GAAsBV,EAAkB,CAG/C,OAFwC5J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,GAIb,GAA2B,OAAvBS,GAAoD,OAArBV,EAA2B,CAEjE,MAAMU,EAAqB,CAAEvK,EAAGqK,EAAYhK,EAAGiK,EAAY1L,EAAEiG,OAAOmE,UAC9Da,EAAqB,CAAE7J,GAAI4J,EAAYhL,EAAEiG,OAAOC,OAAQzE,EAAGsJ,GAGjE,OAFwC1J,KAAKmI,KAAKnI,KAAK2K,IAAMf,EAAiB7J,EAAG,GAAKC,KAAK2K,IAAMf,EAAiBxJ,EAAG,IAC7EJ,KAAKmI,KAAKnI,KAAK2K,IAAIL,EAAmBvK,EAAG,GAAKC,KAAK2K,IAAIL,EAAmBlK,EAAG,IAE5G,CACL8I,SAAYoB,EACZI,UAAYH,GAGP,CACLrB,SAAYU,EACZc,UAAYb,IAMZlK,0CAA0C9C,EAAW8B,EAAU+K,GACrE,MAAMwB,EAAQ,EAAIvM,EAAEuG,IAAMrI,EACpBsO,EAAQxM,EAAEqG,IAAMhF,KAAKC,OAAOtB,EAAEiG,OAAOE,MAAQ4E,GAAc7K,EAAO4B,WAExE,IAAI2K,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAEDzL,4CAA4C9C,EAAW8B,EAAUyL,GACvE,MAAMc,EAAQvM,EAAEuG,IAAMlF,KAAKC,OAAOtB,EAAEiG,OAAOC,OAASuF,GAAcvL,EAAO4B,WACnE0K,EAAQxM,EAAEqG,IAAMnI,EAAI,EAE1B,IAAIuO,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAGDzL,0CAA0C9C,EAAW8B,EAAU+K,GACrE,MAAMwB,EAAQ,EAAIvM,EAAEuG,IAAMrI,EACpBsO,EAAQxM,EAAEqG,IAAMhF,KAAKC,OAAOtB,EAAEiG,OAAOE,MAAQ4E,GAAc7K,EAAO4B,WAExE,IAAI2K,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAEDzL,4CAA4C9C,EAAW8B,EAAUyL,GACvE,MAAMc,EAAQvM,EAAEuG,IAAMlF,KAAKC,OAAOtB,EAAEiG,OAAOC,OAASuF,GAAcvL,EAAO4B,WACnE0K,EAAQxM,EAAEqG,IAAMnI,EAAI,EAE1B,IAAIuO,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAGDzL,0CAA0C9C,EAAW8B,EAAU+K,GACrE,MAAMwB,GAAU,EAAIvM,EAAEuG,IAAMrI,EACtBsO,EAAQxM,EAAEqG,IAAMhF,KAAKC,OAAOtB,EAAEiG,OAAOE,MAAQ4E,GAAc7K,EAAO4B,WAExE,IAAI2K,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAEDzL,4CAA4C9C,EAAW8B,EAAUyL,GACvE,MAAMc,EAAQvM,EAAEuG,IAAMlF,KAAKC,OAAOtB,EAAEiG,OAAOkF,QAAUM,GAAcvL,EAAO4B,WACpE0K,EAAQxM,EAAEqG,IAAMnI,EAAI,EAE1B,IAAIuO,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAGDzL,0CAA0C9C,EAAW8B,EAAU+K,GACrE,MAAMwB,EAAQvM,EAAEuG,IAAMrI,EAAI,EACpBsO,EAAQxM,EAAEqG,IAAMhF,KAAKC,OAAOtB,EAAEiG,OAAOE,MAAQ4E,GAAc7K,EAAO4B,WAExE,IAAI2K,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,EAEDzL,4CAA4C9C,EAAW8B,EAAUyL,GACvE,MAAMc,EAAQvM,EAAEuG,IAAMlF,KAAKC,OAAOtB,EAAEiG,OAAOkF,QAAUM,GAAcvL,EAAO4B,WACpE0K,EAAQxM,EAAEqG,IAAMnI,EAAI,EAE1B,IAAIuO,EAAgB,KASpB,OARI9C,EAAAnE,YAAYgH,IAAU7C,EAAAnE,YAAYgH,GAAOD,KAC3CE,EAAgB9C,EAAAnE,YAAYgH,GAAOD,IAGjCrM,EAAOkL,UAAUC,OACnB9I,EAAA1B,QAAQ6L,iBAAiBH,WAAeC,WAAeC,EAAgB,CAACA,EAAcpG,IAAKoG,EAAclG,KAAO,OAAQ,GAAI,IAAU,GAAJrI,GAG7HuO,GAxuBXzO,EAAAuD,QAAAqI,gCCRA,IAAK+C,mDAAL,SAAKA,GACHA,IAAA,iBACAA,IAAA,qBACAA,IAAA,uBACAA,IAAA,qBAJF,CAAKA,MAAO,KAOZ3O,EAAA4O,MAAA,SAAsBC,GACpB,OAAOF,EAAQE,GAAQC,WAAW,QAGpC9O,EAAAuD,QAAeoL,kFCTI,IAFnB7O,EAAA,GAEuByD,UAClB8G,uFCHL,MAAA0E,EAAAjP,EAAA,GAEAE,EAAAuD,QAAA,MACSP,kBAAkBgM,SACjBD,EAAAxL,QAAQyB,KAAKgK,oFCJvB,MAAqBC,EAIZC,yBACL,OAAOhM,KAAKiM,aAEPD,uBAAuBE,GACxBA,GAAO,GAAKA,GAAO,IACrBlM,KAAKiM,aAAeC,GAIjBlF,2BACL,OAAOhH,KAAKmM,eAEPnF,yBAAyBkF,GAC1BA,GAAO,GAAKA,GAAO,IACrBlM,KAAKmM,eAAiBD,IAjBXH,EAAAE,aAA0B,GAC1BF,EAAAI,eAA0B,IAF3CrP,EAAAuD,QAAA0L,iFCAA,MAAAlG,EAAAjJ,EAAA,GAEAE,EAAAgF,KAAA,SAAqBsK,GACnB,OAAO,IAAIjG,QAAQ,CAACkG,EAASC,KAC3B,MAAMC,EAAU,IAAIC,eACpBD,EAAQE,KAAK,MAAOL,GAAK,GACzBG,EAAQG,aAAe,cACvBH,EAAQI,OAAS,MACf9G,EAAAxF,QAAQuM,gBAAgBL,EAAQM,SAAUlG,GACjC0F,EAAQ1F,MAGnB4F,EAAQO,yFCZZ,MAAA9N,EAAApC,EAAA,GAEAyE,EAAAzE,EAAA,GAEA,IAAImQ,EACAC,EACAC,EAA4B,EAEhC,MAAMC,EAA8B,OAC9BC,EAAoB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1D,IAAIC,EACAC,GAAyB,EAE7BvQ,EAAAuD,QAAA,MACSP,2CACL,OAAOuN,EAGFvN,iBACLiN,EAAgB,KAChB,IAAK,IAAI/P,EAAI,EAAGA,EAAImQ,EAAQ3H,SAAUxI,EACpCmQ,EAAQnQ,GAAK,EAIV8C,4BACL,GAAKiN,EAGE,CACL,MAAMO,EAAMC,YAAYD,OACxBN,GAAkBM,EAAMP,GAAiB,KACpBG,IACnBD,GAAqBD,EAAiBE,GAGxCC,EAAQK,QAAQ,GAAKR,EAAiBC,IACtCE,EAAQM,MACRL,EAAMD,EAAQO,OAAO,CAACC,EAAKC,IAAYD,GAAOC,EAAS,GAAKT,EAAQ3H,OAEhEyH,GAAqBC,GACvBD,GAAwCC,EACxCG,GAAyB,GAEzBA,GAAyB,EAG3BN,EAAgBO,OApBhBP,EAAgBQ,YAAYD,MAC5BF,EAAM,EAuBHtN,iBACLuB,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQkO,UAAY,UACpBxM,EAAA1B,QAAQmO,KAAO,gBAEfzM,EAAA1B,QAAQ6L,iBAAiB4B,GAAOA,EAAIW,QAAQ,IAAM,YAAa,GAAI/O,EAAOQ,cAAgB,IAC5F6B,EAAA1B,QAAQiK,0FCzDZ,MAAA5K,EAAApC,EAAA,GAGAoR,EAAApR,EAAA,GACAyE,EAAAzE,EAAA,GAEAE,EAAAuD,QAAA,MACSP,SAGAA,QAIAA,UAIAA,SACLE,KAAKiO,oBAGCnO,oBACNuB,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQkO,UAAY,UACpBxM,EAAA1B,QAAQmO,KAAO,iBACfzM,EAAA1B,QAAQ6L,qBAA+C,IAAxBwC,EAAA3N,QAAKyC,oBAA4B9D,EAAOM,aAAe,EAAI,GAAIN,EAAOQ,cAAgB,EAAI,IAC3H6B,EAAA1B,QAAQiK,0FC3BZ,MAAA5K,EAAApC,EAAA,GAGAoR,EAAApR,EAAA,GACAyE,EAAAzE,EAAA,GACA2E,EAAA3E,EAAA,GAEAE,EAAAuD,QAAA,MAAAP,cACUE,KAAAkO,iBAA2B,EAC3BlO,KAAAmO,kBAA4B,IAC5BnO,KAAAoO,qBAA+B,EAEhCtO,QACL6B,OAAOgG,iBAAiB,UAAW3H,KAAKqO,qBAEnCvO,OACL6B,OAAO2M,oBAAoB,UAAWtO,KAAKqO,qBAGtCvO,SACLE,KAAKkO,kBAAoBlO,KAAKkO,iBAAmB,GAAKlO,KAAKmO,kBACvDnO,KAAKkO,kBAAoBlO,KAAKmO,kBAAoB,EACpDnO,KAAKoO,qBAAsB,EAE3BpO,KAAKoO,qBAAsB,EAKxBtO,SACLE,KAAKuO,eAGCzO,eACNuB,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQkO,UAAY,UAEpBxM,EAAA1B,QAAQmO,KAAO,iBACfzM,EAAA1B,QAAQ6L,SAAS,gCAAiCxM,EAAOM,aAAe,EAAI,IAAKN,EAAOQ,cAAgB,EAAI,IACxGQ,KAAKoO,sBACP/M,EAAA1B,QAAQmO,KAAO,iBACfzM,EAAA1B,QAAQ6L,SAAS,yBAA0BxM,EAAOM,aAAe,EAAI,IAAKN,EAAOQ,cAAgB,EAAI,KAEzG6B,EAAA1B,QAAQiK,SAGF9J,sBACNkO,EAAA3N,QAAK6B,aAAaG,SAASd,EAAAlB,QAAYiC,0FC7C3C,MAAA0L,EAAApR,EAAA,GACAyE,EAAAzE,EAAA,GAEA4R,EAAA5R,EAAA,IACAqC,EAAArC,EAAA,GACA6R,EAAA7R,EAAA,IAEA8R,EAAA9R,EAAA,IACA6L,EAAA7L,EAAA,GACA+R,EAAA/R,EAAA,IACA2E,EAAA3E,EAAA,GAEAE,EAAAuD,QAAA,MAKSP,MAAM8O,GACPA,IAAkBrN,EAAAlB,QAAY+B,QAChCpC,KAAK6O,eAIF/O,KAAKgP,GACNA,IAAcvN,EAAAlB,QAAY+B,SAC5BT,OAAOoN,OAAS,MAIbjP,SACLuB,EAAAhB,QAAO2O,sBACPP,EAAApO,QAAS0C,OAAO/C,KAAKwE,QACrBxE,KAAKwE,OAAOzB,SACZ/C,KAAKuF,IAAIxC,SAGJjD,SACLE,KAAKuF,IAAIT,OACT9E,KAAKwE,OAAOM,OAGNhF,eACNE,KAAKuE,KAAO,IAAImK,EAAArO,QAChBL,KAAKwE,OAAS,IAAImK,EAAAtO,QAAO,IAAK,IAC9BL,KAAKuF,IAAM,IAAIkD,EAAApI,QAAIL,KAAKuE,KAAMvE,KAAKwE,QAEnC7C,OAAOoN,OAAS,MACdf,EAAA3N,QAAK6B,aAAaG,SAASd,EAAAlB,QAAY+B,UAGzCoM,EAAAnO,QAAS4O,KAAKjP,KAAKwE,QACnBvF,EAAAoB,QAAM4O,KAAKjP,KAAKwE,yFCrDpB,MAAAwJ,EAAApR,EAAA,GAGAsS,EAAAtS,EAAA,IAEAE,EAAAuD,QAAA,MACSP,YAAY0E,GACjBrF,SAASwI,iBAAiB,UAAWvD,IAEnC,OAAQA,EAAE+K,SACR,KAAKD,EAAAE,cAAcC,EACjB7K,EAAO8K,OAAOC,IAAK,EACnB,MACF,KAAKL,EAAAE,cAAcI,EACjBhL,EAAO8K,OAAOG,MAAO,EACrB,MACF,KAAKP,EAAAE,cAAcrQ,EACjByF,EAAO8K,OAAOI,MAAO,EACrB,MACF,KAAKR,EAAAE,cAAc9R,EACjBkH,EAAO8K,OAAOK,OAAQ,EACtB,MACF,KAAKT,EAAAE,cAAcQ,IACnB,KAAKV,EAAAE,cAActQ,EACjBkP,EAAA3N,QAAKwP,iBAMX1Q,SAASwI,iBAAiB,QAASvD,IACjC,OAAQA,EAAE+K,SACR,KAAKD,EAAAE,cAAcC,EACjB7K,EAAO8K,OAAOC,IAAK,EACnB,MACF,KAAKL,EAAAE,cAAcI,EACjBhL,EAAO8K,OAAOG,MAAO,EACrB,MACF,KAAKP,EAAAE,cAAcrQ,EACjByF,EAAO8K,OAAOI,MAAO,EACrB,MACF,KAAKR,EAAAE,cAAc9R,EACjBkH,EAAO8K,OAAOK,OAAQ,sFC1CnB7S,EAAAsS,cAAgB,CAC3BU,MAAO,GACPF,IAAK,GACLP,EAAG,GACHG,EAAG,GACHzQ,EAAG,GACHzB,EAAG,GACHwB,EAAG,mFCNL,MAAAG,EAAArC,EAAA,GAEA,MAAqBmT,EACZjQ,cAAc0E,GACnB,MAAMwL,EAAWC,UAAUC,cACvBF,EAAS,KACXhQ,KAAKmQ,eAAeH,EAAS,GAAIxL,GACjCxE,KAAKoQ,aAAaJ,EAAS,IAC3BhQ,KAAKqQ,cAAcL,EAAS,GAAIxL,IAM5B1E,sBAAsBwQ,EAAc9L,GAC1C,MAAM+L,GAAyBD,EAAQE,KAAK,GAAGzC,QAAQ,GACnDwC,EAAgB,EAClB/L,EAAO8K,OAAOK,OAAQ,EAEfY,EAAgB,EACvB/L,EAAO8K,OAAOG,MAAO,GAGrBjL,EAAO8K,OAAOG,MAAQ,EACtBjL,EAAO8K,OAAOK,OAAQ,GAGxB,MAAMc,GAAyBH,EAAQE,KAAK,GAAGzC,QAAQ,GACnD0C,EAAgB,EAClBjM,EAAO8K,OAAOI,MAAO,EAEde,EAAgB,EACvBjM,EAAO8K,OAAOC,IAAK,GAGnB/K,EAAO8K,OAAOC,IAAO,EACrB/K,EAAO8K,OAAOI,MAAO,GAIjB5P,oBAAoBwQ,GAC1B,MAAMI,EAAWJ,EAAQE,KAAK,GACxBG,EAAWL,EAAQE,KAAK,GACD,IAAxBE,EAAS3C,QAAQ,KACpB9O,EAAAoB,QAAMH,GAAKwQ,EAAW1Q,KAAK4Q,aAEA,IAAxBD,EAAS5C,QAAQ,KACpB9O,EAAAoB,QAAME,GAAKoQ,EAAW3Q,KAAK4Q,aAIvB9Q,qBAAqBwQ,EAAc9L,GAC9B8L,EAAQO,QAAQ,GACpBC,QACLtM,EAAOuD,aAAY,GAGnBvD,EAAOuD,aAAY,IA7CRgI,EAAAa,YAAsB,GAVvC9T,EAAAuD,QAAA0P,iFCHA,MAAA/Q,EAAApC,EAAA,GAGAE,EAAAuD,QAAA,MAAAP,cACSE,KAAAW,KAAe3B,EAAOQ,cAAgBR,EAAO4B,UAC7CZ,KAAAa,KAAe7B,EAAOM,aAAgBN,EAAO4B,2FCLtD,MAAA5B,EAAApC,EAAA,GAEAiP,EAAAjP,EAAA,GAEAyE,EAAAzE,EAAA,GACAmU,EAAAnU,EAAA,GACAoU,EAAApU,EAAA,GACAqU,EAAArU,EAAA,IACAsU,EAAAtU,EAAA,IAEA6L,EAAA7L,EAAA,GAEAuU,EAAAvU,EAAA,IAEAE,EAAAuD,QAAA,cAA4C8Q,EAAA9Q,QAC1CP,YACEI,EACAK,EACAoF,GAEAyL,MAAMlR,EAAGK,EAAG,IAAIyQ,EAAA3Q,QAAa,GAAI,IAAK,EAAGsF,GACzC3F,KAAKqR,oBAGAvR,OAAO0E,EAAgBN,GAC5BlE,KAAKsR,iCACLtR,KAAKuR,gCAAgCrN,GACrClE,KAAKwR,mBAAqBT,EAAA5I,qBACxB,CAAEjI,EAAGsE,EAAOtE,EAAGK,EAAGiE,EAAOjE,GACzB,CAAEL,EAAGF,KAAKE,EAAKK,EAAGP,KAAKO,IAEzBP,KAAKyR,yDAAyDjN,GAC9DxE,KAAK0R,iBAAiBlN,GACtBxE,KAAK2R,OACL3R,KAAK4R,mBAGA9R,KAAK0E,GACVxE,KAAK6R,iBAAiBrN,GAEtB0M,EAAAY,SAAS9R,KAAK+R,aAAc/R,KAAKgS,aAAcxN,EAAQxE,KAAKiS,kBAGvDnS,WAAWoS,GAChBrG,EAAAxL,QAAQ8R,eACRnS,KAAKoS,QAAUF,EACXlS,KAAKoS,QAAU,EACjBpS,KAAKqS,MAELxG,EAAAxL,QAAQ8R,eAILrS,MACL+L,EAAAxL,QAAQiS,iBACRtS,KAAK2E,OAAQ,EAIP7E,iCACN,IAAIrC,EACJ,GAAIgL,EAAAnE,YAAYtE,KAAKmF,KAAM,CACzB,GAAInF,KAAKsP,OAAOG,KAAM,EACpBhS,EAAIgL,EAAAnE,YAAYtE,KAAKmF,KAAKnF,KAAKqF,IAAM,KAC5BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,KAAO9U,EAAE4B,QAC1DW,KAAKE,EAAIzC,EAAE8U,KAAO9U,EAAE4B,MAAQW,KAAKgS,aAAavR,UAAY,GAG5D,MAAM+R,EAAcrS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,WAAa,GAAK1B,EAAO4B,WAChF4R,IAAgBxS,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYkO,GAAaxS,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,KAAO9U,EAAE4B,QACpDW,KAAKsP,OAAOI,MAAQ1P,KAAK+E,OAAOE,OAASjF,KAAK+E,OAAOkF,UACzDjK,KAAKE,EAAIzC,EAAE8U,KAAO9U,EAAE4B,MAAQW,KAAKgS,aAAavR,UAAY,IAKhE,MAAMgS,EAActS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,YAAc1B,EAAO4B,WAC5E6R,IAAgBzS,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYmO,GAAazS,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,KAAO9U,EAAE4B,QACpDW,KAAKsP,OAAOC,IAAMvP,KAAK+E,OAAOmE,UAAYlJ,KAAK+E,OAAOkF,UAC1DjK,KAAKE,EAAIzC,EAAE8U,KAAO9U,EAAE4B,MAAQW,KAAKgS,aAAavR,UAAY,IAKlE,GAAIT,KAAKsP,OAAOK,MAAO,EACrBlS,EAAIgL,EAAAnE,YAAYtE,KAAKmF,KAAKnF,KAAKqF,IAAM,KAC5BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,OACjDvS,KAAKE,EAAIzC,EAAE8U,KAAOvS,KAAKgS,aAAavR,UAAY,GAGlD,MAAMiS,EAAcvS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,WAAa,GAAK1B,EAAO4B,WAChF8R,IAAgB1S,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYoO,GAAa1S,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,OAC3CvS,KAAKsP,OAAOI,MAAQ1P,KAAK+E,OAAOE,OAASjF,KAAK+E,OAAOC,SACzDhF,KAAKE,EAAIzC,EAAE8U,KAAOvS,KAAKgS,aAAavR,UAAY,IAKtD,MAAMkS,EAAcxS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,YAAc1B,EAAO4B,WAC5E+R,IAAgB3S,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYqO,GAAa3S,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,OAC3CvS,KAAKsP,OAAOC,IAAMvP,KAAK+E,OAAOmE,UAAYlJ,KAAK+E,OAAOC,SAC1DhF,KAAKE,EAAIzC,EAAE8U,KAAOvS,KAAKgS,aAAavR,UAAY,KAM1D,GAAIgI,EAAAnE,YAAYtE,KAAKmF,IAAM,IACrBnF,KAAKsP,OAAOC,GAAI,EAClB9R,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAGnF,KAAKqF,OAC1BrF,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,KAAOnV,EAAE8B,SAC3DS,KAAKO,EAAI9C,EAAEmV,KAAOnV,EAAE8B,OAASS,KAAKgS,aAAatR,WAAa,GAG9D,MAAMmS,EAAc1S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,UAAY,GAAKzB,EAAO4B,WAC/EiS,IAAgB7S,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG0N,KACrB7S,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,KAAOnV,EAAE8B,SACrDS,KAAKsP,OAAOK,OAAS3P,KAAK+E,OAAOmE,SAAWlJ,KAAK+E,OAAOC,SAC5DhF,KAAKO,EAAI9C,EAAEmV,KAAOnV,EAAE8B,OAASS,KAAKgS,aAAatR,WAAa,IAKlE,MAAMoS,EAAc3S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,WAAazB,EAAO4B,WAC3EkS,IAAgB9S,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG2N,KACrB9S,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,KAAOnV,EAAE8B,SACrDS,KAAKsP,OAAOG,MAAQzP,KAAK+E,OAAOmE,SAAWlJ,KAAK+E,OAAOkF,UAC3DjK,KAAKO,EAAI9C,EAAEmV,KAAOnV,EAAE8B,OAASS,KAAKgS,aAAatR,WAAa,IAMtE,GAAI+H,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAI,CACzBnF,KAAKsP,OAAOI,OACdjS,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAGnF,KAAKqF,OAC1BrF,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,OAClD5S,KAAKO,EAAI9C,EAAEmV,KAAO5S,KAAKgS,aAAatR,WAAa,GAIrD,MAAMqS,EAAc5S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,UAAY,GAAKzB,EAAO4B,WAC/EmS,IAAgB/S,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG4N,KACrB/S,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,OAC5C5S,KAAKsP,OAAOK,OAAS3P,KAAK+E,OAAOE,MAAQjF,KAAK+E,OAAOC,SACzDhF,KAAKO,EAAI9C,EAAEmV,KAAO5S,KAAKgS,aAAatR,WAAa,IAKvD,MAAMsS,EAAc7S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,WAAazB,EAAO4B,WAC3EoS,IAAgBhT,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG6N,KACrBhT,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,OAC5C5S,KAAKsP,OAAOG,MAAQzP,KAAK+E,OAAOE,MAAQjF,KAAK+E,OAAOkF,UACxDjK,KAAKO,EAAI9C,EAAEmV,KAAO5S,KAAKgS,aAAatR,WAAa,KAOnDZ,iBAAiB0E,GACnBxE,KAAKiT,4CACPjT,KAAK+R,aAAeb,EAAAgC,kBAAkBlT,KAAKmF,IAAKnF,KAAKqF,IAAKrF,KAAKgS,cAC/DhS,KAAKmT,kBAAkB3O,KAGnBxE,KAAK+R,eACP/R,KAAK+R,aAAe,MAEtB/R,KAAKmT,kBAAkB3O,IAInB1E,kBAAkB0E,GACpBxE,KAAKwR,mBAAqB,GAC5BxR,KAAKoT,YAAY5O,EAAOtE,EAAGsE,EAAOjE,GAI9BT,YAAYI,EAAWK,GAC7BP,KAAKsP,OAAOG,MAAQ,EACpBzP,KAAKsP,OAAOK,OAAQ,EACpB3P,KAAKsP,OAAOC,IAAQ,EACpBvP,KAAKsP,OAAOI,MAAQ,EAChB1P,KAAKE,EAAIA,EACXF,KAAKsP,OAAOK,OAAQ,EAEb3P,KAAKE,EAAIA,IAChBF,KAAKsP,OAAOG,MAAO,GAEjBzP,KAAKO,EAAIA,EACXP,KAAKsP,OAAOI,MAAO,EAEZ1P,KAAKO,EAAIA,IAChBP,KAAKsP,OAAOC,IAAK,GAKbzP,OACFE,KAAKsP,OAAOG,OACVzP,KAAKsP,OAAOC,IAAMvP,KAAKsP,OAAOI,KAChC1P,KAAKE,GAAKF,KAAKqT,iBAEfrT,KAAKE,GAAKF,KAAKsT,UAGftT,KAAKsP,OAAOK,QACV3P,KAAKsP,OAAOC,IAAMvP,KAAKsP,OAAOI,KAChC1P,KAAKE,GAAKF,KAAKqT,iBAEfrT,KAAKE,GAAKF,KAAKsT,UAGftT,KAAKsP,OAAOC,KACVvP,KAAKsP,OAAOG,MAAQzP,KAAKsP,OAAOK,MAClC3P,KAAKO,GAAKP,KAAKqT,iBAEfrT,KAAKO,GAAKP,KAAKsT,UAGftT,KAAKsP,OAAOI,OACV1P,KAAKsP,OAAOG,MAAQzP,KAAKsP,OAAOK,MAClC3P,KAAKO,GAAKP,KAAKqT,iBAEfrT,KAAKO,GAAKP,KAAKsT,UAGnBtT,KAAKqR,oBAICvR,oBACNE,KAAKmF,IAAMhF,KAAKC,MAAMJ,KAAKO,EAAIvB,EAAO4B,WACtCZ,KAAKqF,IAAMlF,KAAKC,MAAMJ,KAAKE,EAAIlB,EAAO4B,WAIhCd,mBACNE,KAAK+E,OAAOE,MAAQjF,KAAKO,EAAIvB,EAAO4B,UACpCZ,KAAK+E,OAAOmE,SAAWlK,EAAO4B,UAAYZ,KAAK+E,OAAOE,MACtDjF,KAAK+E,OAAOC,OAAShF,KAAKE,EAAIlB,EAAO4B,UACrCZ,KAAK+E,OAAOkF,QAAUjL,EAAO4B,UAAYZ,KAAK+E,OAAOC,OAG/ClF,yDAAyD0E,GAC/D,MAAM+O,EAA6BxC,EAAAxI,mBACjC,CAAErI,EAAGF,KAAKE,EAAKK,EAAGP,KAAKO,GACvB,CAAEL,EAAGsE,EAAOtE,EAAGK,EAAGiE,EAAOjE,KAErB8I,SAAEA,GAAa4H,EAAA5Q,QAAUmT,KAAKhP,EAAQ+O,GAC5CvT,KAAKiT,2CACHjT,KAAKwR,mBAAqBT,EAAA5I,qBAAqBkB,EAAU,CAAEnJ,EAAG,EAAGK,EAAG,IAMhET,iBAAiB0E,GACvBnD,EAAA1B,QAAQ4J,YAAcvJ,KAAKiS,iBAC3B5Q,EAAA1B,QAAQ6J,UAAY,GACpBnI,EAAA1B,QAAQ8J,YAGNpI,EAAA1B,QAAQ+J,OAAQ,GAAMrI,EAAAhB,QAAOa,OAAOhB,GAAKF,KAAKE,EAAIsE,EAAOtE,GAAKF,KAAKgS,aAAavR,UAAY,GAAMY,EAAAhB,QAAOa,OAAOX,GAAKP,KAAKO,EAAIiE,EAAOjE,GAAKP,KAAKgS,aAAatR,YAC5JW,EAAA1B,QAAQgK,QAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,GAAKF,KAAKE,EAAIsE,EAAOtE,GAAKF,KAAKgS,aAAavR,UAAY,GAAMY,EAAAhB,QAAOa,OAAOX,GAAKP,KAAKO,EAAIiE,EAAOjE,GAAKP,KAAKgS,aAAatR,YAC5JW,EAAA1B,QAAQgK,QAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,GAAKF,KAAKE,EAAIsE,EAAOtE,GAAKF,KAAKgS,aAAavR,WAAY,GAAMY,EAAAhB,QAAOa,OAAOX,GAAKP,KAAKO,EAAIiE,EAAOjE,GAAKP,KAAKgS,aAAatR,YAC5JW,EAAA1B,QAAQgK,OAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,GAAKF,KAAKE,EAAIsE,EAAOtE,GAAKF,KAAKgS,aAAavR,WAAY,GAAMY,EAAAhB,QAAOa,OAAOX,GAAKP,KAAKO,EAAIiE,EAAOjE,GAAKP,KAAKgS,aAAatR,YAC5JW,EAAA1B,QAAQgK,OAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,GAAKF,KAAKE,EAAIsE,EAAOtE,GAAKF,KAAKgS,aAAavR,UAAY,GAAMY,EAAAhB,QAAOa,OAAOX,GAAKP,KAAKO,EAAIiE,EAAOjE,GAAKP,KAAKgS,aAAatR,YAC9JW,EAAA1B,QAAQiK,SAIF9J,gBAAgB0E,GAClBxE,KAAKiT,2CACP5R,EAAA1B,QAAQ4J,YAAc,UAEtBlI,EAAA1B,QAAQ4J,YAAc,UAExBlI,EAAA1B,QAAQ6J,UAAY,GACpBnI,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQ+J,OAAOrI,EAAAhB,QAAOa,OAAOhB,GAAKF,KAAKE,EAAIsE,EAAOtE,GAAImB,EAAAhB,QAAOa,OAAOX,GAAKP,KAAKO,EAAIiE,EAAOjE,IACzFc,EAAA1B,QAAQgK,OAAOtI,EAAAhB,QAAOa,OAAOhB,EAAGmB,EAAAhB,QAAOa,OAAOX,GAChDc,EAAA1B,QAAQiK,0FCnSZ,MAAAvI,EAAAzE,EAAA,GAEA6L,EAAA7L,EAAA,GA8CA,SAAS6W,EAA6BC,EAAejW,EAAekW,GAClE,MAAMC,EAAyB,CAC7BC,EAAKpL,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAKsD,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAG1H,EAAE4H,KAAW,KAClEyO,GAAKrL,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAKsD,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAG1H,EAAE4H,IAAM,GAAK,KAClE0O,EAAKtL,EAAAnE,YAAY7G,EAAE0H,KAAWsD,EAAAnE,YAAY7G,EAAE0H,KAAS1H,EAAE4H,IAAM,GAAK,KAClE2O,GAAKvL,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAKsD,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAG1H,EAAE4H,IAAM,GAAK,KAClE4O,EAAKxL,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAKsD,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAG1H,EAAE4H,KAAW,KAClE6O,GAAKzL,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAKsD,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAG1H,EAAE4H,IAAM,GAAK,KAClE8O,EAAK1L,EAAAnE,YAAY7G,EAAE0H,KAAWsD,EAAAnE,YAAY7G,EAAE0H,KAAS1H,EAAE4H,IAAM,GAAK,KAClE+O,GAAK3L,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAKsD,EAAAnE,YAAY7G,EAAE0H,IAAM,GAAG1H,EAAE4H,IAAM,GAAK,MAGpE,IAAIgP,EAuBN,SAAwB5W,EAAemW,EAAwBD,GAC7D,GAAIC,EAAWE,GACb,OAAO,KAGP,IAAKF,EAAWC,IAAMD,EAAWG,EAC/B,MAAO,CACL7T,EAAGzC,EAAE8U,KAAO9U,EAAE4B,MAAQsU,EAAKlT,UAC3BF,EAAG9C,EAAEmV,KAAOe,EAAKjT,YAGrB,GAAIkT,EAAWC,IAAMD,EAAWG,EAC9B,MAAO,CACL7T,EAAGzC,EAAE8U,KAAO9U,EAAE4B,MAAQsU,EAAKlT,UAC3BF,EAAG9C,EAAEmV,MAGT,IAAKgB,EAAWC,GAAKD,EAAWG,EAC9B,MAAO,CACL7T,EAAGzC,EAAE8U,KAAO9U,EAAE4B,MACdkB,EAAG9C,EAAEmV,KAAOe,EAAKjT,YA3CV4T,CAAe7W,EAAGmW,EAAYD,GACvCY,EA+CN,SAAwB9W,EAAemW,EAAwBD,GAC7D,GAAIC,EAAWI,GACb,OAAO,KAGP,IAAKJ,EAAWK,IAAML,EAAWG,EAC/B,MAAO,CACL7T,EAAGzC,EAAE8U,KAAO9U,EAAE4B,MAASsU,EAAKlT,UAC5BF,EAAG9C,EAAEmV,KAAOnV,EAAE8B,OAASoU,EAAKjT,YAGhC,GAAIkT,EAAWK,IAAML,EAAWG,EAC9B,MAAO,CACL7T,EAAGzC,EAAE8U,KAAO9U,EAAE4B,MAASsU,EAAKlT,UAC5BF,EAAG9C,EAAEmV,KAAOnV,EAAE8B,QAGlB,IAAKqU,EAAWK,GAAKL,EAAWG,EAC9B,MAAO,CACL7T,EAAGzC,EAAE8U,KAAO9U,EAAE4B,MACdkB,EAAG9C,EAAEmV,KAAOnV,EAAE8B,OAASoU,EAAKjT,YAnErB8T,CAAe/W,EAAGmW,EAAYD,GACvCc,EAuEN,SAAwBhX,EAAemW,EAAwBD,GAC7D,GAAIC,EAAWM,GACb,OAAO,KAGP,IAAKN,EAAWK,IAAML,EAAWO,EAC/B,MAAO,CACLjU,EAAGzC,EAAE8U,KAAOoB,EAAKlT,UACjBF,EAAG9C,EAAEmV,KAAOnV,EAAE8B,OAASoU,EAAKjT,YAGhC,GAAIkT,EAAWK,IAAML,EAAWO,EAC9B,MAAO,CACLjU,EAAGzC,EAAE8U,KAAOoB,EAAKlT,UACjBF,EAAG9C,EAAEmV,KAAOnV,EAAE8B,QAGlB,IAAKqU,EAAWK,GAAKL,EAAWO,EAC9B,MAAO,CACLjU,EAAGzC,EAAE8U,KACLhS,EAAG9C,EAAEmV,KAAOnV,EAAE8B,OAASoU,EAAKjT,YA3FrBgU,CAAejX,EAAGmW,EAAYD,GACvCgB,EA+FN,SAAwBlX,EAAemW,EAAwBD,GAC7D,GAAIC,EAAWQ,GACb,OAAO,KAGP,IAAKR,EAAWC,IAAMD,EAAWO,EAC/B,MAAO,CACLjU,EAAGzC,EAAE8U,KAAOoB,EAAKlT,UACjBF,EAAG9C,EAAEmV,KAAOe,EAAKjT,YAGrB,GAAIkT,EAAWC,IAAMD,EAAWO,EAC9B,MAAO,CACLjU,EAAGzC,EAAE8U,KAAOoB,EAAKlT,UACjBF,EAAG9C,EAAEmV,MAGT,IAAKgB,EAAWC,GAAKD,EAAWO,EAC9B,MAAO,CACLjU,EAAGzC,EAAE8U,KACLhS,EAAG9C,EAAEmV,KAAOe,EAAKjT,YAnHVkU,CAAenX,EAAGmW,EAAYD,GAEvCU,IAAWA,EAAOnU,EAAI,GAAKmU,EAAO9T,EAAI,KAAM8T,EAAS,MACrDE,IAAWA,EAAOrU,EAAI,GAAKqU,EAAOhU,EAAI,KAAMgU,EAAS,MACrDE,IAAWA,EAAOvU,EAAI,GAAKuU,EAAOlU,EAAI,KAAMkU,EAAS,MACrDE,IAAWA,EAAOzU,EAAI,GAAKyU,EAAOpU,EAAI,KAAMoU,EAAS,MAEzDjB,EAAKhP,QAAQmQ,IACPR,GAAWQ,EAAK3U,IAAMmU,EAAOnU,GAAK2U,EAAKtU,IAAM8T,EAAO9T,IAAM8T,EAAS,MACnEE,GAAWM,EAAK3U,IAAMqU,EAAOrU,GAAK2U,EAAKtU,IAAMgU,EAAOhU,IAAMgU,EAAS,MACnEE,GAAWI,EAAK3U,IAAMuU,EAAOvU,GAAK2U,EAAKtU,IAAMkU,EAAOlU,IAAMkU,EAAS,MACnEE,GAAWE,EAAK3U,IAAMyU,EAAOzU,GAAK2U,EAAKtU,IAAMoU,EAAOpU,IAAMoU,EAAS,QAGrEN,GAAUX,EAAKhO,KAAK2O,GACpBE,GAAUb,EAAKhO,KAAK6O,GACpBE,GAAUf,EAAKhO,KAAK+O,GACpBE,GAAUjB,EAAKhO,KAAKiP,GAvD1B7X,EAAAoW,kBAAA,SAAkC4B,EAAkBC,EAAkBpB,GACpE,MAAMD,EAAgB,GAItB,IAAIxO,EAAW4P,EAAWzT,EAAAhB,QAAOS,SAFf,EAGdsE,EAAW2P,EAAW1T,EAAAhB,QAAOU,SAFf,EAGlB,MAAMiU,EAASF,EAAWzT,EAAAhB,QAAOS,SAJf,EAKZmU,EAASF,EAAW1T,EAAAhB,QAAOU,SAJf,EAMdmE,EAAW,IAAKA,EAAW,GAC3BE,EAAW,IAAKA,EAAW,GAE/B,IAAK,IAAID,EAAMD,EAAUC,EAAM6P,IAAU7P,EACvC,IAAK,IAAIE,EAAMD,EAAW,EAAGC,EAAM4P,IAAU5P,EACtCoD,EAAAnE,YAAYa,IAASsD,EAAAnE,YAAYa,GAAKE,IAC3CoO,EAA6BC,EAAMjL,EAAAnE,YAAYa,GAAKE,GAAMsO,GAI9D,OAAOD,GA2IT5W,EAAAgV,SAAA,SAAyB4B,EAAeC,EAAoBnP,EAAgB8E,GACtEoK,GACFA,EAAKhP,QAAQmQ,QAAQK,IA4BzBpY,EAAAqY,iBAAA,4FC3NA,MAAAnW,EAAApC,EAAA,GAMAE,EAAAuD,QAAA,MA0BEP,YACSI,EACAK,EACAyR,EACGsB,EACV3N,GAJO3F,KAAAE,IACAF,KAAAO,IACAP,KAAAgS,eACGhS,KAAAsT,WA7BLtT,KAAA2E,OAAiB,EACjB3E,KAAAoV,UAAoB,IAGpBpV,KAAAsP,OAAS,CACdG,MAAQ,EACRE,OAAQ,EACRJ,IAAQ,EACRG,MAAQ,GAIH1P,KAAA+E,OAAS,CACdE,MAAW,EACXiE,SAAW,EACXlE,OAAW,EACXiF,QAAW,GAgBXjK,KAAKqV,iBAAiB1P,GAEtB3F,KAAKqT,iBAAmBlT,KAAKmV,MAAMnV,KAAKoV,IAAI,IAAMvV,KAAKsT,UAMlDxT,WAAWkE,EAAiBC,GACjC,OACE9D,KAAKqV,IAAIxV,KAAKE,EAAI8D,GAAYhF,EAAOM,aAAgB,EAAKN,EAAO4B,WACjET,KAAKqV,IAAIxV,KAAKO,EAAI0D,GAAYjF,EAAOQ,cAAgB,EAAKR,EAAO4B,UAI9Dd,mBAAmBkE,EAAiBC,EAAiBwR,GAC1D,OACEzV,KAAKE,EAAIF,KAAKgS,aAAavR,UAAauD,EAAUyR,EAAmBhV,WACrET,KAAKE,EAAIF,KAAKgS,aAAavR,UAAauD,EAAUyR,EAAmBhV,WACrET,KAAKO,EAAIP,KAAKgS,aAAatR,WAAauD,EAAUwR,EAAmB/U,YACrEV,KAAKO,EAAIP,KAAKgS,aAAatR,WAAauD,EAAUwR,EAAmB/U,WAM/DZ,kBAAkB4V,EAAgBC,EAAgBC,GAC1D,OACE5V,KAAKE,EAAIF,KAAKgS,aAAavR,UAAaiV,EAASE,EAAkBnV,WACnET,KAAKE,EAAIF,KAAKgS,aAAavR,UAAaiV,EAASE,EAAkBnV,WACnET,KAAKO,EAAIP,KAAKgS,aAAatR,WAAaiV,EAASC,EAAkBlV,YACnEV,KAAKO,EAAIP,KAAKgS,aAAatR,WAAaiV,EAASC,EAAkBlV,WAI7DZ,gCAAgCoE,GACxCA,EAAQQ,QAAQN,IACd,GAAIpE,OAASoE,GAAKpE,KAAK6V,kBAAkBzR,EAAElE,EAAGkE,EAAE7D,EAAG6D,EAAE4N,cAAe,CAClE,IAAI8D,EACAC,EACA/V,KAAKE,EAAIkE,EAAElE,EACb4V,EAAiB9V,KAAKE,EAAIF,KAAKgS,aAAavR,WAAc2D,EAAElE,EAAIkE,EAAE4N,aAAavR,WACtET,KAAKE,EAAIkE,EAAElE,IACpB4V,EAAiB1R,EAAElE,EAAIkE,EAAE4N,aAAavR,WAAcT,KAAKE,EAAIF,KAAKgS,aAAavR,YAE7ET,KAAKO,EAAI6D,EAAE7D,EACbwV,EAAiB/V,KAAKO,EAAIP,KAAKgS,aAAatR,YAAe0D,EAAE7D,EAAI6D,EAAE4N,aAAatR,YACvEV,KAAKO,EAAI6D,EAAE7D,IACpBwV,EAAiB3R,EAAE7D,EAAI6D,EAAE4N,aAAatR,YAAeV,KAAKO,EAAIP,KAAKgS,aAAatR,cAE7EoV,GAAiBA,EAAgBC,EAChC/V,KAAKO,EAAI6D,EAAE7D,EACb6D,EAAE7D,GAAKwV,EAEP3R,EAAE7D,GAAKwV,IAECA,GAAiBD,EAAgBC,KACvC/V,KAAKE,EAAIkE,EAAElE,EACbkE,EAAElE,GAAK4V,EAEP1R,EAAElE,GAAK4V,MAOPhW,iBACR,OAAIE,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACf,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,QAA2B,GAAjBpS,KAAKoV,UACtB,UACEpV,KAAKoS,OAASpS,KAAKoV,UACrB,UACEpV,KAAKoS,SAAWpS,KAAKoV,UACvB,eADF,EAKDtV,iBAAiB6F,IACnBA,EAAmB,GAAOA,EAAmB,KAC/CA,EAAmB,GAErB3F,KAAKoS,OAASpS,KAAKoV,UAAYzP,mFCvInC,MAAAqQ,EAAApZ,EAAA,IACAqZ,EAAArZ,EAAA,IAEAE,EAAAuD,QAAA,MACSP,wBAAwBqF,EAAaE,EAAasG,GACvD,OAAIqK,EAAAtK,MAAMC,GACDsK,EAAA5V,QAAW6V,UAAU/Q,EAAKE,EAAKsG,GAG/B,sFCVb,MAAA3M,EAAApC,EAAA,GAEAuZ,EAAAvZ,EAAA,IACAoZ,EAAApZ,EAAA,IAEAE,EAAAuD,QAAA,MACSP,iBAAiBqF,EAAaE,EAAasG,GAChD,OAAQA,GACN,KAAKqK,EAAA3V,QAAQ+V,QACX,OAAO,IAAID,EAAA9V,QAAI8E,EAAKE,EAAKrG,EAAO4B,UAAW5B,EAAO4B,UAAW,WAAW,GAC1E,KAAKoV,EAAA3V,QAAQgW,SACX,OAAO,IAAIF,EAAA9V,QAAI8E,EAAKE,EAAKrG,EAAO4B,UAAW5B,EAAO4B,UAAW,WAC/D,KAAKoV,EAAA3V,QAAQiW,QACX,OAAO,IAAIH,EAAA9V,QAAI8E,EAAKE,EAAKrG,EAAO4B,UAAW5B,EAAO4B,UAAW,WAC/D,QACE,MAAM,IAAI2V,MAAM,kGCfxB,MAAAvX,EAAApC,EAAA,GAEAyE,EAAAzE,EAAA,GACAiP,EAAAjP,EAAA,GACA4Z,EAAA5Z,EAAA,IAEAE,EAAAuD,QAAA,cAAiCmW,EAAAnW,QAC/BP,OACEuB,EAAA1B,QAAQ4J,YAAcvJ,KAAKsJ,MAC3BjI,EAAA1B,QAAQ6J,UAAY,EACpBnI,EAAA1B,QAAQ8J,YAENpI,EAAA1B,QAAQ+J,OAAQ,GAAM1J,KAAKE,EAAuB,GAAMF,KAAKO,GAC7Dc,EAAA1B,QAAQgK,QAAQ,GAAM3J,KAAKE,EAAIlB,EAAO4B,UAAY,GAAMZ,KAAKO,GAC7Dc,EAAA1B,QAAQgK,QAAQ,GAAM3J,KAAKE,EAAIlB,EAAO4B,WAAY,GAAMZ,KAAKO,EAAIvB,EAAO4B,WACxES,EAAA1B,QAAQgK,OAAQ,GAAM3J,KAAKE,GAAuB,GAAMF,KAAKO,EAAIvB,EAAO4B,WACxES,EAAA1B,QAAQgK,OAAQ,GAAM3J,KAAKE,EAAuB,GAAMF,KAAKO,GAG7Dc,EAAA1B,QAAQ+J,OAAQ,GAAM1J,KAAKE,EAAuB,GAAMF,KAAKO,GAC7Dc,EAAA1B,QAAQgK,QAAQ,GAAM3J,KAAKE,EAAIlB,EAAO4B,WAAY,GAAMZ,KAAKO,EAAIvB,EAAO4B,WACxES,EAAA1B,QAAQ+J,QAAQ,GAAM1J,KAAKE,EAAIlB,EAAO4B,UAAY,GAAMZ,KAAKO,GAC7Dc,EAAA1B,QAAQgK,OAAQ,GAAM3J,KAAKE,GAAuB,GAAMF,KAAKO,EAAIvB,EAAO4B,WAC1ES,EAAA1B,QAAQiK,SAGH9J,WAAWoS,GAChBrG,EAAAxL,QAAQoW,gGC3BZ,MAAAzX,EAAApC,EAAA,GAEAE,EAAAuD,QAAA,MAMEP,YACSqF,EACAE,EACAhG,EACAE,EACA+J,EACAoN,GAAwB,GALxB1W,KAAAmF,MACAnF,KAAAqF,MACArF,KAAAX,QACAW,KAAAT,SACAS,KAAAsJ,QACAtJ,KAAA0W,eAEP1W,KAAKuS,KAAOlN,EAAMrG,EAAO4B,UACzBZ,KAAK4S,KAAOzN,EAAMnG,EAAO4B,qoCCjB7B,MAAA5B,EAAApC,EAAA,GACAyE,EAAAzE,EAAA,GACAqU,EAAArU,EAAA,IACAoU,EAAApU,EAAA,GACAmU,EAAAnU,EAAA,GAEA6L,EAAA7L,EAAA,GACA+Z,EAAA/Z,EAAA,IACAga,EAAAha,EAAA,IAEAiP,EAAAjP,EAAA,GACAoR,EAAApR,EAAA,GAEA2E,EAAA3E,EAAA,GAEAE,EAAAuD,QAAA,MAyBEP,YACSI,EACAK,GADAP,KAAAE,IACAF,KAAAO,IA1BFP,KAAA2E,OAAiB,EACjB3E,KAAA6W,SAAmB,EACnB7W,KAAAsP,OAAS,CACdG,MAAQ,EACRE,OAAQ,EACRJ,IAAQ,EACRG,MAAQ,GAIH1P,KAAA8W,gBAAkB,GAClB9W,KAAA+E,OAAS,CACdE,MAAW,EACXiE,SAAW,EACXlE,OAAW,EACXiF,QAAW,GAELjK,KAAAgS,aAA6B,IAAIhB,EAAA3Q,QAAa,GAAI,IAClDL,KAAAsT,SAAmB,EACnBtT,KAAAqT,iBAA2BlT,KAAKmV,MAAMnV,KAAKoV,IAAI,IAAMvV,KAAKsT,UAC1DtT,KAAA+W,UAAW,EACX/W,KAAAgX,iBAAmB,EACnBhX,KAAAiX,YAA4B,GAOlCjX,KAAKqR,oBAGAvR,SACLE,KAAK2R,OACL3R,KAAK4R,mBACL5R,KAAKkX,QACLlX,KAAKiX,YAAYvS,QAAQ,CAAC5F,EAAG9B,KAC3B8B,EAAEiE,OAAO/C,KAAKE,EAAGF,KAAKO,IACN,IAAZzB,EAAE6F,OACJ3E,KAAKiX,YAAYrS,OAAO5H,EAAG,KAK1B8C,QACL,GAAIE,KAAK+W,UAAY/W,KAAKgX,kBAAoB,EAAG,CAC/C,MAAMG,EAAM9V,EAAAhB,QAAOJ,cAAcC,EAAImB,EAAAhB,QAAOa,OAAOhB,EAC7CkX,EAAM/V,EAAAhB,QAAOJ,cAAcM,EAAIc,EAAAhB,QAAOa,OAAOX,EACnD,IAAI8W,EAAOF,GAAOhX,KAAKqV,IAAI2B,GAAMhX,KAAKqV,IAAI4B,IACtCE,EAAOF,GAAOjX,KAAKqV,IAAI2B,GAAMhX,KAAKqV,IAAI4B,IAI1C,MAAMG,EAAgC,GAAhBpX,KAAKqX,SAAiB,IACtCC,EAAgC,GAAhBtX,KAAKqX,SAAiB,IAC5CH,GAAQE,EACRD,GAAQG,EAERzX,KAAKiX,YAAYvR,KAAK,IAAIkR,EAAAvW,QAAWL,KAAKE,EAAGF,KAAKO,EAAG8W,EAAMC,IAC3DtX,KAAKgX,iBAAmB,EAExBnL,EAAAxL,QAAQqX,gBAEN1X,KAAKgX,iBAIJlX,YAAY6X,GACjB3X,KAAK+W,SAAWY,EAGX7X,OACL,MAAM6I,EAAQ3I,KAAK4X,iBACnB5X,KAAK6X,WAAWlP,GAChB3I,KAAK8X,oBAAoBnP,GAsBzBgO,EAAAtW,QAAUyE,OACV9E,KAAK+X,kBAGCjY,OACFE,KAAKsP,OAAOG,OACVzP,KAAKsP,OAAOC,IAAMvP,KAAKsP,OAAOI,KAChC1P,KAAKE,GAAKF,KAAKqT,iBAEfrT,KAAKE,GAAKF,KAAKsT,UAGftT,KAAKsP,OAAOK,QACV3P,KAAKsP,OAAOC,IAAMvP,KAAKsP,OAAOI,KAChC1P,KAAKE,GAAKF,KAAKqT,iBAEfrT,KAAKE,GAAKF,KAAKsT,UAGftT,KAAKsP,OAAOC,KACVvP,KAAKsP,OAAOG,MAAQzP,KAAKsP,OAAOK,MAClC3P,KAAKO,GAAKP,KAAKqT,iBAEfrT,KAAKO,GAAKP,KAAKsT,UAGftT,KAAKsP,OAAOI,OACV1P,KAAKsP,OAAOG,MAAQzP,KAAKsP,OAAOK,MAClC3P,KAAKO,GAAKP,KAAKqT,iBAEfrT,KAAKO,GAAKP,KAAKsT,UAGnBtT,KAAKsR,iCACLtR,KAAKgY,+BACLhY,KAAKqR,oBAGCvR,iBACN,MAAM6I,EAAQoI,EAAAxI,mBAAmBlH,EAAAhB,QAAOJ,cAAeoB,EAAAhB,QAAOa,QAG9D,OAFAG,EAAA1B,QAAQkO,UAAY,UACpBxM,EAAA1B,QAAQ6L,gBAAgB7C,EAAMoF,QAAQ,KAAM,GAAI,IACzCpF,EAGD7I,WAAW6I,GAEjBtH,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQkO,UAAY,UACpBxM,EAAA1B,QAAQmO,KAAO,iBAEfzM,EAAA1B,QAAQ6L,eAAexL,KAAKE,MAAMF,KAAKO,KAAM,GAAI,IAEjDc,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ6J,UAAY,EACpBnI,EAAA1B,QAAQ+J,OAAOrI,EAAAhB,QAAOa,OAAOhB,EAAGmB,EAAAhB,QAAOa,OAAOX,GAC9Cc,EAAA1B,QAAQgK,OAAOtI,EAAAhB,QAAOa,OAAOhB,EAAKF,KAAK8W,gBAAkB3W,KAAK8X,IAAItP,GAAStH,EAAAhB,QAAOa,OAAOX,EAAKP,KAAK8W,gBAAkB3W,KAAKoV,IAAI5M,IAChItH,EAAA1B,QAAQiK,SAER5J,KAAK6R,mBAGC/R,mBACNuB,EAAA1B,QAAQ6J,UAAY,EACpBnI,EAAA1B,QAAQ8J,YAGNpI,EAAA1B,QAAQ+J,QAAQ,GAAMrI,EAAAhB,QAAOa,OAAOhB,EAAIF,KAAKgS,aAAavR,WAAY,GAAMY,EAAAhB,QAAOa,OAAOX,EAAIP,KAAKgS,aAAatR,YAChHW,EAAA1B,QAAQgK,OAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,EAAIF,KAAKgS,aAAavR,WAAY,GAAMY,EAAAhB,QAAOa,OAAOX,EAAIP,KAAKgS,aAAatR,YAChHW,EAAA1B,QAAQgK,OAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,EAAIF,KAAKgS,aAAavR,UAAY,GAAMY,EAAAhB,QAAOa,OAAOX,EAAIP,KAAKgS,aAAatR,YAChHW,EAAA1B,QAAQgK,QAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,EAAIF,KAAKgS,aAAavR,UAAY,GAAMY,EAAAhB,QAAOa,OAAOX,EAAIP,KAAKgS,aAAatR,YAChHW,EAAA1B,QAAQgK,QAAQ,GAAMtI,EAAAhB,QAAOa,OAAOhB,EAAIF,KAAKgS,aAAavR,WAAY,GAAMY,EAAAhB,QAAOa,OAAOX,EAAIP,KAAKgS,aAAatR,YAClHW,EAAA1B,QAAQiK,SAGF9J,oBAAoB6I,GAC1B,MAAMU,SAAEA,EAAQwB,UAAEA,GAAcoG,EAAA5Q,QAAUmT,KAAKxT,KAAM2I,GACjDU,IACEwB,EACFoG,EAAA5Q,QAAU6X,QAAQ7O,EAAU,WAE5B4H,EAAA5Q,QAAU6X,QAAQ7O,IAKhBvJ,kBACNE,KAAKiX,YAAYvS,QAAQ5F,GAAKA,EAAEgG,KAAK9E,KAAKE,EAAGF,KAAKO,IAG5CT,oBACNE,KAAKmF,IAAMhF,KAAKC,MAAMJ,KAAKO,EAAIvB,EAAO4B,WACtCZ,KAAKqF,IAAMlF,KAAKC,MAAMJ,KAAKE,EAAIlB,EAAO4B,WAGhCd,mBACNE,KAAK+E,OAAOE,MAAQjF,KAAKO,EAAIvB,EAAO4B,UACpCZ,KAAK+E,OAAOmE,SAAWlK,EAAO4B,UAAYZ,KAAK+E,OAAOE,MACtDjF,KAAK+E,OAAOC,OAAShF,KAAKE,EAAIlB,EAAO4B,UACrCZ,KAAK+E,OAAOkF,QAAUjL,EAAO4B,UAAYZ,KAAK+E,OAAOC,OAI/ClF,iCACN,IAAIrC,EACJ,GAAIgL,EAAAnE,YAAYtE,KAAKmF,KAAM,CACzB,GAAInF,KAAKsP,OAAOG,KAAM,EACpBhS,EAAIgL,EAAAnE,YAAYtE,KAAKmF,KAAKnF,KAAKqF,IAAM,KAC5BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,KAAO9U,EAAE4B,QAC1DW,KAAKE,EAAIzC,EAAE8U,KAAO9U,EAAE4B,MAAQW,KAAKgS,aAAavR,UAAY,GAG5D,MAAM+R,EAAcrS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,WAAa,GAAK1B,EAAO4B,WAChF4R,IAAgBxS,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYkO,GAAaxS,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,KAAO9U,EAAE4B,QACpDW,KAAKsP,OAAOI,MAAQ1P,KAAK+E,OAAOE,OAASjF,KAAK+E,OAAOkF,UACzDjK,KAAKE,EAAIzC,EAAE8U,KAAO9U,EAAE4B,MAAQW,KAAKgS,aAAavR,UAAY,IAKhE,MAAMgS,EAActS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,YAAc1B,EAAO4B,WAC5E6R,IAAgBzS,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYmO,GAAazS,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,KAAO9U,EAAE4B,QACpDW,KAAKsP,OAAOC,IAAMvP,KAAK+E,OAAOmE,UAAYlJ,KAAK+E,OAAOkF,UAC1DjK,KAAKE,EAAIzC,EAAE8U,KAAO9U,EAAE4B,MAAQW,KAAKgS,aAAavR,UAAY,IAKlE,GAAIT,KAAKsP,OAAOK,MAAO,EACrBlS,EAAIgL,EAAAnE,YAAYtE,KAAKmF,KAAKnF,KAAKqF,IAAM,KAC5BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,OACjDvS,KAAKE,EAAIzC,EAAE8U,KAAOvS,KAAKgS,aAAavR,UAAY,GAGlD,MAAMiS,EAAcvS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,WAAa,GAAK1B,EAAO4B,WAChF8R,IAAgB1S,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYoO,GAAa1S,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,OAC3CvS,KAAKsP,OAAOI,MAAQ1P,KAAK+E,OAAOE,OAASjF,KAAK+E,OAAOC,SACzDhF,KAAKE,EAAIzC,EAAE8U,KAAOvS,KAAKgS,aAAavR,UAAY,IAKtD,MAAMkS,EAAcxS,KAAKC,OAAOJ,KAAKO,EAAIP,KAAKgS,aAAatR,YAAc1B,EAAO4B,WAC5E+R,IAAgB3S,KAAKmF,MACvB1H,EAAIgL,EAAAnE,YAAYqO,GAAa3S,KAAKqF,IAAM,KAC/BrF,KAAKE,EAAIF,KAAKgS,aAAavR,WAAahD,EAAE8U,OAC3CvS,KAAKsP,OAAOC,IAAMvP,KAAK+E,OAAOmE,UAAYlJ,KAAK+E,OAAOC,SAC1DhF,KAAKE,EAAIzC,EAAE8U,KAAOvS,KAAKgS,aAAavR,UAAY,KAM1D,GAAIgI,EAAAnE,YAAYtE,KAAKmF,IAAM,IACrBnF,KAAKsP,OAAOC,GAAI,EAClB9R,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAGnF,KAAKqF,OAC1BrF,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,KAAOnV,EAAE8B,SAC3DS,KAAKO,EAAI9C,EAAEmV,KAAOnV,EAAE8B,OAASS,KAAKgS,aAAatR,WAAa,GAG9D,MAAMmS,EAAc1S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,UAAY,GAAKzB,EAAO4B,WAC/EiS,IAAgB7S,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG0N,KACrB7S,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,KAAOnV,EAAE8B,SACrDS,KAAKsP,OAAOK,OAAS3P,KAAK+E,OAAOmE,SAAWlJ,KAAK+E,OAAOC,SAC5DhF,KAAKO,EAAI9C,EAAEmV,KAAOnV,EAAE8B,OAASS,KAAKgS,aAAatR,WAAa,IAKlE,MAAMoS,EAAc3S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,WAAazB,EAAO4B,WAC3EkS,IAAgB9S,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG2N,KACrB9S,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,KAAOnV,EAAE8B,SACrDS,KAAKsP,OAAOG,MAAQzP,KAAK+E,OAAOmE,SAAWlJ,KAAK+E,OAAOkF,UAC3DjK,KAAKO,EAAI9C,EAAEmV,KAAOnV,EAAE8B,OAASS,KAAKgS,aAAatR,WAAa,IAMtE,GAAI+H,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAI,CACzBnF,KAAKsP,OAAOI,OACdjS,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAGnF,KAAKqF,OAC1BrF,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,OAClD5S,KAAKO,EAAI9C,EAAEmV,KAAO5S,KAAKgS,aAAatR,WAAa,GAIrD,MAAMqS,EAAc5S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,UAAY,GAAKzB,EAAO4B,WAC/EmS,IAAgB/S,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG4N,KACrB/S,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,OAC5C5S,KAAKsP,OAAOK,OAAS3P,KAAK+E,OAAOE,MAAQjF,KAAK+E,OAAOC,SACzDhF,KAAKO,EAAI9C,EAAEmV,KAAO5S,KAAKgS,aAAatR,WAAa,IAKvD,MAAMsS,EAAc7S,KAAKC,OAAOJ,KAAKE,EAAIF,KAAKgS,aAAavR,WAAazB,EAAO4B,WAC3EoS,IAAgBhT,KAAKqF,MACvB5H,EAAIgL,EAAAnE,YAAYtE,KAAKmF,IAAM,GAAG6N,KACrBhT,KAAKO,EAAIP,KAAKgS,aAAatR,YAAcjD,EAAEmV,OAC5C5S,KAAKsP,OAAOG,MAAQzP,KAAK+E,OAAOE,MAAQjF,KAAK+E,OAAOkF,UACxDjK,KAAKO,EAAI9C,EAAEmV,KAAO5S,KAAKgS,aAAatR,WAAa,KAOnDZ,+BACF2I,EAAA1E,mBAAmB/D,KAAKE,EAAGF,KAAKO,GACjC4D,OAAOC,GAAKA,EAAE+T,mBAAmBnY,KAAKE,EAAGF,KAAKO,EAAGP,KAAKgS,eACtDxM,OAAS,GACRxF,KAAKqS,MAIHvS,MACNE,KAAK2E,OAAQ,EACbqJ,EAAA3N,QAAK6B,aAAaG,SAASd,EAAAlB,QAAY+B,yFCnV3C,MAAAf,EAAAzE,EAAA,GAEAE,EAAAuD,QAAA,MACSP,cACL,MAAMsY,EAAkB/W,EAAAhB,QAAOJ,cAAcC,EACvCmY,EAAkBhX,EAAAhB,QAAOJ,cAAcM,EAC7C,IAAI+X,EACAC,EACJlX,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ6J,UAAY,GACpBnI,EAAA1B,QAAQ8J,YAEN6O,EAAW,GACXC,GAAW,IACXlX,EAAA1B,QAAQ+J,OAAO0O,EAAUE,EAASD,EAAUE,GAC5CA,GAAW,IACXlX,EAAA1B,QAAQgK,OAAOyO,EAAUE,EAASD,EAAUE,GAG5CA,EAAU,IACVlX,EAAA1B,QAAQ+J,OAAO0O,EAAUE,EAASD,EAAUE,GAC5CA,EAAU,IACVlX,EAAA1B,QAAQgK,OAAOyO,EAAUE,EAASD,EAAUE,GAG5CA,EAAW,GACXD,GAAW,IACXjX,EAAA1B,QAAQ+J,OAAO0O,EAAUE,EAASD,EAAUE,GAC5CD,GAAW,IACXjX,EAAA1B,QAAQgK,OAAOyO,EAAUE,EAASD,EAAUE,GAG5CD,EAAU,IACVjX,EAAA1B,QAAQ+J,OAAO0O,EAAUE,EAASD,EAAUE,GAC5CD,EAAU,IACVjX,EAAA1B,QAAQgK,OAAOyO,EAAUE,EAASD,EAAUE,GAC9ClX,EAAA1B,QAAQiK,0FCpCZ,MAAA5K,EAAApC,EAAA,GAEAyE,EAAAzE,EAAA,GAGA6L,EAAA7L,EAAA,GASAE,EAAAuD,QAAA,MAeEP,YACSI,EACAK,EACAiY,EACAC,GAHAzY,KAAAE,IACAF,KAAAO,IACAP,KAAAwY,aACAxY,KAAAyY,aAlBFzY,KAAA0Y,MAAgB,GAChB1Y,KAAA2Y,OAAiB,GACjB3Y,KAAA2E,OAAiB,EAShB3E,KAAA4Y,8BAAwC,EACxC5Y,KAAA6Y,sBAA6C,GAQnD,IAAK,IAAI7b,EAAI,EAAGA,EAAIgD,KAAK4Y,gCAAiC5b,EACxDgD,KAAK6Y,sBAAsB7b,GAAK,CAAEkD,EAAG,KAAMK,EAAG,KAAM4E,IAAK,KAAME,IAAK,MAIjEvF,OAAOkE,EAAiBC,GAC7BjE,KAAK8Y,UAAY9Y,KAAKE,EACtBF,KAAK+Y,UAAY/Y,KAAKO,EACtBP,KAAKE,GAAKF,KAAKwY,WAAaxY,KAAK0Y,MACjC1Y,KAAKO,GAAKP,KAAKyY,WAAazY,KAAK0Y,MACjC1Y,KAAKmF,IAAMhF,KAAKC,MAAMJ,KAAKO,EAAIvB,EAAO4B,WACtCZ,KAAKqF,IAAMlF,KAAKC,MAAMJ,KAAKE,EAAIlB,EAAO4B,WAEtC,MAAMoY,EAAgBhZ,KAAKiZ,mBAE3BjZ,KAAKkZ,8BAEDlZ,KAAKmZ,YAAYnV,EAASC,KAC5BjE,KAAK2E,OAAQ,GAGf3E,KAAK6Y,sBAAsBnU,QAAQ0U,IAC7BpZ,KAAK2E,QACP3E,KAAKqZ,0BAA0BL,EAAeI,GAC9CpZ,KAAKsZ,6BAA6BF,MAGlCpZ,KAAK2E,QACP3E,KAAKqZ,0BAA0BL,GAC/BhZ,KAAKsZ,gCAIFxZ,KAAKkE,EAAiBC,GACvBjE,KAAKE,IAAM8D,GAAWhE,KAAKO,IAAM0D,IAIrC5C,EAAA1B,QAAQ4J,YAAc,UACtBlI,EAAA1B,QAAQ6J,UAAY,EACpBnI,EAAA1B,QAAQ8J,YACRpI,EAAA1B,QAAQyK,IACNpK,KAAKE,EAAImB,EAAAhB,QAAOa,OAAOhB,EAAI8D,EAC3BhE,KAAKO,EAAIc,EAAAhB,QAAOa,OAAOX,EAAI0D,EAC3B,EACA,EACC,EAAI9D,KAAKkK,IAEZhJ,EAAA1B,QAAQiK,UAKF9J,mBACN,MAAO,IAAK2I,EAAAvE,SAAUC,OAAOC,GAC3BjE,KAAKqV,IAAIpR,EAAElE,EAAIF,KAAKE,IAAMlB,EAAO4B,WACjCT,KAAKqV,IAAIpR,EAAE7D,EAAIP,KAAKO,IAAMvB,EAAO4B,WAY7Bd,8BACN,MAAMyZ,GAAyBvZ,KAAKE,EAAIF,KAAK8Y,YAAc9Y,KAAK4Y,8BAAgC,GAC1FY,GAAyBxZ,KAAKO,EAAIP,KAAK+Y,YAAc/Y,KAAK4Y,8BAAgC,GAChG,IAAK,IAAI5b,EAAIgD,KAAK4Y,8BAAgC,EAAG5b,GAAK,IAAKA,EAC7DgD,KAAK6Y,sBAAsB7b,GAAGkD,EAAIF,KAAKE,EAAIqZ,GAAyBvc,EAAI,GACxEgD,KAAK6Y,sBAAsB7b,GAAGuD,EAAIP,KAAKO,EAAIiZ,GAAyBxc,EAAI,GACxEgD,KAAK6Y,sBAAsB7b,GAAGmI,IAAMhF,KAAKC,MAAMJ,KAAK6Y,sBAAsB7b,GAAGuD,EAAIvB,EAAO4B,WACxFZ,KAAK6Y,sBAAsB7b,GAAGqI,IAAMlF,KAAKC,MAAMJ,KAAK6Y,sBAAsB7b,GAAGkD,EAAIlB,EAAO4B,WAIpFd,YAAYkE,EAAiBC,GACnC,OACEjE,KAAKE,EAAI8D,EAAU3C,EAAAhB,QAAOa,OAAOhB,EAAIlB,EAAO4B,WAAaZ,KAAKE,EAAI8D,EAAU3C,EAAAhB,QAAOa,OAAOhB,EAAIlB,EAAO4B,WACrGZ,KAAKO,EAAI0D,EAAU5C,EAAAhB,QAAOa,OAAOX,EAAIvB,EAAO4B,WAAaZ,KAAKO,EAAI0D,EAAU5C,EAAAhB,QAAOa,OAAOX,EAAIvB,EAAO4B,UAIjGd,0BAA0BkZ,EAAwBS,GACnDA,IACHA,EAAQzZ,MAGVgZ,EAActU,QAAQN,IAElBqV,EAAMvZ,GAAKkE,EAAElE,EAAIkE,EAAE4N,aAAavR,WAChCgZ,EAAMvZ,GAAKkE,EAAElE,EAAIkE,EAAE4N,aAAavR,WAChCgZ,EAAMlZ,GAAK6D,EAAE7D,EAAI6D,EAAE4N,aAAatR,YAChC+Y,EAAMlZ,GAAK6D,EAAE7D,EAAI6D,EAAE4N,aAAatR,aAEhCV,KAAK2E,OAAQ,EACbP,EAAEsV,WAAW1Z,KAAK2Z,gBAKhB7Z,6BAA6B2Z,GAC9BA,IACHA,EAAQzZ,MAGV,MAAMvC,EAAIgL,EAAAnE,YAAYmV,EAAMtU,KAAKsU,EAAMpU,KACnC5H,IACAA,EAAEic,WAAW1Z,KAAK2Z,aAClB3Z,KAAK2E,OAAQ,EACTlH,EAAEiZ,eACJjO,EAAAnE,YAAYmV,EAAMtU,KAAKsU,EAAMpU,KAAO,OAKpCvF,YACN,OAAOE,KAAK2Y,wFC3JhB,MAAA3Z,EAAApC,EAAA,GAGAyE,EAAAzE,EAAA,GACA2E,EAAA3E,EAAA,GAEAE,EAAAuD,QAAA,MACSP,SAGAA,QAIAA,UAIAA,SACLyB,EAAAlB,QAAYiC,QAAQW,SACpBjD,KAAK4Z,gBAGC9Z,gBACNuB,EAAA1B,QAAQ8J,YACNpI,EAAA1B,QAAQkO,UAAY,UACpBxM,EAAA1B,QAAQmO,KAAO,iBAEfzM,EAAA1B,QAAQ6L,SAAS,SAAUxM,EAAOM,aAAe,EAAI,GAAIN,EAAOQ,cAAgB,EAAI,IACpF6B,EAAA1B,QAAQmO,KAAO,iBACfzM,EAAA1B,QAAQ6L,SAAS,eAAmBxM,EAAOM,aAAe,EAAI,GAAIN,EAAOQ,cAAgB,EAAI,IAC7F6B,EAAA1B,QAAQ6L,SAAS,kBAAmBxM,EAAOM,aAAe,EAAI,GAAIN,EAAOQ,cAAgB,EAAI,IAC/F6B,EAAA1B,QAAQiK,0FC/BZ,MAAArI,EAAA3E,EAAA,GAEAE,EAAAuD,QAAA,MAAAP,cACUE,KAAA6Z,aAA2BtY,EAAAlB,QAAYsD,QAExC7D,WACL,OAAOE,KAAK6Z,aAEP/Z,SAASgP,GACd9O,KAAK6Z,aAAaC,KAAKhL,GACvB,MAAMF,EAAgB5O,KAAK6Z,aAG3B,OAFA/K,EAAUiL,MAAMnL,GAChB5O,KAAK6Z,aAAe/K,EACb9O,KAAK6Z,aAGP/Z,SACLE,KAAK6Z,aAAa9W,SAEbjD,SACLE,KAAK6Z,aAAa5W,yCCpBtB,IAAK+W,mDAAL,SAAKA,GACHA,IAAA,iBADF,CAAKA,MAAU,KAIfld,EAAAuD,QAAe2Z","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import AudioLoader from '@app/audio/AudioLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport FrameRate from '../FrameRate'\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0 // 0.0 to 1.0\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  public static togglePause(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PAUSED) {\n      Game.stateManager.setState(GAME_STATES.PLAYING)\n    } else {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n  }\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n    AudioLoader.load(percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop()\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const audioWeight = 1.0 // TODO: Audio is 100% of all loaded assets for now\n    if (asset === GameAssets.Audio) {\n      Game.loadedPercentage = audioWeight * percentage\n    }\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(): void {\n    this.update()\n\n    if (FrameRate.nextFrameRenderingShouldBeSkipped() === false) {\n      this.render()\n    }\n\n    FrameRate.calculateFrameRate()\n\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    FrameRate.drawFPS() // TODO: Remove this, used just for debugging\n  }\n}\n","import GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStatePaused from './GameStatePaused'\n\n// TODO: Add a IGameState type definition\nconst GAME_STATES = {\n  LOADING   : new GameStateLoading(),\n  MAIN_MENU : new GameStateMainMenu(),\n  PLAYING   : new GameStatePlaying(),\n  PAUSED    : new GameStatePaused(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport ConcreateEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport IMap from './IMap'\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\nexport const enemies: Enemy[] = []\n\nexport function getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n  return enemies.filter(e => e.isOnScreen(playerX, playerY))\n}\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public update(): void {\n    enemies.forEach((e, i) => {\n      e.update(this.player, enemies)\n      if (e.alive === false) {\n        enemies.splice(i, 1) // Remove the enemy\n      }\n    })\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map.gameObjects[row][col])\n      }\n    }\n\n    map.enemies.forEach(e => enemies.push(new ConcreateEnemy(e.x, e.y, e.healthPercentage)))\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/enemy_hit_1.mp3'),\n      load('./audio/enemy_hit_2.mp3'),\n      load('./audio/enemy_hit_3.mp3'),\n      load('./audio/enemy_hit_4.mp3'),\n      load('./audio/enemy_hit_5.mp3'),\n\n      load('./audio/enemy_die_1.mp3'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.SMG[0] = soundFxFiles[0]\n    this.SMG[1] = soundFxFiles[1]\n    this.SMG[2] = soundFxFiles[2]\n    this.SMG[3] = soundFxFiles[3]\n    this.SMG[4] = soundFxFiles[4]\n\n    this.CRATE_HIT[0] = soundFxFiles[5]\n\n    this.ENEMY_HIT[0] = soundFxFiles[6]\n    this.ENEMY_HIT[1] = soundFxFiles[7]\n    this.ENEMY_HIT[2] = soundFxFiles[8]\n    this.ENEMY_HIT[3] = soundFxFiles[9]\n    this.ENEMY_HIT[4] = soundFxFiles[10]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[11]\n    setLoadedPercentage(1.0)\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playCrateHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","export default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}","export default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   * // TODO: Make casting possible between any 2 arbitrary points, not just from 1 point to off-screen\n   */\n  public static cast(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const yInt = p.deltas.dyBottom\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta)\n      }\n    } else { // North\n      const yInt = p.deltas.dyTop\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: Point, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.halfWidth) || (yIntercept > Canvas.halfHeight)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth + p.deltas.dxRight + tileStepX,\n          Canvas.halfHeight + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.halfHeight) || (xIntercept > Canvas.halfWidth)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth + xIntercept,\n          Canvas.halfHeight + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: Point, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Canvas.halfWidth) || (yIntercept > Canvas.halfHeight)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth + tileStepX + p.deltas.dxRight,\n          Canvas.halfHeight - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.halfHeight) || (xIntercept > Canvas.halfWidth)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth + xIntercept,\n          Canvas.halfHeight - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static getInterceptPointNW(p: Point, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.halfWidth) || (yIntercept > Canvas.halfHeight)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth - tileStepX - p.deltas.dxLeft,\n          Canvas.halfHeight - yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Canvas.halfHeight) || (xIntercept > Canvas.halfWidth)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth - xIntercept,\n          Canvas.halfHeight - tileStepY - p.deltas.dyTop,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Canvas.halfWidth) || (yIntercept > Canvas.halfHeight)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth - p.deltas.dxLeft - tileStepX,\n          Canvas.halfHeight + yIntercept,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Canvas.halfHeight) || (-xIntercept > Canvas.halfWidth)) {\n        break\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(\n          Canvas.halfWidth + xIntercept,\n          Canvas.halfHeight + p.deltas.dyBottom + tileStepY,\n          2, 0, (2 * Math.PI)\n        )\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nlet lastFrameTime: number\nlet frameDeltaTime: number\nlet frameOverstepTime: number = 0\n\nconst ONE_FRAME_LENGTH_IN_SECONDS = 0.01667\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\nlet skipNextFrameRendering = false\n\nexport default class FrameRate {\n  public static nextFrameRenderingShouldBeSkipped(): boolean {\n    return skipNextFrameRendering\n  }\n\n  public static restart() {\n    lastFrameTime = null\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(): void {\n    if (!lastFrameTime) {\n      lastFrameTime = performance.now()\n      FPS = 0\n    } else {\n      const now = performance.now()\n      frameDeltaTime = (now - lastFrameTime) / 1000\n      if (frameDeltaTime > ONE_FRAME_LENGTH_IN_SECONDS) {\n        frameOverstepTime += frameDeltaTime - ONE_FRAME_LENGTH_IN_SECONDS\n      }\n\n      FPS_ARR.unshift(1 / (frameDeltaTime + frameOverstepTime))\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n\n      if (frameOverstepTime >= ONE_FRAME_LENGTH_IN_SECONDS) {\n        frameOverstepTime = frameOverstepTime - ONE_FRAME_LENGTH_IN_SECONDS\n        skipNextFrameRendering = true\n      } else {\n        skipNextFrameRendering = false\n      }\n\n      lastFrameTime = now\n    }\n  }\n\n  public static drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationCounter: number = 0\n  private animationInterval: number = 100\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationCounter = (this.animationCounter + 1) % this.animationInterval\n    if (this.animationCounter >= this.animationInterval / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press any key to start', CONFIG.CANVAS_WIDTH / 2 - 132, CONFIG.CANVAS_HEIGHT / 2 - 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection(): void {\n    Game.stateManager.setState(GAME_STATES.PLAYING)\n  }\n}\n","import IGameState from './IGameState'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePlaying implements IGameState {\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n  }\n\n  public exit(nextState: IGameState): void {\n    if (nextState !== GAME_STATES.PAUSED) {\n      window.onblur = null\n    }\n  }\n\n  public update(): void {\n    Canvas.updateMousePosition()\n    Gamepads.update(this.player)\n    this.player.update()\n    this.map.update()\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n  }\n\n  private startNewGame(): void {\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n}\n","import Game from '@app/infrastructure/game/Game'\nimport FrameRate from '@app/infrastructure/FrameRate'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    document.addEventListener('keydown', e => {\n      // TODO: Move Player logic to Player class\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.ESC:\n        case KEYBOARD_KEYS.p:\n          Game.togglePause()\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\n// TODO: This class is useless?\nexport default class Grid {\n  public rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  public cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n\nexport interface Directions {\n    N  : (any | null)\n    NE : (any | null)\n    E  : (any | null)\n    SE : (any | null)\n    S  : (any | null)\n    SW : (any | null)\n    W  : (any | null)\n    NW : (any | null)\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance, angleBetweenPoints } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, drawPath } from '@app/infrastructure/Pathfinding'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default class ConcreateEnemy extends Enemy {\n  constructor(\n    x: number,\n    y: number,\n    healthPercentage: number\n  ) {\n    super(x, y, new CollisionBox(16, 16), 1, healthPercentage)\n    this.updateMapPosition()\n  }\n\n  public update(player: Player, enemies: Enemy[]): void {\n    this.adjustCollisionWithGameObjects()\n    this.adjustCollisionWithOtherEnemies(enemies)\n    this.distanceFromPlayer = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   }\n    )\n    this.determineIfThereAreObstaclesBetweenThisEnemyAndThePlayer(player)\n    this.findPathToPlayer(player)\n    this.move()\n    this.updateTileDeltas()\n  }\n\n  public draw(player: Player): void {\n    this.drawCollisionBox(player) // Just for debugging\n    // this.drawRayToPlayer(player) // TODO: Just for debugging\n    drawPath(this.pathToPlayer, this.collisionBox, player, this.getHealthColor()) // TODO: Just for debugging\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.alive = false\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  private findPathToPlayer(player: Player): void {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      this.pathToPlayer = generatePathNodes(this.row, this.col, this.collisionBox)\n      this.moveTowardsPlayer(player)\n    }\n    else {\n      if (this.pathToPlayer) {\n        this.pathToPlayer = null\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private moveTowardsPlayer(player: Player): void {\n    if (this.distanceFromPlayer > 1) {\n      this.moveTowards(player.x, player.y)\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private move(): void {\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  private determineIfThereAreObstaclesBetweenThisEnemyAndThePlayer(player: Player): void {\n    const angleBetweenPlayerAndEnemy = angleBetweenPoints(\n      { x: this.x,   y: this.y   },\n      { x: player.x, y: player.y }\n    )\n    const { hitPoint } = Raycaster.cast(player, angleBetweenPlayerAndEnemy)\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy = (\n      this.distanceFromPlayer > pointToPointDistance(hitPoint, { x: 0, y: 0 })\n    )\n\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { Directions } from '@app/domain/Grid'\nimport Point from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport GameObject from '@app/domain/objects/GameObject'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\n\n/**\n *   o      o     o      o   o     o     o\n *     ----         ----       ---- ----\n *    |    |       |    |     |    |    |\n *     ----       o ---- o     ---- ----\n *   o      o      |    |    o     o     o\n *                  ----\n *                o      o\n *\n *      o     o     o          o      o\n *        ---- ----              ----\n *       |    |    |      o   o |    |\n *      o ---- ---- o       ---- ----\n *       |    | o          |    | o   o\n *        ----              ----\n *      o      o          o      o\n */\n// TODO: cache path nodes for same collision box dimensions || don't generate path nodes every frame\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): Point[] {\n  const path: Point[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!gameObjects[row] || !gameObjects[row][col]) { continue }\n      generateNodeAroundGameObject(path, gameObjects[row][col], cBox)\n    }\n  }\n\n  return path\n}\n\nfunction generateNodeAroundGameObject(path: Point[], o: GameObject, cBox: CollisionBox): void {\n  const neighbours: Directions = {\n    N  : gameObjects[o.row - 1] ? gameObjects[o.row - 1][o.col    ] : null,\n    NE : gameObjects[o.row - 1] ? gameObjects[o.row - 1][o.col + 1] : null,\n    E  : gameObjects[o.row    ] ? gameObjects[o.row    ][o.col + 1] : null,\n    SE : gameObjects[o.row + 1] ? gameObjects[o.row + 1][o.col + 1] : null,\n    S  : gameObjects[o.row + 1] ? gameObjects[o.row + 1][o.col    ] : null,\n    SW : gameObjects[o.row + 1] ? gameObjects[o.row + 1][o.col - 1] : null,\n    W  : gameObjects[o.row    ] ? gameObjects[o.row    ][o.col - 1] : null,\n    NW : gameObjects[o.row - 1] ? gameObjects[o.row - 1][o.col - 1] : null,\n  }\n\n  let nodeNE = generateNodeNE(o, neighbours, cBox)\n  let nodeSE = generateNodeSE(o, neighbours, cBox)\n  let nodeSW = generateNodeSW(o, neighbours, cBox)\n  let nodeNW = generateNodeNW(o, neighbours, cBox)\n\n  if (nodeNE && (nodeNE.x < 0 || nodeNE.y < 0)) { nodeNE = null }\n  if (nodeSE && (nodeSE.x < 0 || nodeSE.y < 0)) { nodeSE = null }\n  if (nodeSW && (nodeSW.x < 0 || nodeSW.y < 0)) { nodeSW = null }\n  if (nodeNW && (nodeNW.x < 0 || nodeNW.y < 0)) { nodeNW = null }\n\n  path.forEach(node => {\n    if (nodeNE && (node.x === nodeNE.x && node.y === nodeNE.y)) { nodeNE = null }\n    if (nodeSE && (node.x === nodeSE.x && node.y === nodeSE.y)) { nodeSE = null }\n    if (nodeSW && (node.x === nodeSW.x && node.y === nodeSW.y)) { nodeSW = null }\n    if (nodeNW && (node.x === nodeNW.x && node.y === nodeNW.y)) { nodeNW = null }\n  })\n\n  if (nodeNE) { path.push(nodeNE) }\n  if (nodeSE) { path.push(nodeSE) }\n  if (nodeSW) { path.push(nodeSW) }\n  if (nodeNW) { path.push(nodeNW) }\n}\n\nfunction generateNodeNE(o: GameObject, neighbours: Directions, cBox: CollisionBox): Point {\n  if (neighbours.NE) {\n    return null\n  }\n  else {\n    if (!neighbours.N && !neighbours.E) {\n      return {\n        x: o.mapX + o.width + cBox.halfWidth,\n        y: o.mapY - cBox.halfHeight,\n      }\n    }\n    if (neighbours.N && !neighbours.E) {\n      return {\n        x: o.mapX + o.width + cBox.halfWidth,\n        y: o.mapY,\n      }\n    }\n    if (!neighbours.N && neighbours.E) {\n      return {\n        x: o.mapX + o.width,\n        y: o.mapY - cBox.halfHeight,\n      }\n    }\n  }\n}\nfunction generateNodeSE(o: GameObject, neighbours: Directions, cBox: CollisionBox): Point {\n  if (neighbours.SE) {\n    return null\n  }\n  else {\n    if (!neighbours.S && !neighbours.E) {\n      return {\n        x: o.mapX + o.width  + cBox.halfWidth,\n        y: o.mapY + o.height + cBox.halfHeight,\n      }\n    }\n    if (neighbours.S && !neighbours.E) {\n      return {\n        x: o.mapX + o.width  + cBox.halfWidth,\n        y: o.mapY + o.height,\n      }\n    }\n    if (!neighbours.S && neighbours.E) {\n      return {\n        x: o.mapX + o.width,\n        y: o.mapY + o.height + cBox.halfHeight,\n      }\n    }\n  }\n}\nfunction generateNodeSW(o: GameObject, neighbours: Directions, cBox: CollisionBox): Point {\n  if (neighbours.SW) {\n    return null\n  }\n  else {\n    if (!neighbours.S && !neighbours.W) {\n      return {\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY + o.height + cBox.halfHeight,\n      }\n    }\n    if (neighbours.S && !neighbours.W) {\n      return {\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY + o.height,\n      }\n    }\n    if (!neighbours.S && neighbours.W) {\n      return {\n        x: o.mapX,\n        y: o.mapY + o.height + cBox.halfHeight,\n      }\n    }\n  }\n}\nfunction generateNodeNW(o: GameObject, neighbours: Directions, cBox: CollisionBox): Point {\n  if (neighbours.NW) {\n    return null\n  }\n  else {\n    if (!neighbours.N && !neighbours.W) {\n      return {\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY - cBox.halfHeight,\n      }\n    }\n    if (neighbours.N && !neighbours.W) {\n      return {\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY,\n      }\n    }\n    if (!neighbours.N && neighbours.W) {\n      return {\n        x: o.mapX,\n        y: o.mapY - cBox.halfHeight,\n      }\n    }\n  }\n}\n\nexport function drawPath(path: Point[], cBox: CollisionBox, player: Player, color: string) {\n  if (path) {\n    path.forEach(node => drawNode(node, cBox, player, color))\n  }\n}\n\nfunction drawNode(node: Point, cBox: CollisionBox, player: Player, color: string): void {\n  // context.strokeStyle = color\n  // context.lineWidth = 0.1\n  // context.beginPath()\n  //   // Since this is just for debugging purposes, there is no need to\n  //   // optimize/cache the vertex calculations.\n  //   context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - cBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - cBox.halfHeight)\n  //   context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + cBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - cBox.halfHeight)\n  //   context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + cBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + cBox.halfHeight)\n  //   context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - cBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + cBox.halfHeight)\n  //   context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - cBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - cBox.halfHeight)\n  // context.stroke()\n\n  // context.beginPath()\n  //   context.arc(\n  //     Canvas.center.x + (node.x - player.x),\n  //     Canvas.center.y + (node.y - player.y),\n  //     1,\n  //     0,\n  //     (2 * Math.PI)\n  //   )\n  // context.stroke()\n}\n\nexport function findShortestPath(): void {\n\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Point from '@app/infrastructure/geometry/Point'\nimport Player from '@app/domain/player/Player'\n\nexport default abstract class Enemy {\n  public alive: boolean = true\n  public maxHealth: number = 100\n  public health: number\n\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n\n  protected maxSpeedDiagonal: number\n\n  protected distanceFromPlayer: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathToPlayer: Point[]\n\n  constructor(\n    public x: number,\n    public y: number,\n    public collisionBox: CollisionBox,\n    protected maxSpeed: number,\n    healthPercentage: number\n  ) {\n    this.initializeHealth(healthPercentage)\n\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed)\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player, enemies: Enemy[]): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    return (\n      Math.abs(this.x - playerX) < (CONFIG.CANVAS_WIDTH  / 2) + CONFIG.TILE_SIZE &&\n      Math.abs(this.y - playerY) < (CONFIG.CANVAS_HEIGHT / 2) + CONFIG.TILE_SIZE\n    )\n  }\n\n  public collidesWithPlayer(playerX: number, playerY: number, playerCollisionBox: CollisionBox): boolean {\n    return (\n      this.x - this.collisionBox.halfWidth  < playerX + playerCollisionBox.halfWidth  &&\n      this.x + this.collisionBox.halfWidth  > playerX - playerCollisionBox.halfWidth  &&\n      this.y - this.collisionBox.halfHeight < playerY + playerCollisionBox.halfHeight &&\n      this.y + this.collisionBox.halfHeight > playerY - playerCollisionBox.halfHeight\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n\n  protected collidesWithEnemy(enemyX: number, enemyY: number, enemyCollisionBox: CollisionBox): boolean {\n    return (\n      this.x - this.collisionBox.halfWidth  < enemyX + enemyCollisionBox.halfWidth  &&\n      this.x + this.collisionBox.halfWidth  > enemyX - enemyCollisionBox.halfWidth  &&\n      this.y - this.collisionBox.halfHeight < enemyY + enemyCollisionBox.halfHeight &&\n      this.y + this.collisionBox.halfHeight > enemyY - enemyCollisionBox.halfHeight\n    )\n  }\n\n  protected adjustCollisionWithOtherEnemies(enemies: Enemy[]): void {\n    enemies.forEach(e => {\n      if (this !== e && this.collidesWithEnemy(e.x, e.y, e.collisionBox)) {\n        let intersectionX: number\n        let intersectionY: number\n        if (this.x < e.x) {\n          intersectionX = (this.x + this.collisionBox.halfWidth) - (e.x - e.collisionBox.halfWidth)\n        } else if (this.x > e.x) {\n          intersectionX = (e.x + e.collisionBox.halfWidth) - (this.x - this.collisionBox.halfWidth)\n        }\n        if (this.y < e.y) {\n          intersectionY = (this.y + this.collisionBox.halfHeight) - (e.y - e.collisionBox.halfHeight)\n        } else if (this.y > e.y) {\n          intersectionY = (e.y + e.collisionBox.halfHeight) - (this.y - this.collisionBox.halfHeight)\n        }\n        if (!intersectionX || intersectionX > intersectionY) {\n          if (this.y < e.y) {\n            e.y += intersectionY\n          } else {\n            e.y -= intersectionY\n          }\n        } else if (!intersectionY || intersectionX < intersectionY) {\n          if (this.x < e.x) {\n            e.x += intersectionX\n          } else {\n            e.x -= intersectionX\n          }\n        }\n      }\n    })\n  }\n\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.10) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.20) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.30) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.40) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.50) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.60) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.70) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.80) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.90) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n\n  private initializeHealth(healthPercentage: number): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playCrateHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport { gameObjects, getEnemiesOnScreen } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\nimport Game from '@app/infrastructure/game/Game'\nimport GameStateManager from '@app/infrastructure/game/game_states/GameStateManager'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\n\nexport default class Player {\n  public alive: boolean = true\n  public rotation: number = 0\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public row: number\n  public col: number\n  public sightLineLength = 10\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  private collisionBox: CollisionBox = new CollisionBox(12, 12)\n  private maxSpeed: number = 3\n  private maxSpeedDiagonal: number = Math.round(Math.sin(45) * this.maxSpeed)\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n  )\n  {\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.move()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = (Canvas.mousePosition.x - Canvas.center.x)\n      const dy = (Canvas.mousePosition.y - Canvas.center.y)\n      let xVel = dx / ( Math.abs(dx) + Math.abs(dy) )\n      let yVel = dy / ( Math.abs(dx) + Math.abs(dy) )\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    // this.drawPlayerVisionRay(theta - 0.45)\n    // this.drawPlayerVisionRay(theta - 0.4)\n    // this.drawPlayerVisionRay(theta - 0.35)\n    // this.drawPlayerVisionRay(theta - 0.3)\n    // this.drawPlayerVisionRay(theta - 0.25)\n    // this.drawPlayerVisionRay(theta - 0.2)\n    // this.drawPlayerVisionRay(theta - 0.15)\n    // this.drawPlayerVisionRay(theta - 0.1)\n    // this.drawPlayerVisionRay(theta - 0.05)\n    // this.drawPlayerVisionRay(theta + 0.05)\n    // this.drawPlayerVisionRay(theta + 0.1)\n    // this.drawPlayerVisionRay(theta + 0.15)\n    // this.drawPlayerVisionRay(theta + 0.2)\n    // this.drawPlayerVisionRay(theta + 0.25)\n    // this.drawPlayerVisionRay(theta + 0.3)\n    // this.drawPlayerVisionRay(theta + 0.35)\n    // this.drawPlayerVisionRay(theta + 0.4)\n    // this.drawPlayerVisionRay(theta + 0.45)\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  private move(): void {\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.adjustCollisionWithGameObjects()\n    this.checkForCollisionWithEnemies()\n    this.updateMapPosition()\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n      context.fillStyle = '#00AA00'\n      context.font = '10px Monospace'\n\n      context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n      context.strokeStyle = '#523DA5'\n      context.lineWidth = 2\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(Canvas.center.x + (this.sightLineLength * Math.cos(theta)), Canvas.center.y + (this.sightLineLength * Math.sin(theta)))\n    context.stroke()\n\n    this.drawCollisionBox() // Just for debugging\n  }\n\n  private drawCollisionBox() {\n    context.lineWidth = 1\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // cache the vertex calculations.\n      context.moveTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach(p => p.draw(this.x, this.y))\n  }\n\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Generalize collision physics\n  private adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  private checkForCollisionWithEnemies(): void {\n    if (getEnemiesOnScreen(this.x, this.y)\n      .filter(e => e.collidesWithPlayer(this.x, this.y, this.collisionBox))\n      .length > 0) {\n        this.die()\n      }\n  }\n\n  private die(): void {\n    this.alive = false\n    Game.stateManager.setState(GAME_STATES.PAUSED)\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { gameObjects, enemies } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        o.takeDamage(this.getDamage())\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","\nenum GameAssets {\n  Audio,\n}\n\nexport default GameAssets"],"sourceRoot":""}
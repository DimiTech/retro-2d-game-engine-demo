{"version":3,"file":"app.js","mappings":"wGAAA,gBAEA,gBAAqBA,GACnB,OAAO,IAAIC,SAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAU,IAAIC,eACpBD,EAAQE,KAAK,MAAON,GAAK,GACzBI,EAAQG,aAAe,cACvBH,EAAQI,OAAS,KACf,UAAQC,gBAAgBL,EAAQM,UAAUC,GACjCT,EAAQS,IACf,EAEJP,EAAQQ,MAAM,GAElB,C,gECdA,MAAMC,EAAwB,IAAIC,aAElC,UAAeD,C,kECFf,gBAEA,gBACSE,kBAAkBC,SACjB,UAAQC,KAAKD,EACrB,E,gECLF,MAAqBE,EAIDC,yBAChB,OAAOC,KAAKC,YACd,CACkBF,uBAAYG,GACxBA,GAAO,GAAKA,GAAO,IACrBF,KAAKC,aAAeC,EAExB,CAEkBC,2BAChB,OAAOH,KAAKI,cACd,CACkBD,yBAAcD,GAC1BA,GAAO,GAAKA,GAAO,IACrBF,KAAKI,eAAiBF,EAE1B,EApBF,YACiB,EAAAD,aAA0B,GAC1B,EAAAG,eAA0B,G,kECF3C,gBACA,UACA,UAEA,MAAqBC,EAoBZV,kBAAkBW,GACvB,MAAMC,EAAsB,CAC1B,EAAAV,KAAK,8BAEL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBACL,EAAAA,KAAK,qBAEL,EAAAA,KAAK,2BAEL,EAAAA,KAAK,4BACL,EAAAA,KAAK,4BACL,EAAAA,KAAK,4BACL,EAAAA,KAAK,4BACL,EAAAA,KAAK,4BAEL,EAAAA,KAAK,8BACL,EAAAA,KAAK,8BACL,EAAAA,KAAK,iCAEL,EAAAA,KAAK,2BACL,EAAAA,KAAK,2BACL,EAAAA,KAAK,2BAEL,EAAAA,KAAK,6BACL,EAAAA,KAAK,6BACL,EAAAA,KAAK,8BAIDW,QAAqB3B,QAAQ4B,IAAIF,GAEvCP,KAAKU,aAAa,GAAKF,EAAa,GAEpCR,KAAKW,IAAI,GAAKH,EAAa,GAC3BR,KAAKW,IAAI,GAAKH,EAAa,GAC3BR,KAAKW,IAAI,GAAKH,EAAa,GAC3BR,KAAKW,IAAI,GAAKH,EAAa,GAC3BR,KAAKW,IAAI,GAAKH,EAAa,GAE3BR,KAAKY,UAAU,GAAKJ,EAAa,GAEjCR,KAAKa,WAAW,GAAKL,EAAa,GAClCR,KAAKa,WAAW,GAAKL,EAAa,GAClCR,KAAKa,WAAW,GAAKL,EAAa,GAClCR,KAAKa,WAAW,GAAKL,EAAa,IAClCR,KAAKa,WAAW,GAAKL,EAAa,IAElCF,EAAoB,IAEpBN,KAAKc,aAAa,GAAKN,EAAa,IACpCR,KAAKc,aAAa,GAAKN,EAAa,IAEpCR,KAAKe,kBAAkB,GAAKP,EAAa,IAEzCR,KAAKgB,UAAU,GAAKR,EAAa,IACjCR,KAAKgB,UAAU,GAAKR,EAAa,IACjCR,KAAKgB,UAAU,GAAKR,EAAa,IAEjCR,KAAKiB,YAAY,GAAKT,EAAa,IACnCR,KAAKiB,YAAY,GAAKT,EAAa,IACnCR,KAAKiB,YAAY,GAAKT,EAAa,IAEnCF,EAAoB,EACtB,CAEOX,yBACL,MAAMuB,EAAY,UAAQC,qBAC1BD,EAAU3B,OAASS,KAAKU,aAAa,GAErC,MAAMU,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,OACZ,CAEO/B,iBACL,MAAMuB,EAAY,UAAQC,qBAC1BD,EAAU3B,OAASS,KAAKW,IAAIX,KAAK2B,WAEjC,MAAMP,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAA8B,GAAtB,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,QACV1B,KAAK2B,YAAc3B,KAAK2B,UAAY3B,KAAKW,IAAIiB,MAC/C,CAEOjC,uBACL,IAA8B,IAA1BK,KAAK6B,iBACP,OAEF,MAAMX,EAAY,UAAQC,qBAC1BD,EAAU3B,OAASS,KAAKa,WAAWb,KAAK8B,kBAExC,MAAMV,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,QACV1B,KAAK8B,mBAAqB9B,KAAK8B,iBAAmB9B,KAAKa,WAAWe,OAElE5B,KAAK6B,kBAAmB,EACxBE,YAAW,KAAQ/B,KAAK6B,kBAAmB,CAAI,GAAI,IACrD,CAEOlC,yBACL,MAAMuB,EAAY,UAAQC,qBAEpBa,EAAcC,KAAKC,MAAMD,KAAKE,SAAWnC,KAAKc,aAAac,QACjEV,EAAU3B,OAASS,KAAKc,aAAakB,GAErC,MAAMZ,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,OACZ,CAEO/B,6BACL,MAAMuB,EAAY,UAAQC,qBAE1BD,EAAU3B,OAASS,KAAKe,kBAAkB,GAE1C,MAAMK,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,OACZ,CAEO/B,sBACL,IAA6B,IAAzBK,KAAKoC,gBACP,OAEF,MAAMlB,EAAY,UAAQC,qBACpBa,EAAcC,KAAKC,MAAMD,KAAKE,SAAWnC,KAAKgB,UAAUY,QAC9DV,EAAU3B,OAASS,KAAKgB,UAAUgB,GAElC,MAAMZ,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,QAEV1B,KAAKoC,iBAAkB,EACvBL,YAAW,KAAQ/B,KAAKoC,iBAAkB,CAAI,GAAI,IACpD,CAEOzC,wBACL,MAAMuB,EAAY,UAAQC,qBAEpBa,EAAcC,KAAKC,MAAMD,KAAKE,SAAWnC,KAAKiB,YAAYW,QAChEV,EAAU3B,OAASS,KAAKiB,YAAYe,GAEpC,MAAMZ,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,OACZ,CAEO/B,qBACL,MAAMuB,EAAY,UAAQC,qBAC1BD,EAAU3B,OAASS,KAAKY,UAAU,GAElC,MAAMQ,EAAW,UAAQC,aACzBD,EAASE,KAAKC,MAAQ,UAAMpB,cAC5Be,EAAUM,QAAQJ,GAElBA,EAASI,QAAQ,UAAQC,aAEzBP,EAAUQ,OACZ,EAlNF,YACiB,EAAAhB,aAA8B,GAE9B,EAAAC,IAAqB,GACrB,EAAAgB,UAAY,EAEZ,EAAAf,UAA2B,GAE3B,EAAAC,WAA4B,GAC5B,EAAAiB,iBAAmB,EACnB,EAAAD,kBAA4B,EAE5B,EAAAf,aAA8B,GAC9B,EAAAC,kBAAmC,GAEnC,EAAAC,UAA2B,GAC3B,EAAAoB,iBAA2B,EAE3B,EAAAnB,YAA6B,E,kECrB9C,gBAMA,8BASY,KAAAoB,kBAAmB,CAyB/B,CArBSC,mBACL,GAAItC,KAAKuC,mBAAqBvC,KAAKqC,iBACjC,OAGFrC,KAAKwC,kBAAoBxC,KAAKwC,kBAAoB,UAASC,kBAC3D,MAAMC,EAA8B1C,KAAKwC,kBAAoBxC,KAAK2C,gBAClE3C,KAAK4C,wBAA0BX,KAAKC,MAAMQ,EAA8B1C,KAAK6C,4BAA8B7C,KAAK6C,2BAEhH7C,KAAKuC,kBAAoBG,GAA+B,CAC1D,CAEOI,iBACL9C,KAAKuC,mBAAoB,EACzBvC,KAAKwC,kBAAoB,EACzBxC,KAAK4C,wBAA0B,CACjC,CAEOG,KAAKC,EAAaC,GACvBjD,KAAKkD,OAAOH,KAAKC,EAAGC,EAAmBjD,KAAK4C,wBAC9C,E,eCxCF,IAAKO,E,iDAAL,SAAKA,GACH,cACA,qBACD,CAHD,CAAKA,IAAAA,EAAe,KAKpB,UAAeA,C,kECLf,gBAEA,UACA,UACA,UACA,UAEA,UACA,UAGA,gBAqDEC,YACSC,EACAC,EACAC,EACCC,EACRC,GAJO,KAAAJ,EAAAA,EACA,KAAAC,EAAAA,EACA,KAAAC,aAAAA,EACC,KAAAC,MAAAA,EAxDF,KAAAE,kBAAoB,EACrB,KAAAC,MAAkB,GAClB,KAAAC,MAAkB,GAQlB,KAAAC,UAAY,IAMZ,KAAAC,MAAuB,UAAcC,OACrC,KAAAC,cAA+B,UAAcD,OAE7C,KAAAnB,wBAAkC,EAMlC,KAAAqB,iBAA2D,CAChEC,MAAQ,EACRC,OAAQ,EACRC,IAAQ,EACRC,MAAQ,GAEH,KAAAC,OAAiD,CACtDJ,MAAQ,EACRC,OAAQ,EACRC,IAAQ,EACRC,MAAQ,GAEH,KAAAE,QAAkD,CACvDL,MAAQ,EACRC,OAAQ,EACRC,IAAQ,EACRC,MAAQ,GAEH,KAAAG,OAAS,CACdC,MAAW,EACXC,SAAW,EACXC,OAAW,EACXC,QAAW,GAGH,KAAAC,QAAqC,CAAC,EAwFxC,KAAAC,oBAA6D,CACnEZ,KAAQ,EACRC,MAAQ,EACRC,GAAQ,EACRC,KAAQ,GAnFRrE,KAAK+E,SAAW/E,KAAKwD,MACrBxD,KAAKgF,iBAAmB/C,KAAKgD,IAAI,IAAMjF,KAAKwD,MAE5CxD,KAAKkF,iBAAiBzB,GACtBzD,KAAKmF,mBACP,CAEUC,cACRpF,KAAKsE,OAAOJ,MAAQ,EACpBlE,KAAKsE,OAAOH,OAAQ,EACpBnE,KAAKsE,OAAOF,IAAQ,EACpBpE,KAAKsE,OAAOD,MAAQ,EACpBrE,KAAKiE,iBAAiBC,MAAQ,EAC9BlE,KAAKiE,iBAAiBE,OAAQ,EAC9BnE,KAAKiE,iBAAiBG,IAAQ,EAC9BpE,KAAKiE,iBAAiBI,MAAQ,CAChC,CAEUgB,eACRrF,KAAKuE,QAAQH,IAAQ,EACrBpE,KAAKuE,QAAQF,MAAQ,EACrBrE,KAAKuE,QAAQL,MAAQ,EACrBlE,KAAKuE,QAAQJ,OAAQ,CACvB,CAGUmB,2BAIR,GAHAtF,KAAKuF,MAAQvF,KAAKqD,EAClBrD,KAAKwF,MAAQxF,KAAKsD,EAEdtD,KAAKsE,OAAOJ,KAAM,CACpB,MAAMuB,EAAsBzF,KAAKsE,OAAOF,IAAMpE,KAAKsE,OAAOD,KAC1DrE,KAAKuF,OAASvF,KAAK0F,8BAA8B,EAAAC,iBAAiBzB,KAAMuB,GAAoB,E,CAE9F,GAAIzF,KAAKsE,OAAOH,MAAO,CACrB,MAAMsB,EAAsBzF,KAAKsE,OAAOF,IAAMpE,KAAKsE,OAAOD,KAC1DrE,KAAKuF,OAASvF,KAAK0F,8BAA8B,EAAAC,iBAAiBxB,MAAOsB,GAAoB,E,CAE/F,GAAIzF,KAAKsE,OAAOF,GAAI,CAClB,MAAMqB,EAAsBzF,KAAKsE,OAAOJ,MAAQlE,KAAKsE,OAAOH,MAC5DnE,KAAKwF,OAASxF,KAAK0F,8BAA8B,EAAAC,iBAAiBvB,GAAIqB,GAAoB,E,CAE5F,GAAIzF,KAAKsE,OAAOD,KAAM,CACpB,MAAMoB,EAAsBzF,KAAKsE,OAAOJ,MAAQlE,KAAKsE,OAAOH,MAC5DnE,KAAKwF,OAASxF,KAAK0F,8BAA8B,EAAAC,iBAAiBtB,KAAMoB,GAAoB,E,CAEhG,CAEUG,OAER,GAAI5F,KAAKsE,OAAOJ,OAASlE,KAAKuE,QAAQL,MAAQlE,KAAK6F,yCAA0C,CAC3F,MAAMJ,EAAsBzF,KAAKsE,OAAOF,IAAMpE,KAAKsE,OAAOD,KAC1DrE,KAAKqD,GAAKrD,KAAK0F,8BAA8B,EAAAC,iBAAiBzB,KAAMuB,E,CAEtE,GAAIzF,KAAKsE,OAAOH,QAAUnE,KAAKuE,QAAQJ,OAASnE,KAAK6F,yCAA0C,CAC7F,MAAMJ,EAAsBzF,KAAKsE,OAAOF,IAAMpE,KAAKsE,OAAOD,KAC1DrE,KAAKqD,GAAKrD,KAAK0F,8BAA8B,EAAAC,iBAAiBxB,MAAOsB,E,CAGvE,GAAIzF,KAAKsE,OAAOF,KAAOpE,KAAKuE,QAAQH,IAAMpE,KAAK8F,uCAAwC,CACrF,MAAML,EAAsBzF,KAAKsE,OAAOJ,MAAQlE,KAAKsE,OAAOH,MAC5DnE,KAAKsD,GAAKtD,KAAK0F,8BAA8B,EAAAC,iBAAiBvB,GAAIqB,E,CAEpE,GAAIzF,KAAKsE,OAAOD,OAASrE,KAAKuE,QAAQF,MAAQrE,KAAK8F,uCAAwC,CACzF,MAAML,EAAsBzF,KAAKsE,OAAOJ,MAAQlE,KAAKsE,OAAOH,MAC5DnE,KAAKsD,GAAKtD,KAAK0F,8BAA8B,EAAAC,iBAAiBtB,KAAMoB,E,CAGtEzF,KAAKmF,mBACP,CAGQU,yCACN,OAAmD,KAA3C7F,KAAKsE,OAAOJ,MAAQlE,KAAKsE,OAAOH,MAC1C,CACQ2B,uCACN,OAAgD,KAAxC9F,KAAKsE,OAAOF,IAAMpE,KAAKsE,OAAOD,KACxC,CA8BQqB,8BAA8BK,EAA6BN,EAA6BO,GAAa,GAC3G,MAAMC,EAAiBR,EAClB,UAAShD,kBAAoBzC,KAAKgF,iBAAoBhF,KAAK8E,oBAAoBiB,GAC/E,UAAStD,kBAAoBzC,KAAK+E,SAAoB/E,KAAK8E,oBAAoBiB,GAC9EG,EAAuBjE,KAAKC,MAAM+D,GAExC,GAAID,EAAY,CACd,MAAMG,EAA6BF,EAAiB,EACpDjG,KAAK8E,oBAAoBiB,GAAaI,C,CAGxC,OAAOD,CACT,CAEUf,oBACRnF,KAAKoG,IAAMnE,KAAKC,MAAMlC,KAAKsD,EAAI+C,EAAOC,WACtCtG,KAAKuG,IAAMtE,KAAKC,MAAMlC,KAAKqD,EAAIgD,EAAOC,UACxC,CAEUE,mBACRxG,KAAKwE,OAAOC,MAAQzE,KAAKsD,EAAI+C,EAAOC,UACpCtG,KAAKwE,OAAOE,SAAW2B,EAAOC,UAAYtG,KAAKwE,OAAOC,MACtDzE,KAAKwE,OAAOG,OAAS3E,KAAKqD,EAAIgD,EAAOC,UACrCtG,KAAKwE,OAAOI,QAAUyB,EAAOC,UAAYtG,KAAKwE,OAAOG,MACvD,CAEU8B,yBAAyBzD,EAAa0D,GAC9C,GAAI,EAAAC,wBAAwBD,EAAmB1D,GAAI,CACjD,IAAI4D,EACAC,EACAH,EAAkBrD,EAAIL,EAAEK,EAC1BuD,EAAiBF,EAAkBrD,EAAIqD,EAAkBnD,aAAauD,WAAc9D,EAAEK,EAAIL,EAAEO,aAAauD,WAChGJ,EAAkBrD,EAAIL,EAAEK,IACjCuD,EAAiB5D,EAAEK,EAAIL,EAAEO,aAAauD,WAAcJ,EAAkBrD,EAAIqD,EAAkBnD,aAAauD,YAEvGJ,EAAkBpD,EAAIN,EAAEM,EAC1BuD,EAAiBH,EAAkBpD,EAAIoD,EAAkBnD,aAAawD,YAAe/D,EAAEM,EAAIN,EAAEO,aAAawD,YACjGL,EAAkBpD,EAAIN,EAAEM,IACjCuD,EAAiB7D,EAAEM,EAAIN,EAAEO,aAAawD,YAAeL,EAAkBpD,EAAIoD,EAAkBnD,aAAawD,cAEvGH,GAAiBA,GAAiBC,EACjCH,EAAkBpD,EAAIN,EAAEM,EAC1BtD,KAAKuE,QAAQF,MAAO,EAEpBrE,KAAKuE,QAAQH,IAAK,IAEVyC,GAAiBD,EAAgBC,KACvCH,EAAkBrD,EAAIL,EAAEK,EAC1BrD,KAAKuE,QAAQJ,OAAQ,EAErBnE,KAAKuE,QAAQL,MAAO,E,CAI5B,CAEU8C,2BACR,IAAIC,EAKJ,GAAIjH,KAAKsE,OAAOJ,KAAM,CACpB+C,EAAO,UAAIC,MAAMlH,KAAKoG,KAAKpG,KAAKuG,IAAM,GAClCU,GAAQjH,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKG,EAAKE,KAAOF,EAAKG,QACvEpH,KAAKqD,EAAI4D,EAAKE,KAAOF,EAAKG,MAAQpH,KAAKuD,aAAauD,UAAY,EAChE9G,KAAKiE,iBAAiBC,MAAO,GAG/B,MAAMmD,EAAcpF,KAAKC,OAAOlC,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKV,EAAOC,WAChFe,GAAeA,IAAgBrH,KAAKoG,MACtCa,EAAO,UAAIC,MAAMG,GAAarH,KAAKuG,IAAM,GACrCU,GAAQjH,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKG,EAAKE,KAAOF,EAAKG,QACjEpH,KAAKsE,OAAOD,MAAQrE,KAAKwE,OAAOC,OAASzE,KAAKwE,OAAOI,UACzD5E,KAAKqD,EAAI4D,EAAKE,KAAOF,EAAKG,MAAQpH,KAAKuD,aAAauD,UAAY,EAChE9G,KAAKiE,iBAAiBC,MAAO,KAKnC,MAAMoD,EAAcrF,KAAKC,OAAOlC,KAAKsD,EAAItD,KAAKuD,aAAawD,YAAcV,EAAOC,WAC5EgB,GAAeA,IAAgBtH,KAAKoG,MACtCa,EAAO,UAAIC,MAAMI,GAAatH,KAAKuG,IAAM,GACrCU,GAAQjH,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKG,EAAKE,KAAOF,EAAKG,QACjEpH,KAAKsE,OAAOF,IAAMpE,KAAKwE,OAAOE,UAAY1E,KAAKwE,OAAOI,UAC1D5E,KAAKqD,EAAI4D,EAAKE,KAAOF,EAAKG,MAAQpH,KAAKuD,aAAauD,UAAY,EAChE9G,KAAKiE,iBAAiBC,MAAO,I,CASrC,GAAIlE,KAAKsE,OAAOH,MAAO,CACrB8C,EAAO,UAAIC,MAAMlH,KAAKoG,KAAKpG,KAAKuG,IAAM,GAClCU,GAAQjH,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKG,EAAKE,OAC3DnH,KAAKqD,EAAI4D,EAAKE,KAAOnH,KAAKuD,aAAauD,UAAY,EACnD9G,KAAKiE,iBAAiBE,OAAQ,GAGhC,MAAMoD,EAActF,KAAKC,OAAOlC,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKV,EAAOC,WAChFiB,GAAeA,IAAgBvH,KAAKoG,MACtCa,EAAO,UAAIC,MAAMK,GAAavH,KAAKuG,IAAM,GACrCU,GAAQjH,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKG,EAAKE,OACrDnH,KAAKsE,OAAOD,MAAQrE,KAAKwE,OAAOC,OAASzE,KAAKwE,OAAOG,SACzD3E,KAAKqD,EAAI4D,EAAKE,KAAOnH,KAAKuD,aAAauD,UAAY,EACnD9G,KAAKiE,iBAAiBE,OAAQ,KAKpC,MAAMqD,EAAcvF,KAAKC,OAAOlC,KAAKsD,EAAItD,KAAKuD,aAAawD,YAAcV,EAAOC,WAC5EiB,GAAeC,IAAgBxH,KAAKoG,MACtCa,EAAO,UAAIC,MAAMM,GAAaxH,KAAKuG,IAAM,GACrCU,GAAQjH,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKG,EAAKE,OACrDnH,KAAKsE,OAAOF,IAAMpE,KAAKwE,OAAOE,UAAY1E,KAAKwE,OAAOG,SAC1D3E,KAAKqD,EAAI4D,EAAKE,KAAOnH,KAAKuD,aAAauD,UAAY,EACnD9G,KAAKiE,iBAAiBE,OAAQ,I,CAStC,GAAInE,KAAKsE,OAAOF,GAAI,CAClB6C,EAAO,UAAIC,MAAMlH,KAAKoG,IAAM,GAAGpG,KAAKuG,KAChCU,GAAQjH,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKE,EAAKQ,KAAOR,EAAKS,SACxE1H,KAAKsD,EAAI2D,EAAKQ,KAAOR,EAAKS,OAAS1H,KAAKuD,aAAawD,WAAa,EAClE/G,KAAKiE,iBAAiBG,IAAK,GAG7B,MAAMuD,EAAc1F,KAAKC,OAAOlC,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKT,EAAOC,WAC/EqB,GAAeA,IAAgB3H,KAAKuG,MACtCU,EAAO,UAAIC,MAAMlH,KAAKoG,IAAM,GAAGuB,GAC3BV,GAAQjH,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKE,EAAKQ,KAAOR,EAAKS,SAClE1H,KAAKsE,OAAOH,OAASnE,KAAKwE,OAAOE,SAAW1E,KAAKwE,OAAOG,SAC5D3E,KAAKsD,EAAI2D,EAAKQ,KAAOR,EAAKS,OAAS1H,KAAKuD,aAAawD,WAAa,EAClE/G,KAAKiE,iBAAiBG,IAAK,KAKjC,MAAMwD,EAAc3F,KAAKC,OAAOlC,KAAKqD,EAAIrD,KAAKuD,aAAauD,WAAaT,EAAOC,WAC3EsB,GAAeA,IAAgB5H,KAAKuG,MACtCU,EAAO,UAAIC,MAAMlH,KAAKoG,IAAM,GAAGwB,GAC3BX,GAAQjH,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKE,EAAKQ,KAAOR,EAAKS,SAClE1H,KAAKsE,OAAOJ,MAAQlE,KAAKwE,OAAOE,SAAW1E,KAAKwE,OAAOI,UAC3D5E,KAAKsD,EAAI2D,EAAKQ,KAAOR,EAAKS,OAAS1H,KAAKuD,aAAawD,WAAa,EAClE/G,KAAKiE,iBAAiBG,IAAK,I,CAS/BpE,KAAKsE,OAAOD,OACd4C,EAAO,UAAIC,MAAMlH,KAAKoG,IAAM,GAAGpG,KAAKuG,KAChCU,GAAQjH,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKE,EAAKQ,OAC5DzH,KAAKsD,EAAI2D,EAAKQ,KAAOzH,KAAKuD,aAAawD,WAAa,EACpD/G,KAAKiE,iBAAiBI,MAAO,IAIjC,MAAMwD,EAAc5F,KAAKC,OAAOlC,KAAKqD,EAAIrD,KAAKuD,aAAauD,UAAY,GAAKT,EAAOC,WAC/EuB,GAAeA,IAAgB7H,KAAKuG,MACtCU,EAAO,UAAIC,MAAMlH,KAAKoG,IAAM,GAAGyB,GAC3BZ,GAAQjH,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKE,EAAKQ,OACtDzH,KAAKsE,OAAOH,OAASnE,KAAKwE,OAAOC,MAAQzE,KAAKwE,OAAOG,SACzD3E,KAAKsD,EAAI2D,EAAKQ,KAAOzH,KAAKuD,aAAawD,WAAa,EACpD/G,KAAKiE,iBAAiBI,MAAO,KAKnC,MAAMyD,EAAc7F,KAAKC,OAAOlC,KAAKqD,EAAIrD,KAAKuD,aAAauD,WAAaT,EAAOC,WAC3EwB,GAAeA,IAAgB9H,KAAKuG,MACtCU,EAAO,UAAIC,MAAMlH,KAAKoG,IAAM,GAAG0B,GAC3Bb,GAAQjH,KAAKsD,EAAItD,KAAKuD,aAAawD,WAAa,GAAKE,EAAKQ,OACtDzH,KAAKsE,OAAOJ,MAAQlE,KAAKwE,OAAOC,MAAQzE,KAAKwE,OAAOI,UACxD5E,KAAKsD,EAAI2D,EAAKQ,KAAOzH,KAAKuD,aAAawD,WAAa,EACpD/G,KAAKiE,iBAAiBI,MAAO,IAIrC,CAEU0D,4BACR/H,KAAK2D,MAAMqE,KAAKhI,KAAKqD,GACjBrD,KAAK2D,MAAM/B,OAAS5B,KAAK0D,mBAAqB1D,KAAK2D,MAAMsE,QAE7DjI,KAAK4D,MAAMoE,KAAKhI,KAAKsD,GACjBtD,KAAK4D,MAAMhC,OAAS5B,KAAK0D,mBAAqB1D,KAAK4D,MAAMqE,OAC/D,CAEUC,gBAAgBC,GACpBnI,KAAK8D,QAAU,UAAcsE,WAC7BpI,KAAK8D,QAAU,UAAcuE,mBAC7BrI,KAAK8D,QAAU,UAAcwE,eAE/BtI,KAAKuI,6BAA6BJ,GAGlCnI,KAAKwI,2BAET,CAEQA,4BACN,MAAMzC,EAAsB,GAExB/F,KAAKiE,iBAAiBI,OAA8B,IAAtBrE,KAAKuE,QAAQF,KAC7C0B,EAAUiC,KAAK,EAAAS,WAAWC,GAEnB1I,KAAKiE,iBAAiBG,KAA0B,IAApBpE,KAAKuE,QAAQH,IAChD2B,EAAUiC,KAAK,EAAAS,WAAWE,GAGxB3I,KAAKiE,iBAAiBE,QAAgC,IAAvBnE,KAAKuE,QAAQJ,MAC9C4B,EAAUiC,KAAK,EAAAS,WAAWG,GAEnB5I,KAAKiE,iBAAiBC,OAA8B,IAAtBlE,KAAKuE,QAAQL,MAClD6B,EAAUiC,KAAK,EAAAS,WAAWI,GAG5B,MAAMC,EAAkB/C,EAAUgD,KAAK,KAAO/I,KAAK+F,WAAa,IAEhE/F,KAAK+F,UAAY,EAAA0C,WAAWK,EAC9B,CAEQP,6BAA6BJ,GACnC,MAAMa,EAAQ,EAAAC,mBAAmBd,EAAgBnI,MACjDA,KAAK+F,UAAY,EAAAmD,yBAAyBF,EAC5C,CAEUG,gBAER,MAAMC,EAAapJ,KAAK2D,MAAM0F,OAAM,CAAC1F,EAAO2F,IAAa,IAANA,GAAmB3F,IAAU3D,KAAK2D,MAAM,KACrF4F,EAAavJ,KAAK4D,MAAMyF,OAAM,CAACzF,EAAO0F,IAAa,IAANA,GAAmB1F,IAAU5D,KAAK4D,MAAM,KAC3F,OAAIwF,IAAcG,CAKpB,CAEUrE,iBAAiBzB,EAA2B,IAChDA,EAAmB,GAAOA,EAAmB,KAC/CA,EAAmB,GAErBzD,KAAKwJ,OAASxJ,KAAK6D,UAAYJ,CACjC,CAGUgG,iBACR,OAAIzJ,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACf,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,QAA2B,GAAjBxJ,KAAK6D,UACtB,UACE7D,KAAKwJ,OAASxJ,KAAK6D,UACrB,UACE7D,KAAKwJ,SAAWxJ,KAAK6D,UACvB,eADF,CAGT,E,eC5cF,IAAK6F,E,iDAAL,SAAKA,GACH,uBACA,uBACA,uCACA,6BACA,6CACA,qBACA,2BACA,wBACD,CATD,CAAKA,IAAAA,EAAa,KAWlB,UAAeA,C,sFCXf,gBAEA,UAEA,MAAqBC,EAOZhK,8BACLgK,EAAMC,aAAeD,EAAME,cAE3BC,EAAWC,OACb,CAEOpK,mBACL,UAAIqK,QAEJL,EAAMC,eAENE,EAAWC,OACb,CAEOpK,qBACL,OAAQgK,EAAMC,eAAiBD,EAAMM,SACvC,EAvBF,YACgB,EAAAA,UAAY,EAAAC,kBAEH,EAAAL,cAAgB,EAEzB,EAAAD,aAAeD,EAAME,cAqBrC,gBAEA,UACA,UAEA,MAAaC,EAGJnK,0CACLmK,EAAWK,yBAA2B,UAASC,gBACjD,CAEOzK,eACLmK,EAAWK,wBAA0B,CACvC,CAEOxK,8CACL,EAAAF,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,gBACf,MAAMC,EAAqBvI,KAAKwI,MAAMX,EAAWK,wBAA0B,KAC3E,EAAA1K,QAAQiL,SAAS,SAASf,EAAMC,sBAAsBY,IAAsB,GAAInE,EAAOsE,cAAgB,IACzG,EAAAlL,QAAQmL,QACV,EAlBF,eACgB,EAAAT,wBAA0B,C,kECpC1C,gBAEA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UAEA,UAEA,UAEA,UAUA,MAAqBU,UAAsB,UAWzCzH,YACEC,EACAC,EACAE,EACAC,EACAqH,GAEAC,MAAM1H,EAAGC,EAAG,IAAI,UAAa,GAAI,IAAKE,EAAOC,GAbrC,KAAAuH,YAAc,IACd,KAAAC,oBAAsB,GAEtB,KAAAC,cAA8B,IAAOlL,KAAKgL,YAAuB3E,EAAO8E,WACxE,KAAAC,kBAA8B,IAAOpL,KAAKiL,oBAAuB5E,EAAO8E,WAWhFnL,KAAKqL,iBAAoB,EAAIP,EAAyB9K,KAAKsL,oBAG3DtL,KAAKuL,kBACLvL,KAAKwL,sBAELxL,KAAKyL,WAAa,CAChB,CAAC,UAAc1H,QAAoB,IAAI,EAAA2H,6BACvC,CAAC,UAAcC,QAAoB,IAAI,EAAAC,6BACvC,CAAC,UAActD,gBAAoB,IAAI,EAAAuD,qCACvC,CAAC,UAAczD,WAAoB,IAAI,EAAA0D,gCACvC,CAAC,UAAczD,mBAAoB,IAAI,EAAA0D,wCACvC,CAAC,UAAcC,OAAoB,IAAI,EAAAC,4BACvC,CAAC,UAAcC,UAAoB,IAAI,EAAAC,+BAE3C,CAGOC,OAAOC,GACZ,GAAIrM,KAAK8D,OAAS,UAAckI,MAM9B,OALAjB,MAAMqB,OAAOC,QAET,UAAKC,aAAaC,aAAe,UAAYC,SAC/CxM,KAAKsC,kBAAiB,IAKrBtC,KAAKyM,SACRzM,KAAKyM,OAASJ,GAEhBrM,KAAKqF,eACLrF,KAAKsF,2BACLtF,KAAK+H,4BAEL/H,KAAK0M,MAAQ1M,KAAK2M,eAGhB3M,KAAK8D,QAAU,UAAcC,QAC7B/D,KAAK8D,QAAU,UAAcwE,gBAC7BtI,KAAK8D,QAAU,UAAcsE,WAC7BpI,KAAK8D,QAAU,UAAcuE,mBAC7BrI,KAAKgE,gBAAkB,UAAcqE,mBACrCrI,KAAKgE,gBAAkB,UAAcsE,iBACZ,IAAzBtI,KAAKmJ,iBAELnJ,KAAK4M,SAAS,UAAc7I,QAG9B/D,KAAK6M,mBAAqB,EAAAC,qBACxB,CAAEzJ,EAAGgJ,EAAOhJ,EAAGC,EAAG+I,EAAO/I,GACzB,CAAED,EAAGrD,KAAKqD,EAAKC,EAAGtD,KAAKsD,IAGzB,MAAMyJ,EAAkB/M,KAAKgN,cAAcX,GAiB3C,GAfErM,KAAK8D,QAAU,UAAcsE,WAC7BpI,KAAK8D,QAAU,UAAcuE,mBAC7B0E,IAEA/M,KAAKuL,kBACLvL,KAAK4M,SAAS,UAAcxE,YAI5BpI,KAAK8D,QAAU,UAAcuE,oBACT,IAApB0E,GAEA/M,KAAK4M,SAAS,UAAcjB,QAG1B3L,KAAK8D,QAAU,UAAcsE,UAAW,CAE1C,GAAIpI,KAAKiN,YAAc,GAAKjN,KAAKkN,gBAAkB,IACjDlN,KAAKmN,OAAOd,GACZrM,KAAKuL,kBACLvL,KAAKwL,sBACDuB,GAEF,YADA/M,KAAK4M,SAAS,UAAcvE,mBAKhC,MAAM+E,EAAmBpN,KAAKiN,aAAejN,KAAKkL,eAG3B,IAArB6B,IACqB,IAArBK,GAEApN,KAAK4M,SAAS,UAAcjB,O,CAIhC3L,KAAKqN,2CACH,UAAUC,gDAAgDtN,KAAMqM,GAGhErM,KAAK8D,QAAU,UAAcC,QAC7B/D,KAAK8D,QAAU,UAAc6H,SAE7B3L,KAAKuN,iBAAiBlB,EAAQrM,KAAKqN,4CAGjCrN,KAAK8D,QAAU,UAAc6H,UAEyB,IAApD3L,KAAKqN,4CACLrN,KAAKwN,aAAa5L,OAAS,IAG7B5B,KAAK4M,SAAS,UAAcjB,SAIhC3L,KAAKyN,kCAAkCpB,GACvCrM,KAAK0N,4BAA4BrB,GAE7BrM,KAAK8D,QAAU,UAAc6H,QAC/B3L,KAAK4F,OAGP5F,KAAKwG,mBAELxG,KAAKgH,2BAELhH,KAAKkI,gBAAgBmE,GAErBtB,MAAMqB,OAAOC,GAET,UAAKC,aAAaC,aAAe,UAAYC,UAC/CxM,KAAK2N,+BAEL3N,KAAKsC,iBAAiByK,GAE1B,CAGOhK,KAAKsJ,GACNhG,EAAOuH,MAAMC,qBACX7N,KAAK8D,MAAQ,UAAckI,OAC7BhM,KAAK8N,uBAAuBzB,GAG5BhG,EAAOuH,MAAMG,eACf/N,KAAKgO,sBAAsB3B,GAEzBhG,EAAOuH,MAAMK,mBACf,EAAAC,oBAAoBlO,KAAKmO,iBAAkB9B,EAAQrM,KAAKyJ,kBAEtDpD,EAAOuH,MAAMQ,yBACfpO,KAAKqO,+BAA+BhC,GAGtCtB,MAAMhI,KAAKsJ,GAEPhG,EAAOuH,MAAMU,aACftO,KAAKuO,gBAAgBlC,EAEzB,CAGU/J,iBAAiByK,GACrB/M,KAAK8D,QAAU,UAAcsE,WACNpI,KAAKiN,aAAejN,KAAKkL,eAEhDlL,KAAKyL,WAAWzL,KAAK8D,OAAOxB,mBAG5BtC,KAAK8D,QAAU,UAAcuE,mBAC/BrI,KAAKyL,WAAWzL,KAAK8D,OAAOxB,mBACxBtC,KAAKyL,WAAWzL,KAAK8D,OAAOvB,qBACN,IAApBwK,EACF/M,KAAK4M,SAAS,UAAcxE,WAG5BpI,KAAK4M,SAAS,UAAcjB,UAIzB3L,KAAK8D,QAAU,UAAc6H,OACpC3L,KAAKyL,WAAWzL,KAAK8D,OAAOxB,mBAErBtC,KAAK8D,QAAU,UAAckI,OACpChM,KAAKyL,WAAWzL,KAAK8D,OAAOxB,mBACxBtC,KAAKyL,WAAWzL,KAAK8D,OAAOvB,mBAC9BvC,KAAK4M,SAAS,UAAcV,WAGvBlM,KAAK8D,QAAU,UAAcoI,WACpClM,KAAKyL,WAAWzL,KAAK8D,OAAOxB,mBACxBtC,KAAKyL,WAAWzL,KAAK8D,OAAOvB,mBAC9BvC,KAAK4M,SAAS,UAAc4B,SAGlC,CAGQjB,iBAAiBlB,EAAgBgB,GACnCA,GAC4B,IAA1BrN,KAAKqL,mBACPrL,KAAKmO,iBAAmB,EAAAM,kBACtBxM,KAAKwI,MAAMxI,KAAKyM,IAAIrC,EAAOjG,IAAMpG,KAAKoG,KAAO,GAC7CnE,KAAKwI,MAAMxI,KAAKyM,IAAIrC,EAAO9F,IAAMvG,KAAKuG,KAAO,GAC7CvG,KAAKuD,cAEPvD,KAAKwN,aAAe,EAAAmB,iBAAiB3O,KAAMqM,EAAQrM,KAAKmO,mBAG1DnO,KAAKqL,kBAAoB,UAASjB,iBAC9BpK,KAAKqL,iBAAmBrL,KAAKsL,sBAC/BtL,KAAKqL,iBAAmB,GAGtBrL,KAAKwN,aAAa5L,OAAS,GAC7B5B,KAAK4O,0BAIH5O,KAAKmO,mBACPnO,KAAKmO,iBAAmB,MAEtBnO,KAAKwN,eACPxN,KAAKwN,aAAe,IAEtBxN,KAAK6O,kBAAkBxC,GAE3B,CAEQuC,wBAEN,IAAIE,EAAY9O,KAAKwN,aAAaxN,KAAKwN,aAAa5L,OAAS,GAAGyB,EAC5D0L,EAAY/O,KAAKwN,aAAaxN,KAAKwN,aAAa5L,OAAS,GAAG0B,EAE9DtD,KAAKwN,aAAa5L,OAAS,GAC3BK,KAAKyM,IAAII,EAAY9O,KAAKqD,GAAK,GAC/BpB,KAAKyM,IAAIK,EAAY/O,KAAKsD,GAAK,IAE/BtD,KAAKwN,aAAawB,MAClBF,EAAY9O,KAAKwN,aAAaxN,KAAKwN,aAAa5L,OAAS,GAAGyB,EAC5D0L,EAAY/O,KAAKwN,aAAaxN,KAAKwN,aAAa5L,OAAS,GAAG0B,GAE9DtD,KAAKiP,YAAYH,EAAWC,EAC9B,CAEQF,kBAAkBxC,GACpBrM,KAAK6M,mBAAqB7M,KAAKuD,aAAa6D,MAC9CpH,KAAKiP,YAAY5C,EAAOhJ,EAAGgJ,EAAO/I,GAGlCtD,KAAKoF,aAET,CAEQ6J,YAAY5L,EAAWC,GAC7BtD,KAAKoF,cAEDpF,KAAKqD,EAAIA,GACXrD,KAAKsE,OAAOH,OAAQ,EACpBnE,KAAKiE,iBAAiBE,OAAQ,GAEvBnE,KAAKqD,EAAIA,IAChBrD,KAAKsE,OAAOJ,MAAO,EACnBlE,KAAKiE,iBAAiBC,MAAO,GAE3BlE,KAAKsD,EAAIA,GACXtD,KAAKsE,OAAOD,MAAO,EACnBrE,KAAKiE,iBAAiBI,MAAO,GAEtBrE,KAAKsD,EAAIA,IAChBtD,KAAKsE,OAAOF,IAAK,EACjBpE,KAAKiE,iBAAiBG,IAAK,EAE/B,CAEQuJ,+BACF3N,KAAK8D,QAAU,UAAcsE,WAAapI,KAAKiN,WAAa,GAA6B,IAAxBjN,KAAKkN,iBACxElN,KAAKiN,YAAc,UAAS7C,kBAIFpK,KAAKiN,aAAejN,KAAKkL,eAC1BlL,KAAKkN,gBAAkB,IAChDlN,KAAKkN,gBAAkB,UAAS9C,iBAC5BpK,KAAKkN,eAAiB,IACxBlN,KAAKkN,eAAiB,GAG5B,CAGQY,uBAAuBzB,GAC7B,EAAA5M,QAAQyP,YAAclP,KAAKyJ,iBAC3B,EAAAhK,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YAGN,EAAA5K,QAAQ2P,QACL,GAAM,UAAOC,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAKrD,KAAKuD,aAAauD,WAChE,GAAM,UAAOuI,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,GAAKtD,KAAKuD,aAAawD,YAEnE,EAAAtH,QAAQ6P,OACL,GAAM,UAAOD,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAKrD,KAAKuD,aAAauD,WAChE,GAAM,UAAOuI,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,GAAKtD,KAAKuD,aAAawD,YAEnE,EAAAtH,QAAQ6P,OACN,GAAM,UAAOD,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAKrD,KAAKuD,aAAauD,UAChE,GAAM,UAAOuI,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,GAAKtD,KAAKuD,aAAawD,YAElE,EAAAtH,QAAQ6P,QACL,GAAM,UAAOD,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAKrD,KAAKuD,aAAauD,UAChE,GAAM,UAAOuI,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,GAAKtD,KAAKuD,aAAawD,YAEnE,EAAAtH,QAAQ6P,QACL,GAAM,UAAOD,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAKrD,KAAKuD,aAAauD,WAChE,GAAM,UAAOuI,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,GAAKtD,KAAKuD,aAAawD,YAErE,EAAAtH,QAAQmL,QACV,CAEQ2D,gBAAgBlC,GACtB,EAAA5M,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,gBACf,EAAA9K,QAAQiL,SACN1K,KAAK8D,MAAMyL,WACX,UAAOF,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAKrD,KAAKuD,aAAauD,UAC1D,UAAOuI,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,GAAKtD,KAAKuD,aAAawD,YAE9D,EAAAtH,QAAQmL,QACV,CAEQoD,sBAAsB3B,GACxBrM,KAAKqN,2CACP,EAAA5N,QAAQyP,YAAc,UAEtB,EAAAzP,QAAQyP,YAAc,UAExB,EAAAzP,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YACN,EAAA5K,QAAQ2P,OAAO,UAAOC,OAAOhM,GAAKrD,KAAKqD,EAAIgJ,EAAOhJ,GAAI,UAAOgM,OAAO/L,GAAKtD,KAAKsD,EAAI+I,EAAO/I,IACzF,EAAA7D,QAAQ6P,OAAO,UAAOD,OAAOhM,EAAG,UAAOgM,OAAO/L,GAChD,EAAA7D,QAAQmL,QACV,CAEQyD,+BAA+BmB,GACrCxP,KAAKwN,aACFiC,SAAQ,CAACC,EAAGpG,KACX,EAAAqG,SAASD,EAAGF,EAAGE,EAAEE,QAAU,UAAY,UAAU,IAEjD5P,KAAKwN,aAAa5L,OAAS,GAC7B5B,KAAKwN,aAAaiC,SAAQ,CAACI,EAAMvG,KAC/BtJ,KAAK8P,8BAA8BD,EAAM7P,KAAKwN,aAAalE,EAAI,IAAMkG,EAAGA,EAAE,GAGhF,CAEQM,8BAA8BC,EAAWC,EAAW3D,GAC1D,EAAA5M,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YACN,EAAA5K,QAAQ2P,OAAO,UAAOC,OAAOhM,GAAK2M,EAAG3M,EAAIgJ,EAAOhJ,GAAI,UAAOgM,OAAO/L,GAAK0M,EAAG1M,EAAI+I,EAAO/I,IACrF,EAAA7D,QAAQ6P,OAAO,UAAOD,OAAOhM,GAAK0M,EAAG1M,EAAIgJ,EAAOhJ,GAAI,UAAOgM,OAAO/L,GAAKyM,EAAGzM,EAAI+I,EAAO/I,IACvF,EAAA7D,QAAQmL,QACV,EA9XF,W,kECzBA,gBAGA,UAEA,MAAqBkB,UAAwC,UAA7D,c,oBACY,KAAA5I,OAAyB,UAAQ+M,KAEjC,KAAAtN,gBAAoB,IACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,EAE7B,KAAAR,kBAAmB,CAC/B,EAVA,W,kECLA,gBAGA,UAEA,MAAqB0J,UAAgD,UAArE,c,oBACY,KAAA7I,OAAyB,UAAQ+M,KAEjC,KAAAtN,gBAAoB,EACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,CACzC,EARA,W,kECLA,gBAGA,UAEA,MAAqBsJ,UAAuC,UAA5D,c,oBACY,KAAAjJ,OAAyB,UAAQgN,MAEjC,KAAAvN,gBAAoB,IACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,CACzC,EARA,W,iECLA,gBAGA,UAEA,MAAqBoJ,UAAoC,UAAzD,c,oBACY,KAAA/I,OAAyB,UAAQ+M,KAEjC,KAAAtN,gBAAoB,IACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,CACzC,EARA,W,kECLA,gBAGA,UAEA,MAAqB6I,UAAqC,UAA1D,c,oBACY,KAAAxI,OAAyB,UAAQ+M,KAEjC,KAAAtN,gBAAoB,EACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,CACzC,EARA,W,kECLA,gBAGA,UAEA,MAAqB+I,UAAqC,UAA1D,c,oBACY,KAAA1I,OAAyB,UAAQ+M,KAEjC,KAAAtN,gBAAoB,IACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,CACzC,EARA,W,kECLA,gBAGA,UAEA,MAAqBgJ,UAA6C,UAAlE,c,oBACY,KAAA3I,OAAyB,UAAQ+M,KAEjC,KAAAtN,gBAAoB,EACpB,KAAAH,kBAAoB,EAEpB,KAAAI,wBAA6B,EAC7B,KAAAC,2BAA6B,CACzC,EARA,W,yTCLA,gBASE,EAAA6I,6BATK,UACP,gBASE,EAAAE,6BATK,UACP,gBASE,EAAAC,qCATK,UACP,gBASE,EAAAC,gCATK,UACP,gBASE,EAAAC,wCATK,UACP,eASE,EAAAE,4BATK,UACP,gBASE,EAAAE,+BATK,S,kECNP,gBAEA,UAKA,UACA,UAEA,UAEA,UACA,UAEA,UAEA,MAA8BgE,UAAc,UAqB1C/M,YACEC,EACAC,EACAC,EACAC,EACAC,GAEAsH,MAAM1H,EAAGC,EAAGC,EAAcC,EAAOC,GAvBzB,KAAA4H,iBAA2B,EAC3B,KAAAC,oBAA8B,IAE9B,KAAAkC,aAA2B,GAuBnCxN,KAAK6E,QAAQuL,cAAgB,IAAI,SACnC,CAEOrN,KAAKsJ,GACVrM,KAAKyL,WAAWzL,KAAK8D,OAAOf,KAAK/C,KAAM,CAAEqD,EAAGgJ,EAAOhJ,EAAGC,EAAG+I,EAAO/I,IAEhE+M,OAAOC,OAAOtQ,KAAK6E,SAAS4K,SAAQc,GAAUA,EAAOC,OAAOnE,EAAOhJ,EAAGgJ,EAAO/I,IAE/E,CAEO8I,OAAOC,GACZgE,OAAOC,OAAOtQ,KAAK6E,SAAS4K,SAAQc,GAAUA,EAAOnE,UACvD,CAEOqE,WAAWC,EAAiBC,GACjC,MAAMC,EAAqC,EAAnBvK,EAAOC,UAC/B,OACErE,KAAKyM,IAAI1O,KAAKqD,EAAIqN,GAAWrK,EAAOwK,aAAe,EAAID,GACvD3O,KAAKyM,IAAI1O,KAAKsD,EAAIqN,GAAWtK,EAAOsE,cAAgB,EAAIiG,CAE5D,CAIUlD,4BAA4BrB,GACpC,MAAMyE,EAAiB,CACrBzN,EAAGrD,KAAKuF,MACRjC,EAAGtD,KAAKwF,MACRjC,aAAcvD,KAAKuD,cAErBvD,KAAKyG,yBAAyB4F,EAAQyE,EACxC,CAEUrD,kCAAkCpB,GAC1C,MAAMyE,EAAiB,CACrBzN,EAAGrD,KAAKuF,MACRjC,EAAGtD,KAAKwF,MACRjC,aAAcvD,KAAKuD,cAEgB,UAAIwN,mBAAmB/Q,KAAKqD,EAAGrD,KAAKsD,GAE5CmM,SAASuB,IAChCA,EAAElN,OAAS,UAAckI,OAGzBhM,OAASgR,GACXhR,KAAKyG,yBAAyBuK,EAAGF,E,GAGvC,CAEU9D,cAAcP,GACtB,MAAMwE,GAAkCxE,EAAOlJ,aAAauD,UAAY9G,KAAKuD,aAAauD,WAAa7E,KAAKiP,KAAK,GACjH,OAAOlR,KAAK6M,mBAAqBoE,CACnC,CAEUE,uBAAuB1E,GAC/B,MAAMwE,GAAkCxE,EAAOlJ,aAAauD,UAAY9G,KAAKuD,aAAauD,WAAa7E,KAAKiP,KAAK,GAEjH,OAAOlR,KAAK6M,mBADiB,EACIoE,CACnC,CAEUtE,eACR,MAAMyE,EAAYpR,KAAK2D,MAAM0F,OAAOhG,GAAMA,IAAMrD,KAAK2D,MAAM,KACrD0N,EAAYrR,KAAK4D,MAAMyF,OAAO/F,GAAMA,IAAMtD,KAAK4D,MAAM,KAC3D,SAAIwN,IAAaC,EAKnB,CAEUlE,OAAOqC,GACf,MAAM8B,EAA2B,UAAUC,6CAA6CvR,KAAMwP,GAG5FxP,KAAKmR,uBAAuB3B,KACC,IAA7B8B,GAEA,UAAQE,kBACRxR,KAAKyR,WAAWjC,KAGhB,UAAQkC,sBACR1R,KAAKyR,WAAWjC,EAAG,UAAgBmC,MAEvC,CAEUC,eACR,OAAO3P,KAAKE,UAAY,EAC1B,CAEUoJ,kBACRvL,KAAKiN,WAAajN,KAAKkL,aACzB,CACUM,sBACRxL,KAAKkN,eAAiBlN,KAAKoL,iBAC7B,CAEOyG,WAAWC,GAChB9R,KAAKwJ,QAAUsI,EAEf9R,KAAK6E,QAAQuL,cAAcpI,KAAK,EAAA+J,oBAAoBC,OAAOhS,KAAKqD,EAAGrD,KAAKsD,EAAGtD,KAAKuD,aAAcuO,IAE1F9R,KAAKwJ,QAAU,EACjBxJ,KAAKiS,MAGL,UAAQC,cAEZ,CAEOD,MACL,UAAQE,iBACRnS,KAAK4M,SAAS,UAAcZ,MAC9B,CAEUyF,WAAWjC,EAAW4C,EAAkC,MAC5DA,IAAmB,UAAgBT,KACrCnC,EAAEqC,WAAW,EAAGO,GAGhB5C,EAAEqC,WAAW7R,KAAKqS,YAEtB,CAGUA,YACR,OAAO,EACT,CAEOzF,SAAS0F,GACdtS,KAAKgE,cAAgBhE,KAAK8D,MAC1B9D,KAAK8D,MAAQwO,EACbtS,KAAKuS,iBACP,CAEUA,kBACRlC,OAAOC,OAAOtQ,KAAKyL,YAAYgE,SAAU+C,GAAuBA,EAAE1P,kBACpE,EA1KF,W,kECjBA,gBAEA,UACA,UACA,UAEA,UAEA,UAEA,SACA,UAGA,UACA,UAEA,MAAqB2P,EAwBnBrP,cACE,MAAMsP,EAAU,UAAW,UAAM9I,cACjC5J,KAAK2S,QAAQD,GACb1S,KAAKqM,OAAS,IAAI,UAAOqG,EAAQrG,OAAOhJ,EAAGqP,EAAQrG,OAAO/I,EAC5D,CApBO3D,0BAA0B+Q,EAAiBC,GAChD,OAAO8B,EAAIG,QAAQC,QAAO7B,GAAKA,EAAEP,WAAWC,EAASC,IACvD,CAEOhR,2BAA2B+Q,EAAiBC,GACjD,OAAO8B,EAAIK,gBAAgBD,QAAO7B,GAAKA,EAAEP,WAAWC,EAASC,IAC/D,CAEOhR,0BACL,OAAO8S,EAAIG,QAAQhR,MACrB,CAEOjC,eACL8S,EAAIK,gBAAkB,EACxB,CAQOC,UACL,KAAON,EAAIG,QAAQhR,QACjB6Q,EAAIG,QAAQ5D,KAEhB,CAEO5C,SACLqG,EAAIG,QAAQnD,SAAQ,CAACuB,EAAG1H,KAClB0H,EAAElN,QAAU,UAAcoI,WAE5BuG,EAAIG,QAAQI,OAAO1J,EAAG,GACtBmJ,EAAIK,gBAAgB9K,KAAKgJ,IAE3BA,EAAE5E,OAAOpM,KAAKqM,OAAO,IAGvBoG,EAAIK,gBAAgBrD,SAAQ,CAACuB,EAAG1H,KAC9B0H,EAAE5E,OAAOpM,KAAKqM,QACV2E,EAAElN,QAAU,UAAc0K,SAC5BiE,EAAIK,gBAAgBE,OAAO1J,EAAG,E,IAIlCtJ,KAAKiT,mCACP,CAEQA,qCAEsB,IAA1BR,EAAIS,WAAWC,QAEU,IAAvBV,EAAIG,QAAQhR,SACZ6Q,EAAIG,QAAQvJ,OAAM2H,GAAKA,EAAElN,OAAS,UAAckI,SAGlDyG,EAAIS,WAAWhU,MAEnB,CAEO6D,OACL/C,KAAKoT,kBAGLX,EAAIY,oBAAoBrT,KAAKqM,OAAOhJ,EAAGrD,KAAKqM,OAAO/I,GAChDmM,SAAQuB,GAAKA,EAAEjO,KAAK/C,KAAKqM,UAG5BoG,EAAI1B,mBAAmB/Q,KAAKqM,OAAOhJ,EAAGrD,KAAKqM,OAAO/I,GAC/CuP,QAAO7B,GAAKA,EAAElN,QAAU,UAAc0K,UACtCiB,SAAQuB,IACHA,EAAElN,QAAU,UAAc0K,SAG9BwC,EAAEjO,KAAK/C,KAAKqM,OAAO,GAEzB,CAEQ+G,kBACN,MAAME,EAAatT,KAAKqM,OAAO7H,OAAOG,OAAS,UAAO4O,aAChDC,EAAaxT,KAAKqM,OAAO7H,OAAOC,MAAS,UAAOgP,aAEhDC,EAAW1T,KAAKqM,OAAOjG,IAAM,UAAOuN,SACpCC,EAAW5T,KAAKqM,OAAO9F,IAAM,UAAOsN,SAG1C,IAAI5M,EACJ,IAAK,IAAIb,EAAMsN,EAAUtN,EAAMsN,EAAW,UAAOI,KAAO,IAAK1N,EAC3D,IAAK,IAAIG,EAAMqN,EAAW,EAAGrN,EAAMqN,EAAW,UAAOG,KAAO,IAAKxN,EAC3DkM,EAAIvL,MAAMd,IAAQqM,EAAIvL,MAAMd,GAAKG,KACnCU,EAAOwL,EAAIvL,MAAMd,GAAKG,GACtBU,EAAK5D,GAAKkD,EAAMqN,GAAYvN,EAAOC,UAAYgN,EAC/CrM,EAAK3D,GAAK8C,EAAMsN,GAAYrN,EAAOC,UAAYkN,EAC/CvM,EAAKlE,QAEH0P,EAAIS,WAAW9M,MAAQA,GAAOqM,EAAIS,WAAW3M,MAAQA,IACvDkM,EAAIS,WAAW7P,GAAKkD,EAAMqN,GAAYvN,EAAOC,UAAYgN,EACzDb,EAAIS,WAAW5P,GAAK8C,EAAMsN,GAAYrN,EAAOC,UAAYkN,EACzDf,EAAIS,WAAWnQ,OAIvB,CAEQ4P,QAAQqB,GACdhU,KAAKiU,gBAAgBD,GACrBhU,KAAKkU,YAAYF,EACnB,CAGQC,gBAAgBD,GACtBhU,KAAKmU,UAAUH,GACfhU,KAAKoU,eAAeJ,EACtB,CAEQG,UAAUH,GAChB,IAAK,IAAI5N,EAAM,EAAGA,EAAM4N,EAAIK,YAAYzS,SAAUwE,EAAK,CACrDqM,EAAIvL,MAAMd,GAAO,GACjB,IAAK,IAAIG,EAAM,EAAGA,EAAMyN,EAAIK,YAAYjO,GAAKxE,SAAU2E,EAAK,CAC1D,MAAM+N,EAASN,EAAIK,YAAYjO,GAAKG,GACpCkM,EAAIvL,MAAMd,GAAKG,GAAO,KAClB,EAAAgO,OAAOD,KACT7B,EAAIvL,MAAMd,GAAKG,GAAO,UAAYiO,WAAWpO,EAAKG,EAAK+N,G,EAI/D,CAEQF,eAAeJ,GACrB,IAAK,IAAI5N,EAAM,EAAGA,EAAM4N,EAAIK,YAAYzS,SAAUwE,EAChD,IAAK,IAAIG,EAAM,EAAGA,EAAMyN,EAAIK,YAAYjO,GAAKxE,SAAU2E,EACtCyN,EAAIK,YAAYjO,GAAKG,KACrB,UAAQkO,aACrBhC,EAAIS,WAAa,IAAI,UAAO9M,EAAKG,GAIzC,CAEQ2N,YAAYF,GAClBA,EAAIpB,QAAQnD,SAAQ,CAACuB,EAAG1H,KACtBmJ,EAAIG,QAAQ5K,KAAK,IAAI,UAAcgJ,EAAE3N,EAAG2N,EAAE1N,EAAG,KAAO0N,EAAEvN,iBAAkB6F,GAAG,GAE/E,EAvJF,YACgB,EAAApC,MAAkB,GAClB,EAAA0L,QAAmB,GACnB,EAAAE,gBAA2B,E,eCpB3C,IAAK4B,E,iEAAL,SAAKA,GACH,qBACA,2BACA,6BACA,2BACA,8BACD,CAND,CAAKA,IAAAA,EAAO,KAQZ,kBAAuBJ,GACrB,OACEA,IAAYI,EAAQC,UACpBL,IAAYI,EAAQE,WACpBN,IAAYI,EAAQG,QAExB,EAEA,UAAeH,C,6FCdf,MAGMI,EAAgC,CACpCC,MAJF,QAKEC,MAJF,QAOa,EAAA9K,kBAAoBmG,OAAO4E,KAAKH,GAAMlT,OAEnD,mBAAmCsT,GACjC,MAAMC,EAAwBC,OAAOF,GAAaG,SAAS,EAAG,KAC9D,OAAOP,EAAK,MAAMK,IACpB,C,kECfA,gBAEA,gBAME/R,YACSgD,EACAG,EACAa,EACAM,EACA4N,EACAC,GAAwB,GALxB,KAAAnP,IAAAA,EACA,KAAAG,IAAAA,EACA,KAAAa,MAAAA,EACA,KAAAM,OAAAA,EACA,KAAA4N,MAAAA,EACA,KAAAC,aAAAA,EAEPvV,KAAKmH,KAAOZ,EAAMF,EAAOC,UACzBtG,KAAKyH,KAAOrB,EAAMC,EAAOC,SAC3B,E,kEClBF,gBAEA,UACA,UACA,UACA,UAEA,UAEA,MAAqBkP,UAAe,UAApC,c,oBACS,KAAArC,QAAS,EAOR,KAAAsC,QAAUD,EAAOE,aAGjB,KAAAC,iBAAgC,EAChC,KAAAhT,gBAAgC,IAChC,KAAAiT,8BAAgC,CAwC1C,CAtCE7S,OACM,UAAKuJ,aAAaC,aAAe,UAAYC,SAC/CxM,KAAKsC,mBAGP,EAAA7C,QAAQ6K,UAAYtK,KAAK6V,WACzB,EAAApW,QAAQ4K,YACN,EAAA5K,QAAQqW,KACN9V,KAAKqD,EACLrD,KAAKsD,EACL+C,EAAOC,UACPD,EAAOC,WAEX,EAAA7G,QAAQsW,MACV,CAEOzT,mBACLtC,KAAK2V,kBAAoB3V,KAAK2V,iBAAmB,UAASlT,mBAAqBzC,KAAK2C,gBAEpF3C,KAAK4V,8BAAgC5V,KAAK2V,iBAAmB3V,KAAK2C,gBAElE,MAAMqT,EAAe/T,KAAKgD,IAAIjF,KAAK4V,+BAA2C,EAAV3T,KAAKgU,KAEzEjW,KAAKyV,QAAUD,EAAOU,iBAAoBF,EAAe,GAAK,EAAKR,EAAOE,YAC5E,CAEOxW,OACLc,KAAKmT,QAAS,CAChB,CAEQ0C,WACN,OAAI7V,KAAKmT,OACA,QAAQqC,EAAOW,cAAcnW,KAAKyV,WAGlC,QAAQD,EAAOY,gBAAgBpW,KAAKyV,UAE/C,EApDF,YAGmB,EAAAU,UAAc,cACd,EAAAC,YAAc,cACd,EAAAF,gBAAkB,IAClB,EAAAR,aAAkB,E,gECfrC,gBASEtS,YACSgD,EACAG,GADA,KAAAH,IAAAA,EACA,KAAAG,IAAAA,CAET,E,kECbF,gBAEA,UACA,UACA,UAEA,MAAqB8P,UAAa,UAChCtT,OACE,EAAAtD,QAAQyP,YAAclP,KAAKsV,MAC3B,EAAA7V,QAAQ0P,UAAY,EACpB,EAAA1P,QAAQ4K,YAEN,EAAA5K,QAAQ2P,OAAQ,GAAMpP,KAAKqD,EAAuB,GAAMrD,KAAKsD,GAC7D,EAAA7D,QAAQ6P,QAAQ,GAAMtP,KAAKqD,EAAIgD,EAAOC,UAAY,GAAMtG,KAAKsD,GAC7D,EAAA7D,QAAQ6P,QAAQ,GAAMtP,KAAKqD,EAAIgD,EAAOC,WAAY,GAAMtG,KAAKsD,EAAI+C,EAAOC,WACxE,EAAA7G,QAAQ6P,OAAQ,GAAMtP,KAAKqD,GAAuB,GAAMrD,KAAKsD,EAAI+C,EAAOC,WACxE,EAAA7G,QAAQ6P,OAAQ,GAAMtP,KAAKqD,EAAuB,GAAMrD,KAAKsD,GAG7D,EAAA7D,QAAQ2P,OAAQ,GAAMpP,KAAKqD,EAAuB,GAAMrD,KAAKsD,GAC7D,EAAA7D,QAAQ6P,QAAQ,GAAMtP,KAAKqD,EAAIgD,EAAOC,WAAY,GAAMtG,KAAKsD,EAAI+C,EAAOC,WACxE,EAAA7G,QAAQ2P,QAAQ,GAAMpP,KAAKqD,EAAIgD,EAAOC,UAAY,GAAMtG,KAAKsD,GAC7D,EAAA7D,QAAQ6P,OAAQ,GAAMtP,KAAKqD,GAAuB,GAAMrD,KAAKsD,EAAI+C,EAAOC,WAC1E,EAAA7G,QAAQmL,QACV,CAEOiH,WAAWC,GAChB,UAAQwE,aACV,EAtBF,W,iECNA,gBAEA,UACA,UAEA,gBACS3W,kBAAkByG,EAAaG,EAAa+N,GACjD,OAAQA,GACN,KAAK,UAAQK,SACX,OAAO,IAAI,UAAKvO,EAAKG,EAAKF,EAAOC,UAAWD,EAAOC,UAAW,WAAW,GAC3E,KAAK,UAAQsO,UACX,OAAO,IAAI,UAAKxO,EAAKG,EAAKF,EAAOC,UAAWD,EAAOC,UAAW,WAChE,KAAK,UAAQuO,SACX,OAAO,IAAI,UAAKzO,EAAKG,EAAKF,EAAOC,UAAWD,EAAOC,UAAW,WAChE,QACE,MAAM,IAAIiQ,MAAM,iBAEtB,E,kECjBF,gBAEA,gBACS5W,cACL,MAAM6W,EAAkB,UAAOC,cAAcpT,EACvCqT,EAAkB,UAAOD,cAAcnT,EAC7C,IAAIqT,EACAC,EACJ,EAAAnX,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YAENsM,EAAW,GACXC,GAAW,IACX,EAAAnX,QAAQ2P,OAAOoH,EAAUG,EAASD,EAAUE,GAC5CA,GAAW,IACX,EAAAnX,QAAQ6P,OAAOkH,EAAUG,EAASD,EAAUE,GAG5CA,EAAU,IACV,EAAAnX,QAAQ2P,OAAOoH,EAAUG,EAASD,EAAUE,GAC5CA,EAAU,IACV,EAAAnX,QAAQ6P,OAAOkH,EAAUG,EAASD,EAAUE,GAG5CA,EAAW,GACXD,GAAW,IACX,EAAAlX,QAAQ2P,OAAOoH,EAAUG,EAASD,EAAUE,GAC5CD,GAAW,IACX,EAAAlX,QAAQ6P,OAAOkH,EAAUG,EAASD,EAAUE,GAG5CD,EAAU,IACV,EAAAlX,QAAQ2P,OAAOoH,EAAUG,EAASD,EAAUE,GAC5CD,EAAU,IACV,EAAAlX,QAAQ6P,OAAOkH,EAAUG,EAASD,EAAUE,GAC9C,EAAAnX,QAAQmL,QACV,E,kECrCF,gBAEA,UAEA,UACA,UACA,UAGA,UAEA,UACA,UAEA,UAEA,UAEA,UACA,QAEA,UAEA,UAEA,MAAqBiM,UAAe,UAYlCzT,YAAmBC,EAAkBC,GACnCyH,MAAM1H,EAAGC,EAAG,IAAI,UAAa,GAAI,IAAK,IAAM,GAD3B,KAAAD,EAAAA,EAAkB,KAAAC,EAAAA,EAX9B,KAAAwT,OAAiB,EACjB,KAAAC,SAAmB,EACnB,KAAAC,gBAAkB,GAEjB,KAAAC,iBAAoD,CAC1D,EAAG,IAAI,UACP,EAAG,IAAI,WAGD,KAAAC,cAA8BlX,KAAKiX,iBAAiB,GAoCpD,KAAAE,gBAAmBnG,IACzB,OAAQA,EAAEoG,SACR,KAAK,EAAAC,cAAcC,EACjBtX,KAAKsE,OAAOF,IAAK,EACjBpE,KAAKiE,iBAAiBG,IAAK,EAC3B,MACF,KAAK,EAAAiT,cAAc7E,EACjBxS,KAAKsE,OAAOJ,MAAO,EACnBlE,KAAKiE,iBAAiBC,MAAO,EAC7B,MACF,KAAK,EAAAmT,cAAcE,EACjBvX,KAAKsE,OAAOD,MAAO,EACnBrE,KAAKiE,iBAAiBI,MAAO,EAC7B,MACF,KAAK,EAAAgT,cAAcG,EACjBxX,KAAKsE,OAAOH,OAAQ,EACpBnE,KAAKiE,iBAAiBE,OAAQ,EAC9B,MACF,KAAK,EAAAkT,cAAc,GACjBrX,KAAKyX,cAAc,GACnB,MACF,KAAK,EAAAJ,cAAc,GACjBrX,KAAKyX,cAAc,G,EAUlB,KAAAC,aAAgB1G,IACrB,OAAQA,EAAEoG,SACR,KAAK,EAAAC,cAAcC,EACjBtX,KAAKsE,OAAOF,IAAK,EACjB,MACF,KAAK,EAAAiT,cAAc7E,EACjBxS,KAAKsE,OAAOJ,MAAO,EACnB,MACF,KAAK,EAAAmT,cAAcE,EACjBvX,KAAKsE,OAAOD,MAAO,EACnB,MACF,KAAK,EAAAgT,cAAcG,EACjBxX,KAAKsE,OAAOH,OAAQ,E,EA1EpBkC,EAAOsR,SAASC,2BAClB5X,KAAK6E,QAAQuL,cAAgB,IAAI,UAErC,CAEOhE,SACLpM,KAAKqF,eACLrF,KAAKsF,2BAELtF,KAAK6X,+BACL7X,KAAK4F,OACL5F,KAAKgH,2BACLhH,KAAKwG,mBACLxG,KAAKmF,oBAELkL,OAAOC,OAAOtQ,KAAKiX,kBAAkBxH,SAAQ6H,GAAKA,EAAElL,OAAOpM,KAAKqD,EAAGrD,KAAKsD,KAExE+M,OAAOC,OAAOtQ,KAAK6E,SAAS4K,SAAQc,GAAUA,EAAOnE,UACvD,CAEOrJ,OACL,MAAMiG,EAAQhJ,KAAK8X,iBACnB9X,KAAK+X,WAAW/O,GAChBhJ,KAAKgY,qBAAqBhP,GAE1B,UAAUjG,OAEVsN,OAAOC,OAAOtQ,KAAKiX,kBAAkBxH,SAAQ6H,GAAKA,EAAEvU,KAAK/C,KAAKqD,EAAGrD,KAAKsD,IACxE,CA4BW2U,qBACT,OAAOjY,KAAKmX,eACd,CACWc,mBAAe1W,GACxBvB,KAAKmX,gBAAkB5V,CACzB,CAkBOsQ,WAAWC,EAAsBM,EAAkC,MACxEpS,KAAKwJ,OAASxJ,KAAKwJ,OAASsI,EAExB9R,KAAK6E,QAAQuL,eACfpQ,KAAK6E,QAAQuL,cAAcpI,KACzB,EAAA+J,oBAAoBC,OAAOhS,KAAKqD,EAAGrD,KAAKsD,EAAGtD,KAAKuD,aAAcuO,EAAc,EAAAoG,mBAAmBC,KAAM/F,IAIrGpS,KAAKwJ,QAAU,EACjBxJ,KAAKiS,MAIE,OADCG,GAEJ,UAAQgG,eAIhB,CAEQN,iBACN,MAAM9O,EAAQ,EAAAC,mBAAmB,UAAOwN,cAAe,UAAOpH,QAG9D,OAFA,EAAA5P,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQiL,SAAS,OAAO1B,EAAMqP,QAAQ,KAAM,GAAI,IACzCrP,CACT,CAEQ+O,WAAW/O,GAEjB,EAAAvJ,QAAQ4K,YACR,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,iBAEf,EAAA9K,QAAQiL,SAAS,MAAM1K,KAAKqD,MAAMrD,KAAKsD,KAAM,GAAI,IAEjD,EAAA7D,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ0P,UAAY,EACpB,EAAA1P,QAAQ2P,OAAO,UAAOC,OAAOhM,EAAG,UAAOgM,OAAO/L,GAC9C,EAAA7D,QAAQ6P,OACN,UAAOD,OAAOhM,EAAIrD,KAAKgX,gBAAkB/U,KAAKqW,IAAItP,GAClD,UAAOqG,OAAO/L,EAAItD,KAAKgX,gBAAkB/U,KAAKgD,IAAI+D,IAEpD,EAAAvJ,QAAQmL,SAEJvE,EAAOuH,MAAM2K,sBACfvY,KAAK8N,yBAGPuC,OAAOC,OAAOtQ,KAAK6E,SAAS4K,SAAQc,GAAUA,EAAOC,OAAOxQ,KAAKqD,EAAGrD,KAAKsD,IAC3E,CAEQ0U,qBAAqBhP,GAC3BhJ,KAAKwY,oBAAoBxP,GAGrB3C,EAAOuH,MAAM6K,4BACfzY,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KACjChJ,KAAKwY,oBAAoBxP,EAAQ,IACjChJ,KAAKwY,oBAAoBxP,EAAQ,KAErC,CAEQwP,oBAAoBxP,GAC1B,MAAM,SAAE0P,EAAQ,QAAEC,GAAY,UAAUC,KAAK5Y,KAAMgJ,GAC/C0P,IACEC,EACF,UAAUE,QAAQH,EAAU,WAE5B,UAAUG,QAAQH,GAGxB,CAEQb,+BACN,MAAMiB,EAAkB,CACtBzV,EAAGrD,KAAKuF,MACRjC,EAAGtD,KAAKwF,MACRjC,aAAcvD,KAAKuD,cAEfwV,EAAkB,UAAIhI,mBAAmB/Q,KAAKqD,EAAGrD,KAAKsD,GAG1DyV,EAAgBC,MAAMhI,GAAM,EAAArK,wBAAwBqK,EAAG8H,MAEvDC,EAAgBtJ,SAASuB,IACnBA,EAAElN,OAAS,UAAckI,OAG7BhM,KAAKyG,yBAAyBuK,EAAG8H,EAAgB,GAGvD,CAEOG,YAAYC,GACjB7I,OAAOC,OAAOtQ,KAAKiX,kBAAkBxH,SAAQ6H,GAAKA,EAAE2B,aAAY,KAChEjZ,KAAKkX,cAAc+B,YAAYC,EACjC,CAEQzB,cAAc0B,GACpBnZ,KAAKkX,cAAgBlX,KAAKiX,iBAAiBkC,EAC7C,CAEQlH,MAENjS,KAAK8W,OAAQ,EAEb,UAAQsC,iBACV,CAEQtL,yBACN,EAAArO,QAAQyP,YAAclP,KAAKyJ,iBAE3B,EAAAhK,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YAGR,EAAA5K,QAAQ2P,QACL,GAAM,UAAOC,OAAOhM,EAAIrD,KAAKuD,aAAauD,WAC1C,GAAM,UAAOuI,OAAO/L,EAAItD,KAAKuD,aAAawD,YAE7C,EAAAtH,QAAQ6P,OACL,GAAM,UAAOD,OAAOhM,EAAIrD,KAAKuD,aAAauD,WAC1C,GAAM,UAAOuI,OAAO/L,EAAItD,KAAKuD,aAAawD,YAE7C,EAAAtH,QAAQ6P,OACN,GAAM,UAAOD,OAAOhM,EAAIrD,KAAKuD,aAAauD,UAC1C,GAAM,UAAOuI,OAAO/L,EAAItD,KAAKuD,aAAawD,YAE5C,EAAAtH,QAAQ6P,QACL,GAAM,UAAOD,OAAOhM,EAAIrD,KAAKuD,aAAauD,UAC1C,GAAM,UAAOuI,OAAO/L,EAAItD,KAAKuD,aAAawD,YAE7C,EAAAtH,QAAQ6P,QACL,GAAM,UAAOD,OAAOhM,EAAIrD,KAAKuD,aAAauD,WAC1C,GAAM,UAAOuI,OAAO/L,EAAItD,KAAKuD,aAAawD,YAE7C,EAAAtH,QAAQmL,QACV,EAxPF,W,gECzBA,gBAYExH,YACSC,EACAC,EACA+V,EACAC,GAHA,KAAAjW,EAAAA,EACA,KAAAC,EAAAA,EACA,KAAA+V,WAAAA,EACA,KAAAC,WAAAA,CAET,E,gEClBF,gBAEA,UAEA,UAEA,UAEA,UAWA,MAAqBC,UAAyB,UAW5CnW,YACEC,EACAC,EACA+V,EACAC,GAEAvO,MAAM1H,EAAGC,EAAG+V,EAAYC,GAhBnB,KAAA9V,MAAgB,GAChB,KAAAgW,OAAiB,EACjB,KAAA1C,OAAiB,EAKhB,KAAA2C,8BAAwC,EACxC,KAAAC,sBAA6C,GASnD,IAAK,IAAIpQ,EAAI,EAAGA,EAAItJ,KAAKyZ,gCAAiCnQ,EACxDtJ,KAAK0Z,sBAAsBpQ,GAAK,CAAEjG,EAAG,KAAMC,EAAG,KAAM8C,IAAK,KAAMG,IAAK,KAExE,CAEO6F,OAAOsE,EAAiBC,GAC7B3Q,KAAK2Z,UAAY3Z,KAAKqD,EACtBrD,KAAK4Z,UAAY5Z,KAAKsD,EACtBtD,KAAKqD,GAAKrD,KAAKqZ,WAAarZ,KAAKwD,MACjCxD,KAAKsD,GAAKtD,KAAKsZ,WAAatZ,KAAKwD,MACjCxD,KAAKoG,IAAMnE,KAAKC,MAAMlC,KAAKsD,EAAI+C,EAAOC,WACtCtG,KAAKuG,IAAMtE,KAAKC,MAAMlC,KAAKqD,EAAIgD,EAAOC,WAEtC,MAAMuT,EAAgB7Z,KAAK8Z,mBAE3B9Z,KAAK+Z,8BAED/Z,KAAKga,YAAYtJ,EAASC,KAC5B3Q,KAAK8W,OAAQ,GAGf9W,KAAK0Z,sBAAsBjK,SAAQwK,IAC7Bja,KAAK8W,QACP9W,KAAKka,0BAA0BL,EAAeI,GAC9Cja,KAAKma,uBAAuBF,G,IAG5Bja,KAAK8W,QACP9W,KAAKka,0BAA0BL,GAC/B7Z,KAAKma,yBAET,CAEOpX,KAAK2N,EAAiBC,GACvB3Q,KAAKqD,IAAMqN,GAAW1Q,KAAKsD,IAAMqN,IAIrC,EAAAlR,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ0P,UAAY,EACpB,EAAA1P,QAAQ4K,YACR,EAAA5K,QAAQ2a,IACNpa,KAAKqD,EAAI,UAAOgM,OAAOhM,EAAIqN,EAC3B1Q,KAAKsD,EAAI,UAAO+L,OAAO/L,EAAIqN,EAC3B,GACA,EACC,EAAI1O,KAAKgU,IAEZ,EAAAxW,QAAQmL,SACV,CAIQkP,mBACN,MAAO,IAAK,UAAIlH,SAAUC,QAAO7B,GAC/B/O,KAAKyM,IAAIsC,EAAE3N,EAAIrD,KAAKqD,IAAMgD,EAAOC,WACjCrE,KAAKyM,IAAIsC,EAAE1N,EAAItD,KAAKsD,IAAM+C,EAAOC,WAErC,CAUQyT,8BACN,MAAMM,GAAyBra,KAAKqD,EAAIrD,KAAK2Z,YAAc3Z,KAAKyZ,8BAAgC,GAC1Fa,GAAyBta,KAAKsD,EAAItD,KAAK4Z,YAAc5Z,KAAKyZ,8BAAgC,GAChG,IAAK,IAAInQ,EAAItJ,KAAKyZ,8BAAgC,EAAGnQ,GAAK,IAAKA,EAC7DtJ,KAAK0Z,sBAAsBpQ,GAAGjG,EAAIrD,KAAKqD,EAAIgX,GAAyB/Q,EAAI,GACxEtJ,KAAK0Z,sBAAsBpQ,GAAGhG,EAAItD,KAAKsD,EAAIgX,GAAyBhR,EAAI,GACxEtJ,KAAK0Z,sBAAsBpQ,GAAGlD,IAAMnE,KAAKC,MAAMlC,KAAK0Z,sBAAsBpQ,GAAGhG,EAAI+C,EAAOC,WACxFtG,KAAK0Z,sBAAsBpQ,GAAG/C,IAAMtE,KAAKC,MAAMlC,KAAK0Z,sBAAsBpQ,GAAGjG,EAAIgD,EAAOC,UAE5F,CAEQ0T,YAAYtJ,EAAiBC,GACnC,OACE3Q,KAAKqD,EAAIqN,EAAU,UAAOrB,OAAOhM,EAAIgD,EAAOC,WAAatG,KAAKqD,EAAIqN,EAAU,UAAOrB,OAAOhM,EAAIgD,EAAOC,WACrGtG,KAAKsD,EAAIqN,EAAU,UAAOtB,OAAO/L,EAAI+C,EAAOC,WAAatG,KAAKsD,EAAIqN,EAAU,UAAOtB,OAAO/L,EAAI+C,EAAOC,SAEzG,CAEQ4T,0BAA0BL,EAAwBU,GACnDA,IACHA,EAAQva,MAGV6Z,EAAcpK,SAAQuB,IACpB,GACEuJ,EAAMlX,GAAK2N,EAAE3N,EAAI2N,EAAEzN,aAAauD,WAChCyT,EAAMlX,GAAK2N,EAAE3N,EAAI2N,EAAEzN,aAAauD,WAChCyT,EAAMjX,GAAK0N,EAAE1N,EAAI0N,EAAEzN,aAAawD,YAChCwT,EAAMjX,GAAK0N,EAAE1N,EAAI0N,EAAEzN,aAAawD,WAChC,CAEA,GAAIiK,EAAElN,OAAS,UAAckI,MAC3B,OAGFhM,KAAK8W,OAAQ,EACb9F,EAAEa,WAAW7R,KAAKqS,Y,IAGxB,CAEQ8H,uBAAuBI,GACxBA,IACHA,EAAQva,MAGV,MAAMiH,EAAO,UAAIC,MAAMqT,EAAMnU,KAAKmU,EAAMhU,KACpCU,IACAA,EAAK4K,WAAW7R,KAAKqS,aACrBrS,KAAK8W,OAAQ,EACT7P,EAAKsO,eACP,UAAIrO,MAAMqT,EAAMnU,KAAKmU,EAAMhU,KAAO,MAG1C,CAEQ8L,YACN,OAAOrS,KAAKwZ,MACd,EAhJF,W,kECnBA,gBAEA,UAEA,UAEA,UAEA,UASA,MAAqBgB,UAAuB,UAW1CpX,YACEC,EACAC,EACA+V,EACAC,GAEAvO,MAAM1H,EAAGC,EAAG+V,EAAYC,GAhBnB,KAAA9V,MAAgB,GAChB,KAAAgW,OAAiB,EACjB,KAAA1C,OAAiB,EAKhB,KAAA2C,8BAAwC,EACxC,KAAAC,sBAA6C,GASnD,IAAK,IAAIpQ,EAAI,EAAGA,EAAItJ,KAAKyZ,gCAAiCnQ,EACxDtJ,KAAK0Z,sBAAsBpQ,GAAK,CAAEjG,EAAG,KAAMC,EAAG,KAAM8C,IAAK,KAAMG,IAAK,KAExE,CAEO6F,OAAOsE,EAAiBC,GAC7B3Q,KAAK2Z,UAAY3Z,KAAKqD,EACtBrD,KAAK4Z,UAAY5Z,KAAKsD,EACtBtD,KAAKqD,GAAKrD,KAAKqZ,WAAarZ,KAAKwD,MACjCxD,KAAKsD,GAAKtD,KAAKsZ,WAAatZ,KAAKwD,MACjCxD,KAAKoG,IAAMnE,KAAKC,MAAMlC,KAAKsD,EAAI+C,EAAOC,WACtCtG,KAAKuG,IAAMtE,KAAKC,MAAMlC,KAAKqD,EAAIgD,EAAOC,WAEtC,MAAMuT,EAAgB7Z,KAAK8Z,mBAE3B9Z,KAAK+Z,8BAED/Z,KAAKga,YAAYtJ,EAASC,KAC5B3Q,KAAK8W,OAAQ,GAGf9W,KAAK0Z,sBAAsBjK,SAAQwK,IAC7Bja,KAAK8W,QACP9W,KAAKka,0BAA0BL,EAAeI,GAC9Cja,KAAKma,uBAAuBF,G,IAG5Bja,KAAK8W,QACP9W,KAAKka,0BAA0BL,GAC/B7Z,KAAKma,yBAET,CAEOpX,KAAK2N,EAAiBC,GACvB3Q,KAAKqD,IAAMqN,GAAW1Q,KAAKsD,IAAMqN,IAIrC,EAAAlR,QAAQyP,YAAc,SACtB,EAAAzP,QAAQ0P,UAAY,EAEpB,EAAA1P,QAAQ4K,YACN,EAAA5K,QAAQ4K,YACN,EAAA5K,QAAQ2P,OACNpP,KAAKqD,EAAI,UAAOgM,OAAOhM,EAAIqN,EAC3B1Q,KAAKsD,EAAI,UAAO+L,OAAO/L,EAAIqN,GAE7B,EAAAlR,QAAQ6P,OACNtP,KAAK2Z,UAAY,UAAOtK,OAAOhM,EAAIqN,EACnC1Q,KAAK4Z,UAAY,UAAOvK,OAAO/L,EAAIqN,GAEzC,EAAAlR,QAAQmL,SACV,CAIQkP,mBACN,MAAO,IAAK,UAAIlH,SAAUC,QAAO7B,GAC/B/O,KAAKyM,IAAIsC,EAAE3N,EAAIrD,KAAKqD,IAAMgD,EAAOC,WACjCrE,KAAKyM,IAAIsC,EAAE1N,EAAItD,KAAKsD,IAAM+C,EAAOC,WAErC,CAUQyT,8BACN,MAAMM,GAAyBra,KAAKqD,EAAIrD,KAAK2Z,YAAc3Z,KAAKyZ,8BAAgC,GAC1Fa,GAAyBta,KAAKsD,EAAItD,KAAK4Z,YAAc5Z,KAAKyZ,8BAAgC,GAChG,IAAK,IAAInQ,EAAItJ,KAAKyZ,8BAAgC,EAAGnQ,GAAK,IAAKA,EAC7DtJ,KAAK0Z,sBAAsBpQ,GAAGjG,EAAIrD,KAAKqD,EAAIgX,GAAyB/Q,EAAI,GACxEtJ,KAAK0Z,sBAAsBpQ,GAAGhG,EAAItD,KAAKsD,EAAIgX,GAAyBhR,EAAI,GACxEtJ,KAAK0Z,sBAAsBpQ,GAAGlD,IAAMnE,KAAKC,MAAMlC,KAAK0Z,sBAAsBpQ,GAAGhG,EAAI+C,EAAOC,WACxFtG,KAAK0Z,sBAAsBpQ,GAAG/C,IAAMtE,KAAKC,MAAMlC,KAAK0Z,sBAAsBpQ,GAAGjG,EAAIgD,EAAOC,UAE5F,CAEQ0T,YAAYtJ,EAAiBC,GACnC,OACE3Q,KAAKqD,EAAIqN,EAAU,UAAOrB,OAAOhM,EAAIgD,EAAOC,WAAatG,KAAKqD,EAAIqN,EAAU,UAAOrB,OAAOhM,EAAIgD,EAAOC,WACrGtG,KAAKsD,EAAIqN,EAAU,UAAOtB,OAAO/L,EAAI+C,EAAOC,WAAatG,KAAKsD,EAAIqN,EAAU,UAAOtB,OAAO/L,EAAI+C,EAAOC,SAEzG,CAEQ4T,0BAA0BL,EAAwBU,GACnDA,IACHA,EAAQva,MAGV6Z,EAAcpK,SAAQuB,IACpB,GACEuJ,EAAMlX,GAAK2N,EAAE3N,EAAI2N,EAAEzN,aAAauD,WAChCyT,EAAMlX,GAAK2N,EAAE3N,EAAI2N,EAAEzN,aAAauD,WAChCyT,EAAMjX,GAAK0N,EAAE1N,EAAI0N,EAAEzN,aAAawD,YAChCwT,EAAMjX,GAAK0N,EAAE1N,EAAI0N,EAAEzN,aAAawD,WAChC,CAEA,GAAIiK,EAAElN,OAAS,UAAckI,MAC3B,OAGFhM,KAAK8W,OAAQ,EACb9F,EAAEa,WAAW7R,KAAKqS,Y,IAGxB,CAEQ8H,uBAAuBI,GACxBA,IACHA,EAAQva,MAGV,MAAMiH,EAAO,UAAIC,MAAMqT,EAAMnU,KAAKmU,EAAMhU,KACpCU,IACAA,EAAK4K,WAAW7R,KAAKqS,aACrBrS,KAAK8W,OAAQ,EACT7P,EAAKsO,eACP,UAAIrO,MAAMqT,EAAMnU,KAAKmU,EAAMhU,KAAO,MAG1C,CAEQ8L,YACN,OAAOrS,KAAKwZ,MACd,EAnJF,W,kECjBA,gBAEA,UACA,UAIA,UAEA,8BAMY,KAAAiB,UAAW,EASd,KAAAC,YAA4B,EAkErC,CAhEStO,OAAOsE,EAAiBC,GAC7B3Q,KAAK2a,MAAMjK,EAASC,GACpB3Q,KAAK0a,YAAYjL,SAAQ,CAACD,EAAGlG,KAC3BkG,EAAEpD,OAAOsE,EAASC,IACF,IAAZnB,EAAEsH,OACJ9W,KAAK4a,iBAAiBtR,E,GAG5B,CAEOvG,KAAK2N,EAAiBC,GAC3B3Q,KAAK0a,YAAYjL,SAASD,GAAMA,EAAEzM,KAAK2N,EAASC,IAClD,CAEOgK,MAAMjK,EAAiBC,GACxB3Q,KAAK6a,UAAY,IACnB7a,KAAK6a,UAAY,UAASzQ,iBACtBpK,KAAK6a,SAAW,IAClB7a,KAAK6a,SAAW,KAIE,IAAlB7a,KAAKya,UAILza,KAAK6a,UAAY,IAEnB7a,KAAK8a,eAAepK,EAASC,GAC7B3Q,KAAKwL,sBAEL,UAAQuP,UAEZ,CAEOD,eAAepK,EAAiBC,GACrC,MAAMqK,EAAK,UAAOvE,cAAcpT,EAAI,UAAOgM,OAAOhM,EAC5C4X,EAAK,UAAOxE,cAAcnT,EAAI,UAAO+L,OAAO/L,EAClD,IAAI4X,EAAOF,GAAM/Y,KAAKyM,IAAIsM,GAAM/Y,KAAKyM,IAAIuM,IACrCE,EAAOF,GAAMhZ,KAAKyM,IAAIsM,GAAM/Y,KAAKyM,IAAIuM,IAIrC5U,EAAOsR,SAASyD,sBAGlBF,GAFsC,GAAhBjZ,KAAKE,SAAiB,IAG5CgZ,GAFsC,GAAhBlZ,KAAKE,SAAiB,KAK9CnC,KAAK0a,YAAY1S,KAAK,IAAIhI,KAAKqb,sBAAsB3K,EAASC,EAASuK,EAAMC,GAC/E,CAEOlC,YAAYC,GACjBlZ,KAAKya,SAAWvB,CAClB,CAEU0B,iBAAiBU,GACzBtb,KAAK0a,YAAY1H,OAAOsI,EAAiB,EAC3C,CAEU9P,sBACRxL,KAAK6a,SAAW7a,KAAKub,WACvB,E,gECzFF,gBAEA,QAEA,UAEA,MAAqBC,UAAkB,UAAvC,c,oBAEY,KAAAC,YAAc,GACd,KAAAZ,SAAc,EACd,KAAAU,YAAe,IAAOvb,KAAKyb,YAAepV,EAAO8E,WAEjD,KAAAkQ,sBAAwB,SACpC,EAPA,W,kECNA,gBAEA,UAEA,UAEA,MAAqBG,UAAkB,UAAvC,c,oBAEY,KAAAC,YAAc,IACd,KAAAZ,SAAc,EACd,KAAAU,YAAe,IAAOvb,KAAKyb,YAAepV,EAAO8E,WAEjD,KAAAkQ,sBAAwB,SACpC,EAPA,W,mICNA,gBAEA,UACA,UAEA,UACA,UAQA,IAAYnD,GAAZ,SAAYA,GACV,oBACA,wBACA,sBACD,CAJD,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAM9B,4BACSvY,cACL0D,EACAC,EACAC,EACAiW,EACAlE,EAA4B4C,EAAmBwD,IAC/CtJ,EAAkC,MAElC,OAAO,IAAIuJ,EACTtY,EACAC,EAA8B,GAA1BC,EAAawD,WAChB9E,KAAKE,SAAWoB,EAAamE,OAAgBnE,EAAawD,WAC1D9E,KAAKE,SAAWoB,EAAa6D,MAAS,IAAO7D,EAAauD,UAAY,IACvEsL,GAAkCoH,EAAOjK,WACzC+F,EAEJ,GAGF,MAAaqG,EACXvY,YACSC,EACAC,EACGsY,EACAC,EACFrC,EACAlE,GALD,KAAAjS,EAAAA,EACA,KAAAC,EAAAA,EACG,KAAAsY,cAAAA,EACA,KAAAC,cAAAA,EACF,KAAArC,OAAAA,EACA,KAAAlE,MAAAA,EAKH,KAAA/S,mBAAoB,EAGnB,KAAAoT,iBAAgC,EAChC,KAAAhT,gBAAgC,IAChC,KAAAiT,8BAAgC,EAChC,KAAAkG,UAAgC,GAahC,KAAAC,SAAW,EACX,KAAAxR,KAAO,GAAGvK,KAAK+b,uBACf,KAAAC,UAAYhc,KAAK+b,SAAW,EAC5B,KAAAE,oBAA8B,EAzBpCjc,KAAKic,oBAAuBjc,KAAKwZ,OAAO5X,OAAS5B,KAAKgc,UAAa,CACrE,CAUO1Z,mBACLtC,KAAK2V,kBAAoB,UAASlT,kBAClCzC,KAAK4V,8BAAgC5V,KAAK2V,iBAAmB3V,KAAK2C,gBAC9D3C,KAAKkc,yBACPlc,KAAKuC,mBAAoB,EAE7B,CACO2Z,uBACL,OAAQlc,KAAK2V,kBAAoB3V,KAAK2C,eACxC,CAOOI,KAAK2N,EAAiBC,GAC3B,EAAAlR,QAAQ4K,YACN,MAAMoL,EAAU,EAAIzV,KAAK4V,8BACzB,EAAAnW,QAAQ6K,UAAY,QAAQtK,KAAKsV,UAAUG,KAC3C,EAAAhW,QAAQ8K,KAAOvK,KAAKuK,KACpB,EAAA9K,QAAQiL,SACN,GAAG1K,KAAKwZ,SACRxZ,KAAK4b,eAAiB5b,KAAKqD,EAAI,UAAOgM,OAAOhM,EAAIqN,GAAW1Q,KAAKic,oBACjEjc,KAAK6b,eAAiB7b,KAAKsD,EAAI,UAAO+L,OAAO/L,EAAIqN,GAAY3Q,KAAK4V,8BAAgC5V,KAAK8b,WAE3G,EAAArc,QAAQmL,QACV,EA/CF,iBAkDA,8BAEU,KAAAwF,cAAgC,EA4B1C,CA1BShE,SACD,UAAKE,aAAaC,aAAe,UAAYC,SAC/CxM,KAAKoQ,cAAcX,SAAQ,CAAC0M,EAAQ7S,KAClC6S,EAAO7Z,oBAE0B,IAA7B6Z,EAAO5Z,mBACTvC,KAAKoQ,cAAc4C,OAAO1J,EAAG,E,GAIrC,CAEOkH,OAAOE,EAAiBC,GACzBtK,EAAOsR,SAASyE,qBAClBpc,KAAKqc,0BAA0B3L,EAASC,EAE5C,CAEO3I,KAAKsU,GACVtc,KAAKoQ,cAAcpI,KAAKsU,EAC1B,CAGOD,0BAA0B3L,EAAiBC,GAChD3Q,KAAKoQ,cAAcX,SAAQ8M,GAAaA,EAAUxZ,KAAK2N,EAASC,IAClE,E,iECvHF,gBAEA,gBACShR,kBAAkBW,GACvB,UAAQT,KAAKS,EACf,E,kECJF,gBACA,SAEA,MAAqBkc,EAIZ7c,kBAAkBW,SACjBkc,EAAQtM,MAAMrQ,MAAK,IAAMS,EAAoB,YAC7Ckc,EAAQvM,KAAKpQ,MAAK,IAAMS,EAAoB,IACpD,EAPF,YACgB,EAAA2P,KAAwB,IAAI,UAC5B,EAAAC,MAAwB,IAAI,S,gECH5C,gBAMSrQ,KAAK4c,GACV,OAAO,IAAI5d,SAAQ,CAACC,EAAS4d,KAC3B1c,KAAK2c,YAAc,IAAIC,MACvB5c,KAAK2c,YAAYE,IAAM7c,KAAK8c,IAC5B9c,KAAK2c,YAAYvd,OAAS,KACxBqd,IACA3d,GAAS,CACV,GAEL,E,iEClBF,gBAIA,UAGA,MAAqBie,UAAoB,UA2BvC3Z,cACE2H,QA3BK,KAAA+R,IAAc,oCAGb,KAAAE,iBAAmB,CACzBC,MAAO,CACL7V,MAAO,GACPM,OAAQ,GACRwV,KAAM,EACNC,KAAM,IAIF,KAAAC,0BAA4B,CAClCH,MAAO,CACL,CACEI,GAAI,GAAKrd,KAAKgd,iBAAiBC,MAAMvV,OAAS1H,KAAKgd,iBAAiBC,MAAME,MAAQ,GAEpF,CACEE,GAAI,GAAKrd,KAAKgd,iBAAiBC,MAAMvV,OAAS1H,KAAKgd,iBAAiBC,MAAME,MAAQ,GAEpF,CACEE,GAAI,GAAKrd,KAAKgd,iBAAiBC,MAAMvV,OAAS1H,KAAKgd,iBAAiBC,MAAME,MAAQ,IAOxF,CAEOpa,KAAKua,EAAoBra,EAA0BL,GACxD5C,KAAKud,gBAAgBD,EAAUra,EAAmBL,EACpD,CAEQ2a,gBACND,EACAra,EACAL,GAGA,MAAM,EAAES,EAAC,EAAEC,GAAMga,GACTja,EAAGma,EAAIla,EAAGma,GAAOxa,EAEnBya,EAAmBzb,KAAKC,MAAMlC,KAAKgd,iBAAiBC,MAAM7V,OAAUkW,EAAS/Z,aAAa6D,MAAS,KACnGuW,EAAmB1b,KAAKC,MAAMlC,KAAKgd,iBAAiBC,MAAMvV,QAAU4V,EAAS/Z,aAAamE,OAAS,KAInGkW,EAAW,GADON,EAASja,EAAIia,EAASha,GADjB,GAEWtD,KAAKgd,iBAAiBC,MAAM7V,MAAQpH,KAAKgd,iBAAiBC,MAAMC,MAExG,EAAAzd,QAAQoe,UACN7d,KAAK2c,YACLiB,EACA5d,KAAKod,0BAA0BH,MAAMra,GAAyBya,GAC9Drd,KAAKgd,iBAAiBC,MAAM7V,MAC5BpH,KAAKgd,iBAAiBC,MAAMvV,OAC5B,UAAO2H,OAAOhM,GAAKA,EAAIma,EAAKE,EAAmB,GAC/C,UAAOrO,OAAO/L,GAAKA,EAAIma,EAAKE,EAAmB,GAC/CD,EACAC,EAEJ,EA9DF,W,kECPA,gBAEA,UAEA,UAGA,MAAqBG,UAAmB,UA4DtC1a,cACE2H,QA5DK,KAAA+R,IAAc,uCAEb,KAAAiB,gBAAqE,CAC3EpV,EAAI,CAAEpC,IAAK,EAAGyX,MAAM,GACpBC,GAAI,CAAE1X,IAAK,EAAGyX,MAAM,GACpBpV,EAAI,CAAErC,IAAK,EAAGyX,MAAM,GACpBE,GAAI,CAAE3X,IAAK,EAAGyX,MAAM,GACpBtV,EAAI,CAAEnC,IAAK,EAAGyX,MAAM,GACpBG,GAAI,CAAE5X,IAAK,EAAGyX,MAAM,GACpBnV,EAAI,CAAEtC,IAAK,EAAGyX,MAAM,GACpBI,GAAI,CAAE7X,IAAK,EAAGyX,MAAM,IAGd,KAAAhB,iBAAmB,CACzBqB,QAAS,CACPjX,MAAO,GACPM,OAAQ,IAEV4W,MAAO,CACLlX,MAAO,GACPM,OAAQ,GACRwV,KAAM,EACNG,GAAI,MAIA,KAAAD,0BAA4B,CAClCkB,MAAO,CACL,CACEC,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,IAElC,CACEkB,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,IAElC,CACEkB,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,IAElC,CACEkB,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,IAElC,CACEkB,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,IAElC,CACEkB,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,IAElC,CACEkB,GAAI,GAAKve,KAAKgd,iBAAiBsB,MAAMlX,MAAQpH,KAAKgd,iBAAiBsB,MAAMpB,MAAQ,EACjFG,GAAIrd,KAAKgd,iBAAiBsB,MAAMjB,KAOtC,CAEOta,KAAKua,EAAoBra,EAA0BL,GACxD,GAAI0a,EAASxZ,QAAU,UAAckI,MACnChM,KAAKwe,gBAAgBlB,EAAUra,EAAmBL,OAE/C,CACH,MAAM6b,EAAeze,KAAKgd,iBAAiBqB,QAAQjX,MAC7CsX,EAAe1e,KAAKgd,iBAAiBqB,QAAQ3W,OAC7CiX,EAAoB,CAAEtb,EAAGob,EAAc,GAAInb,EAAGob,EAAe,IAC7DE,EAAuB5e,KAAK6e,iBAAiBvB,EAASxZ,MAAO6a,GAC7DG,EAAiB9e,KAAK+d,gBAAgBT,EAASvX,WACrD/F,KAAK+e,WAAWzB,EAAUra,EAAmB2b,EAAeD,EAAYG,EAAgBL,EAAaC,EAAc9b,E,CAEvH,CAEQic,iBAAiBG,EAA8BL,GACrD,MAAMM,EAAsB,CAC1B5b,EAAG,EACHC,EAAG,GAEL,OAAQ0b,GACN,KAAK,UAAcjb,OACnB,KAAK,UAAc4H,OACnB,KAAK,UAAcrD,eACnB,KAAK,UAAcD,kBACjB,OAAO4W,EACT,KAAK,UAAc7W,UAEjB,MAAO,CACL/E,EAAG4b,EAAoB5b,EACvBC,EAAG2b,EAAoB3b,EAHE,EAGwBqb,EAAWrb,GAGpE,CAEQkb,gBACNlB,EACAra,EACAL,GAGA,MAAM,EAAES,EAAC,EAAEC,GAAMga,GACTja,EAAGma,EAAIla,EAAGma,GAAOxa,EAEnBya,EAAmBzb,KAAKC,MAAMlC,KAAKgd,iBAAiBsB,MAAMlX,OAAUkW,EAAS/Z,aAAa6D,MAAS,KACnGuW,EAAmB1b,KAAKC,MAAMlC,KAAKgd,iBAAiBsB,MAAM5W,QAAU4V,EAAS/Z,aAAamE,OAAS,KAEzG,EAAAjI,QAAQoe,UACN7d,KAAK2c,YACL3c,KAAKod,0BAA0BkB,MAAM1b,GAAyB2b,GAC9Dve,KAAKod,0BAA0BkB,MAAM1b,GAAyBya,GAC9Drd,KAAKgd,iBAAiBsB,MAAMlX,MAC5BpH,KAAKgd,iBAAiBsB,MAAM5W,OAC5B,UAAO2H,OAAOhM,GAAKA,EAAIma,EAAKE,EAAmB,GAC/C,UAAOrO,OAAO/L,GAAKA,EAAIma,EAAKE,EAAmB,GAC/CD,EACAC,EAEJ,CAEQoB,WACNzB,EACAra,EACA2b,EACAD,EACAG,EACAL,EACAC,EACA9b,GAGA,MAAM,EAAES,EAAC,EAAEC,EAAGC,aAAc2b,GAAS5B,GAC7Bja,EAAGma,EAAIla,EAAGma,GAAOxa,EAErB6b,EAAed,OACjB,EAAAve,QAAQ0f,OACR,EAAA1f,QAAQ2f,UACN,UAAO/P,OAAOhM,GAAKA,EAAIma,EAAK0B,EAAKpY,WACjC,UAAOuI,OAAO/L,GAAKA,EAAIma,EAAKyB,EAAKnY,aAEnC,EAAAtH,QAAQ4f,OAAO,EAAG,IAGpB,MAAM3B,EAAmBJ,EAAS/Z,aAAa6D,MAAS,EAClDuW,EAAmBL,EAAS/Z,aAAamE,OAAS,EAExD,EAAAjI,QAAQoe,UACN7d,KAAK2c,YACLiC,EAAcvb,EAAIsb,EAAWtb,EAAIyb,EAAevY,IAChDqY,EAActb,EAAIqb,EAAWrb,EAAIrB,KAAKC,MAAMU,GAC5C6b,EACAC,EACAI,EAAed,KAAO,EAAIS,EAAc,EAAI,UAAOpP,OAAOhM,GAAKA,EAAIma,EAAK0B,EAAKpY,WAC7EgY,EAAed,KAAO,EAAsB,UAAO3O,OAAO/L,GAAKA,EAAIma,EAAKyB,EAAKnY,YAC7E2W,EACAC,GAGEmB,EAAed,MACjB,EAAAve,QAAQ6f,SAEZ,EApKF,W,mFCPA,gBAGA,UAEMC,EAASC,SAASC,eAAe,UACvCF,EAAOnY,MAASf,EAAOwK,aACvB0O,EAAO7X,OAASrB,EAAOsE,cACvB4U,EAAOG,MAAMtY,MAA0B,IAAjBf,EAAOsZ,MAAetZ,EAAOsZ,MAAQtZ,EAAOwK,aAAiB,KAAO,OAC1F0O,EAAOG,MAAMhY,OAA0B,IAAjBrB,EAAOsZ,MAAetZ,EAAOsZ,MAAQtZ,EAAOsE,cAAiB,KAAO,OAC7E,EAAAlL,QAAU8f,EAAOK,WAAW,MAEzC,EAAAngB,QAAA,uBAAgC,EAEhC,MAAqBogB,EAgBZlgB,eACL,EAAAF,QAAQqgB,UAAU,EAAG,EAAGP,EAAOnY,MAAOmY,EAAO7X,OAC/C,CAIO/H,6BACLK,KAAKyW,cAAgB,CACnBpT,EAAGpB,KAAKC,OAAO,UAAMmB,EAAIkc,EAAOjM,YAAcjN,EAAOsZ,OACrDrc,EAAGrB,KAAKC,OAAO,UAAMoB,EAAIic,EAAO/L,WAAcnN,EAAOsZ,OAEzD,EA3BF,YACgB,EAAA7Y,UAAayY,EAAOnY,MAAS,EAC7B,EAAAL,WAAawY,EAAO7X,OAAS,EAC7B,EAAAoM,KAAO7R,KAAKC,MAAMqd,EAAO7X,OAASrB,EAAOC,WACzC,EAAAyN,KAAO9R,KAAKC,MAAMqd,EAAOnY,MAASf,EAAOC,WACzC,EAAAqN,SAAW1R,KAAKC,MAAOqd,EAAO7X,OAAS,EAAKrB,EAAOC,WACnD,EAAAuN,SAAW5R,KAAKC,MAAOqd,EAAOnY,MAAS,EAAKf,EAAOC,WACnD,EAAAmN,aAAgB8L,EAAO7X,OAAS,EAAKrB,EAAOC,UAC5C,EAAAiN,aAAgBgM,EAAOnY,MAAS,EAAKf,EAAOC,UAG5C,EAAA+I,OAAgB,CAC5BhM,EAAGgD,EAAOwK,aAAgB,EAC1BvN,EAAG+C,EAAOsE,cAAgB,GAOd,EAAAoV,oBAAsB,IAAyBR,C,mGClC/D,gBAEA,gBAGEnc,YACSgE,EACAM,GAGP,GAJO,KAAAN,MAAAA,EACA,KAAAM,OAAAA,EAGHrB,EAAO2Z,2BACL5Y,EAAQ,GAAM,GAAKM,EAAS,GAAM,GACpC,MAAM,IAAI6O,MAAM,yDAGpBvW,KAAK8G,UAAa9G,KAAKoH,MAAS,EAChCpH,KAAK+G,WAAa/G,KAAK0H,OAAS,CAClC,GASF,mCAAwC8K,EAAgByN,GACtD,OACEzN,EAAEnP,EAAImP,EAAEjP,aAAauD,UAAamZ,EAAE5c,EAAI4c,EAAE1c,aAAauD,WACvD0L,EAAEnP,EAAImP,EAAEjP,aAAauD,UAAamZ,EAAE5c,EAAI4c,EAAE1c,aAAauD,WACvD0L,EAAElP,EAAIkP,EAAEjP,aAAawD,WAAakZ,EAAE3c,EAAI2c,EAAE1c,aAAawD,YACvDyL,EAAElP,EAAIkP,EAAEjP,aAAawD,WAAakZ,EAAE3c,EAAI2c,EAAE1c,aAAawD,UAE3D,C,oICjCA,gBAEA,IAAY0B,EAWA9C,GAXZ,SAAY8C,GACV,QACA,UACA,QACA,UACA,QACA,UACA,QACA,SACD,CATD,CAAYA,EAAA,EAAAA,aAAA,EAAAA,WAAU,MAWV9C,EAAA,EAAAA,mBAAA,EAAAA,iBAAgB,KAC1B,QACA,gBACA,cACA,cAGF,MAAMua,EAAiF,CACrF,CAACzX,EAAWG,GAAK,CAAEuX,IAAK,IAAKC,IAAK,IAClC,CAAC3X,EAAWyV,IAAK,CAAEiC,IAAK,GAAKC,IAAK,IAClC,CAAC3X,EAAWC,GAAK,CAAEyX,IAAK,GAAKC,IAAK,KAClC,CAAC3X,EAAW0V,IAAK,CAAEgC,IAAK,IAAKC,IAAK,KAClC,CAAC3X,EAAWI,GAAK,CAAEsX,IAAK,IAAKC,IAAK,KAClC,CAAC3X,EAAW2V,IAAK,CAAE+B,IAAK,IAAKC,IAAK,KAClC,CAAC3X,EAAWE,GAAK,CAAEwX,IAAK,IAAKC,IAAK,KAClC,CAAC3X,EAAWwV,IAAK,CAAEkC,IAAK,IAAKC,IAAK,MAapC,oCAAyCpX,GAMvC,GALIA,EAAQ,IACVA,EAAQ,EAAI/G,KAAKgU,GAAKhU,KAAKyM,IAAI1F,KAEjCA,EAAQ,EAAAqX,iBAAiBrX,KAGd,GAAKA,EAAQkX,EAAyBzX,EAAWG,GAAGwX,KAC7DpX,GAASkX,EAAyBzX,EAAWG,GAAGuX,KAAOnX,EAAQ,IAE/D,OAAOP,EAAWG,EAGpB,MAAQ7C,GAAcsK,OAAOiQ,QAAQJ,GAA0BK,MAAK,EAAExa,EAAWya,KACvExX,GAASwX,EAAWL,KAAOnX,EAAQwX,EAAWJ,MAExD,OAAO3X,EAAW1C,EACpB,C,kEC1DA,gBAEA,UAEM0a,EAAoB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1D,IAAIC,EAEJ,gBAES/gB,iBACL,IAAK,IAAI2J,EAAI,EAAGA,EAAImX,EAAQ7e,SAAU0H,EACpCmX,EAAQnX,GAAK,CAEjB,CAEO3J,0BAA0BghB,EAAuBvW,GACjDuW,GAGHF,EAAQG,QAAQ,IAAOxW,GACvBqW,EAAQzR,MACR0R,EAAMD,EAAQI,QAAO,CAACC,EAAKC,IAAYD,EAAOC,GAAS,GAAKN,EAAQ7e,QAJpE8e,EAAM,CAMV,CAEO/gB,uBACL,EAAAF,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,gBAEf,EAAA9K,QAAQiL,SAAS,QAAQgW,GAAOA,EAAIrI,QAAQ,IAAM,YAAa,GAAIhS,EAAOsE,cAAgB,IAC5F,EAAAlL,QAAQmL,QACV,E,eC/BF,IAAKoW,E,iDAAL,SAAKA,GACH,2BACA,oBACD,CAHD,CAAKA,IAAAA,EAAU,KAKf,UAAeA,C,kECNf,gBAEA,MAAqBC,EASZthB,2BAA2BuhB,GAChCD,EAAS7W,iBAAoB8W,EAC7BD,EAASxe,kBAAoB4D,EAAO8E,WAAa8V,EAAS7W,gBAC5D,EAZF,YACyB,EAAA+W,WAAa,IAEtB,EAAAC,kBAAoB,EACpB,EAAAhX,iBAAoB,C,4JCNpC,gBAEA,UACA,UACA,UAEA,UAwCA,SAAgBuF,EAASE,EAAgBxD,EAAgBiJ,GACvD,EAAA7V,QAAQyP,YAAcoG,EACtB,EAAA7V,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YAGN,EAAA5K,QAAQ2P,OAAQ,GAAM,UAAOC,OAAOhM,GAAKwM,EAAKxM,EAAIgJ,EAAOhJ,GAAKwM,EAAKtM,aAAauD,UAAY,GAAM,UAAOuI,OAAO/L,GAAKuM,EAAKvM,EAAI+I,EAAO/I,GAAKuM,EAAKtM,aAAawD,YAC5J,EAAAtH,QAAQ6P,QAAQ,GAAM,UAAOD,OAAOhM,GAAKwM,EAAKxM,EAAIgJ,EAAOhJ,GAAKwM,EAAKtM,aAAauD,UAAY,GAAM,UAAOuI,OAAO/L,GAAKuM,EAAKvM,EAAI+I,EAAO/I,GAAKuM,EAAKtM,aAAawD,YAC5J,EAAAtH,QAAQ6P,QAAQ,GAAM,UAAOD,OAAOhM,GAAKwM,EAAKxM,EAAIgJ,EAAOhJ,GAAKwM,EAAKtM,aAAauD,WAAY,GAAM,UAAOuI,OAAO/L,GAAKuM,EAAKvM,EAAI+I,EAAO/I,GAAKuM,EAAKtM,aAAawD,YAC5J,EAAAtH,QAAQ6P,OAAQ,GAAM,UAAOD,OAAOhM,GAAKwM,EAAKxM,EAAIgJ,EAAOhJ,GAAKwM,EAAKtM,aAAauD,WAAY,GAAM,UAAOuI,OAAO/L,GAAKuM,EAAKvM,EAAI+I,EAAO/I,GAAKuM,EAAKtM,aAAawD,YAC5J,EAAAtH,QAAQ6P,OAAQ,GAAM,UAAOD,OAAOhM,GAAKwM,EAAKxM,EAAIgJ,EAAOhJ,GAAKwM,EAAKtM,aAAauD,UAAY,GAAM,UAAOuI,OAAO/L,GAAKuM,EAAKvM,EAAI+I,EAAO/I,GAAKuM,EAAKtM,aAAawD,YAC9J,EAAAtH,QAAQmL,SAER,EAAAnL,QAAQ4K,YACN,EAAA5K,QAAQ2a,IACN,UAAO/K,OAAOhM,GAAKwM,EAAKxM,EAAIgJ,EAAOhJ,GACnC,UAAOgM,OAAO/L,GAAKuM,EAAKvM,EAAI+I,EAAO/I,GACnC,EACA,EACC,EAAIrB,KAAKgU,IAEd,EAAAxW,QAAQmL,QACV,CAzDA,6BAAkCyW,EAAkBC,EAAkBpC,GACpE,MAAMqC,EAAmB,GAIzB,IAAI7N,EAAW2N,EAAW,UAAO1N,SAFf,EAGdC,EAAW0N,EAAW,UAAOzN,SAFf,EAGlB,MAAM2N,EAASH,EAAW,UAAO1N,SAJf,EAKZ8N,EAASH,EAAW,UAAOzN,SAJf,EAMdH,EAAW,IAAKA,EAAW,GAC3BE,EAAW,IAAKA,EAAW,GAE/B,IAAK,IAAIxN,EAAMsN,EAAUtN,EAAMob,IAAUpb,EACvC,IAAK,IAAIG,EAAMqN,EAAW,EAAGrN,EAAMkb,IAAUlb,EACtC,UAAIW,MAAMd,IAAS,UAAIc,MAAMd,GAAKG,IACjCA,EAAM,GAAKH,EAAM,GACnBmb,EAAKvZ,KAAK,IAAI0Z,EAAS,CACrBre,EAAGkD,EAAMF,EAAOC,UAAYD,EAAOC,UAAY,EAC/ChD,EAAG8C,EAAMC,EAAOC,UAAYD,EAAOC,UAAY,GAC9C4Y,IAMX,OAAOqC,CACT,EAEA,+BAAoCA,EAAkBlV,EAAgBiJ,GAChEiM,GACFA,EAAK9R,SAAQI,GAAQF,EAASE,EAAMxD,EAAQiJ,IAEhD,EAEA,aAwBA,4BAAiCqM,EAActV,EAAgB8B,GAC7D,MAAMyT,EAAY,IAAIF,EAASrV,EAAQA,EAAO9I,cACxCse,EAAY,IAAIH,EAASC,EAAQA,EAAMpe,cAE7C4K,EAAiBnG,KAAK4Z,GAEtBC,EAAUC,EAAI,EACdD,EAAUE,EAAIF,EAAUG,UAAUJ,GAElC,MAAMK,EAA6B,CAAEJ,GAErC,IAAIK,EAEJ,KAAOD,EAAergB,OAAS,GAAKsgB,IAAgBN,GAAU,CAG5D,IAFAK,EAAeE,MAAK,CAAC3P,EAAayN,IAAgBzN,EAAEuP,EAAI9B,EAAE8B,IAEnDE,EAAergB,OAAS,IAAmC,IAA9BqgB,EAAe,GAAGrS,SACpDqS,EAAeha,QAGjB,GAAIga,EAAergB,QAAU,EAC3B,MAGFsgB,EAAcD,EAAeha,QAC7Bia,EAAYtS,SAAU,EAGtBsS,EAAYE,eAAiB,IAAKjU,GAC/B0E,QAAOhD,OAEHA,EAAKtJ,MAAQ2b,EAAY3b,KAAWsJ,EAAKzJ,MAAQ8b,EAAY9b,KAC7DyJ,EAAKtJ,MAAQ2b,EAAY3b,KAAWsJ,EAAKzJ,MAAQ8b,EAAY9b,IAAM,GACnEyJ,EAAKtJ,MAAQ2b,EAAY3b,IAAM,GAAKsJ,EAAKzJ,MAAQ8b,EAAY9b,KAC7DyJ,EAAKtJ,MAAQ2b,EAAY3b,KAAWsJ,EAAKzJ,MAAQ8b,EAAY9b,IAAM,GACnEyJ,EAAKtJ,MAAQ2b,EAAY3b,IAAM,GAAKsJ,EAAKzJ,MAAQ8b,EAAY9b,OAE5DyJ,EAAKtJ,MAAQ2b,EAAY3b,IAAM,GAAKsJ,EAAKzJ,MAAQ8b,EAAY9b,IAAM,GAEhE,UAAIc,MAAM2I,EAAKzJ,MAAsD,OAA1C,UAAIc,MAAM2I,EAAKzJ,KAASyJ,EAAKtJ,IAAM,IAC9D,UAAIW,MAAM2I,EAAKzJ,IAAM,IAAgD,OAA1C,UAAIc,MAAM2I,EAAKzJ,IAAM,GAAGyJ,EAAKtJ,QAI3DsJ,EAAKtJ,MAAQ2b,EAAY3b,IAAM,GAAKsJ,EAAKzJ,MAAQ8b,EAAY9b,IAAM,GAEhE,UAAIc,MAAM2I,EAAKzJ,MAAsD,OAA1C,UAAIc,MAAM2I,EAAKzJ,KAASyJ,EAAKtJ,IAAM,IAC9D,UAAIW,MAAM2I,EAAKzJ,IAAM,IAAgD,OAA1C,UAAIc,MAAM2I,EAAKzJ,IAAM,GAAGyJ,EAAKtJ,QAI3DsJ,EAAKtJ,MAAQ2b,EAAY3b,IAAM,GAAKsJ,EAAKzJ,MAAQ8b,EAAY9b,IAAM,GAEhE,UAAIc,MAAM2I,EAAKzJ,MAAsD,OAA1C,UAAIc,MAAM2I,EAAKzJ,KAASyJ,EAAKtJ,IAAM,IAC9D,UAAIW,MAAM2I,EAAKzJ,IAAM,IAAgD,OAA1C,UAAIc,MAAM2I,EAAKzJ,IAAM,GAAGyJ,EAAKtJ,QAI3DsJ,EAAKtJ,MAAQ2b,EAAY3b,IAAM,GAAKsJ,EAAKzJ,MAAQ8b,EAAY9b,IAAM,GAEhE,UAAIc,MAAM2I,EAAKzJ,MAAsD,OAA1C,UAAIc,MAAM2I,EAAKzJ,KAASyJ,EAAKtJ,IAAM,IAC9D,UAAIW,MAAM2I,EAAKzJ,IAAM,IAAgD,OAA1C,UAAIc,MAAM2I,EAAKzJ,IAAM,GAAGyJ,EAAKtJ,SAMnE2b,EAAYE,eACTpO,KAAInE,KACkB,IAAjBA,EAAKD,SACPqS,EAAeja,KAAK6H,GAItB,MAAMwS,EAAyBH,EAAYJ,EAAI,EAAAhV,qBAAqBoV,EAAarS,GAQjF,OANIwS,EAAyBxS,EAAKiS,IAChCjS,EAAKyS,OAASJ,EACdrS,EAAKiS,EAAIO,EACTxS,EAAKkS,EAAIlS,EAAKiS,EAAIjS,EAAKmS,UAAUJ,IAG5B/R,CAAI,G,CAIjB,MAAM0R,EAAO,GACb,GAAIK,EAASU,OAAQ,CACnB,IAAI5S,EAAckS,EAClB,KAAOlS,EAAE4S,QACPf,EAAKvZ,KAAK0H,GACVA,EAAIA,EAAE4S,M,CAGV,OAAOf,CACT,EAEA,MAAaG,EAmBXte,YAAYmf,EAAoBrD,GAdzB,KAAA1a,OAAS,CACdC,MAAW,EACXC,SAAW,EACXC,OAAW,EACXC,QAAW,GAIN,KAAAgL,SAAmB,EACnB,KAAAmS,EAAYS,IACZ,KAAAV,EAAYU,IACZ,KAAAF,OAAmB,KAIxBtiB,KAAKqD,EAAIkf,EAAYlf,EACrBrD,KAAKsD,EAAIif,EAAYjf,EACrBtD,KAAKuD,aAAe,IAAI,UAAa2b,EAAK9X,MAAO8X,EAAKxX,QACtD1H,KAAKwG,mBACLxG,KAAKmF,mBACP,CAEO6c,UAAUJ,GACf,OAAO,EAAA9U,qBAAqB9M,KAAM4hB,EACpC,CAGQpb,mBACNxG,KAAKwE,OAAOC,MAAQzE,KAAKsD,EAAI+C,EAAOC,UACpCtG,KAAKwE,OAAOE,SAAW2B,EAAOC,UAAYtG,KAAKwE,OAAOC,MACtDzE,KAAKwE,OAAOG,OAAS3E,KAAKqD,EAAIgD,EAAOC,UACrCtG,KAAKwE,OAAOI,QAAUyB,EAAOC,UAAYtG,KAAKwE,OAAOG,MACvD,CAGQQ,oBACNnF,KAAKoG,IAAMnE,KAAKC,MAAMlC,KAAKsD,EAAI+C,EAAOC,WACtCtG,KAAKuG,IAAMtE,KAAKC,MAAMlC,KAAKqD,EAAIgD,EAAOC,UACxC,EA3CF,Y,kECvKA,gBAEA,UAEA,UAEA,UAKA,UAEA,MAAqBmc,EAWZ9iB,YACL6P,EACAxG,EACA0Z,GAEA,KAAI1Z,GAAS,GASN,CACL,MAAM2Z,EAAOnT,EAAEhL,OAAOC,MAAQxC,KAAK2gB,KAAK5Z,GAGlC6Z,EAAkB,EAAIF,EAAQ,EAEpC,OAAIA,GAAQ,GAAKE,EACRJ,EAAUK,oBAAoBtT,EAAGxG,EAAO0Z,GAGxCD,EAAUM,oBAAoBvT,EAAGxG,EAAO0Z,E,CAnBnC,CACd,MAAMC,EAAOnT,EAAEhL,OAAOE,SAAWzC,KAAK2gB,IAAI5Z,GAE1C,GAAI2Z,GAAQ,EACV,OAAOF,EAAUO,oBAAoBxT,EAAGxG,EAAO0Z,GAE5C,GAAIC,EAAO,EACd,OAAOF,EAAUQ,oBAAoBzT,EAAGxG,EAAO0Z,E,CAerD,CAEO/iB,eAAe+Y,EAAiBpD,EAAgB,WACrD,EAAA7V,QAAQyP,YAAcoG,EACtB,EAAA7V,QAAQ0P,UAAY,GACpB,EAAA1P,QAAQ4K,YACN,EAAA5K,QAAQ2P,OAAO,UAAOtI,UAAW,UAAOC,YACxC,EAAAtH,QAAQ6P,OACN,UAAOxI,UAAY4R,EAASrV,EAC5B,UAAO0D,WAAa2R,EAASpV,GAEjC,EAAA7D,QAAQmL,SACR,EAAAnL,QAAQ0P,UAAY,CACtB,CAEOxP,oDAAoDoQ,EAAsBC,GAC/E,MAAMkT,EAA6B,EAAAja,mBAAmB+G,EAAID,GACpDoT,EAAUV,EAAU7J,KAAK7I,EAAImT,EAA4BlT,GAI/D,OAAImT,GACyB,OAApBA,EAAQxK,OAKnB,CAGOhZ,uDAAuDyjB,EAAsBC,GAClF,MAAMC,GAA6B,EAAAra,mBAAmBoa,EAAID,GAAI/K,QAAQ,GAEtE,GAA0B,IAAtBiL,EAAyB,CAC3B,MAAOC,EAAMC,GAAQC,EAAcL,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6CgS,EAA0BC,GACnF,OAAO,EAET,MAAOE,EAAMC,GAAQC,EAAcR,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CmS,EAA0BC,E,CAMlF,GAAIL,EAAoB,GAAKA,EAAoB,EAAAO,YAAc,EAAG,CACrE,MAAON,EAAMC,GAAQC,EAAcL,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6CgS,EAA0BC,GACnF,OAAO,EAET,MAAOM,EAAMC,GAAQC,EAAcZ,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CuS,EAA0BC,E,CAMlF,GAAIT,IAAuB,EAAAO,YAAc,EAAI,CAChD,MAAOH,EAAMC,GAAQC,EAAcR,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6CmS,EAA0BC,GACnF,OAAO,EAET,MAAOG,EAAMC,GAAQC,EAAcZ,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CuS,EAA0BC,E,CAMlF,GAAIT,EAAoB,EAAAO,YAAc,GAAKP,EAAoB,EAAAO,YAAa,CAC/E,MAAOI,EAAMC,GAAQC,EAAcf,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6C0S,EAA0BC,GACnF,OAAO,EAET,MAAOR,EAAMC,GAAQC,EAAcR,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CmS,EAA0BC,E,CAMlF,GAAI1hB,KAAKyM,IAAI4U,KAAuB,EAAAO,YAAa,CACpD,MAAOI,EAAMC,GAAQC,EAAcf,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6C0S,EAA0BC,GACnF,OAAO,EAET,MAAOJ,EAAMC,GAAQC,EAAcZ,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CuS,EAA0BC,E,CAMlF,GAAIT,GAAqB,EAAAO,aAAeP,GAAqB,EAAAO,YAAc,EAAG,CACjF,MAAON,EAAMC,GAAQC,EAAcL,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6CgS,EAA0BC,GACnF,OAAO,EAET,MAAOM,EAAMC,GAAQC,EAAcZ,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CuS,EAA0BC,E,CAMlF,GAAIT,KAAuB,EAAAO,YAAc,EAAG,CAC/C,MAAON,EAAMC,GAAQC,EAAcL,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6CgS,EAA0BC,GACnF,OAAO,EAET,MAAOS,EAAMC,GAAQC,EAAcf,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6C0S,EAA0BC,E,CAMlF,GAAIZ,GAAqB,EAAAO,YAAc,GAAKP,EAAoB,EAAG,CACtE,MAAOW,EAAMC,GAAQC,EAAcf,EAAIC,GACvC,GAAIZ,EAAUlR,6CAA6C0S,EAA0BC,GACnF,OAAO,EAET,MAAOR,EAAMC,GAAQC,EAAcR,EAAIC,GACvC,QAAIZ,EAAUlR,6CAA6CmS,EAA0BC,E,CAKzF,CAOQhkB,2BAA2B6P,EAAqBxG,EAAe0Z,GAIrE,IAII0B,EACAC,EALAC,EAA0B,KAC1BC,EAAwB,KAExBjb,EAAI,EAIR,KACE+a,EAAY/a,EAAIjD,EAAOC,UAErB8d,EADY,IAAVpb,EACW,GAECwG,EAAEhL,OAAOI,QAAUyf,GAAapiB,KAAK2gB,IAAI5Z,KAIpDqb,EAAY7U,EAAEhL,OAAOI,QAAU6d,EAAU+B,iBAAqBJ,EAAa3B,EAAUgC,eAKtF/B,IACE2B,EAAY7U,EAAEhL,OAAOI,QAAW8d,EAAKrf,EAAImM,EAAEnM,GAAM+gB,EAAc1B,EAAKpf,EAAIkM,EAAElM,KAfrE,CAoBX,GAAI+C,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKmM,EAAEhL,OAAOI,QAAUyf,EACzD/gB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAK8gB,GAG1B,CACZ/gB,EAAG,UAAOgM,OAAOhM,EAAImM,EAAEhL,OAAOI,QAAUyf,EACxC/gB,EAAG,UAAO+L,OAAO/L,EAAI8gB,GAGzB,EAAA3kB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAKV,GAFA2Z,EAAkB9B,EAAUkC,6BAA6Brb,EAAGkG,EAAG4U,GAE3DG,EAAiB,CACnBD,EAAmB,CAAEjhB,EAAGghB,EAAY7U,EAAEhL,OAAOI,QAAStB,EAAG8gB,GACzD,K,GAEA9a,C,CAMJ,IAIIsb,EACAC,EALAC,EAA4B,KAC5BC,EAA0B,KAE1BC,EAAI,EAIR,KACEH,EAAYG,EAAI3e,EAAOC,YACT,IAAV0C,IAGF4b,GAAcpV,EAAEhL,OAAOE,SAAWmgB,GAAa5iB,KAAK2gB,IAAI5Z,GAIrD6b,EAAYrV,EAAEhL,OAAOE,SAAW+d,EAAUgC,eAAmBG,EAAanC,EAAU+B,kBAKrF9B,IACEmC,EAAYrV,EAAEhL,OAAOE,SAAYge,EAAKpf,EAAIkM,EAAElM,GAAMrB,KAAKwI,MAAMma,GAAelC,EAAKrf,EAAImM,EAAEnM,KAflF,CAoBX,GAAIgD,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKuhB,EACtCthB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAKkM,EAAEhL,OAAOE,SAAWmgB,GAG9C,CACZxhB,EAAG,UAAOgM,OAAOhM,EAAIuhB,EACrBthB,EAAG,UAAO+L,OAAO/L,EAAIkM,EAAEhL,OAAOE,SAAWmgB,GAG7C,EAAAplB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAIV,GAAIwZ,EAAaS,EACf,MAKF,GAFAE,EAAoBtC,EAAUwC,+BAA+BD,EAAGxV,EAAGoV,GAE/DG,EAAmB,CACrBD,EAAqB,CAAEzhB,EAAGuhB,EAAYthB,EAAGuhB,EAAYrV,EAAEhL,OAAOE,UAC9D,K,GAEAsgB,C,CAOJ,GAAIV,GAA2C,OAAvBQ,EACtB,MAAO,CACLpM,SAAY4L,EACZ3L,QAAU4L,GAGT,GAAIO,GAA2C,OAArBR,EAC7B,MAAO,CACL5L,SAAYoM,EACZnM,QAAUoM,GAGT,GAAID,GAAsBR,EAG7B,OAFwCriB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,GAIX,GAA2B,OAAvBO,GAAoD,OAArBR,EAA2B,CAEjE,MAAMQ,EAAqB,CAAEzhB,EAAGuhB,EAAYthB,EAAGuhB,EAAYrV,EAAEhL,OAAOE,UAC9D4f,EAAqB,CAAEjhB,EAAGghB,EAAY7U,EAAEhL,OAAOI,QAAStB,EAAG8gB,GAGjE,OAFwCniB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,E,CAIlB,CAGQ5kB,2BAA2B6P,EAAqBxG,EAAe0Z,GAIrE,IAII0B,EACAC,EALAC,EAA0B,KAC1BC,EAAwB,KAExBjb,EAAI,EAIR,KACE+a,EAAY/a,EAAIjD,EAAOC,UAErB8d,EADY,IAAVpb,EACW,GAECwG,EAAEhL,OAAOI,QAAUyf,GAAapiB,KAAK2gB,KAAK5Z,KAIrDqb,EAAY7U,EAAEhL,OAAOI,QAAU6d,EAAU+B,iBAAqBJ,EAAa3B,EAAUgC,eAKtF/B,IACE2B,EAAY7U,EAAEhL,OAAOI,QAAW8d,EAAKrf,EAAImM,EAAEnM,GAAM+gB,EAAc5U,EAAElM,EAAIof,EAAKpf,KAfrE,CAoBX,GAAI+C,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKmM,EAAEhL,OAAOI,QAAUyf,EACzD/gB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAK8gB,GAG1B,CACZ/gB,EAAG,UAAOgM,OAAOhM,EAAImM,EAAEhL,OAAOI,QAAUyf,EACxC/gB,EAAG,UAAO+L,OAAO/L,EAAI8gB,GAGzB,EAAA3kB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAKV,GAFA2Z,EAAkB9B,EAAU0C,6BAA6B7b,EAAGkG,EAAG4U,GAE3DG,EAAiB,CACnBD,EAAmB,CAAEjhB,EAAGghB,EAAY7U,EAAEhL,OAAOI,QAAStB,GAAI8gB,GAC1D,K,GAEA9a,C,CAMJ,IAIIsb,EACAC,EALAC,EAA4B,KAC5BC,EAA0B,KAE1BC,EAAI,EAIR,KACEH,EAAYG,EAAI3e,EAAOC,YACT,IAAV0C,IAGF4b,GAAcpV,EAAEhL,OAAOC,MAAQogB,GAAa5iB,KAAK2gB,KAAK5Z,GAInD6b,EAAYrV,EAAEhL,OAAOC,MAAQge,EAAUgC,eAAmBG,EAAanC,EAAU+B,kBAKlF9B,IACEmC,EAAYrV,EAAEhL,OAAOC,MAAS+K,EAAElM,EAAIof,EAAKpf,GAAMrB,KAAKwI,MAAMma,GAAelC,EAAKrf,EAAImM,EAAEnM,KAf/E,CAoBX,GAAIgD,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKuhB,EACtCthB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAKkM,EAAEhL,OAAOC,MAAQogB,GAG3C,CACZxhB,EAAG,UAAOgM,OAAOhM,EAAIuhB,EACrBthB,EAAG,UAAO+L,OAAO/L,EAAIuhB,EAAYrV,EAAEhL,OAAOC,OAG9C,EAAAhF,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAIV,GAAIwZ,EAAaS,EACf,MAKF,GAFAE,EAAoBtC,EAAU2C,+BAA+BJ,EAAGxV,EAAGoV,GAE/DG,EAAmB,CACrBD,EAAqB,CAAEzhB,EAAGuhB,EAAYthB,GAAIuhB,EAAYrV,EAAEhL,OAAOC,OAC/D,K,GAEAugB,C,CAOJ,GAAIV,GAA2C,OAAvBQ,EACtB,MAAO,CACLpM,SAAY4L,EACZ3L,QAAU4L,GAGT,GAAIO,GAA2C,OAArBR,EAC7B,MAAO,CACL5L,SAAYoM,EACZnM,QAAUoM,GAGT,GAAID,GAAsBR,EAG7B,OAFwCriB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,GAIX,GAA2B,OAAvBO,GAAoD,OAArBR,EAA2B,CAEjE,MAAMQ,EAAqB,CAAEzhB,EAAGuhB,EAAYthB,GAAIuhB,EAAYrV,EAAEhL,OAAOC,OAC/D6f,EAAqB,CAAEjhB,EAAGghB,EAAY7U,EAAEhL,OAAOI,QAAStB,GAAI8gB,GAGlE,OAFwCniB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,E,CAIlB,CAGQ5kB,2BAA2B6P,EAAUxG,EAAe0Z,GAI1D,IAII0B,EACAC,EALAC,EAA0B,KAC1BC,EAAwB,KAExBjb,EAAI,EAIR,KACE+a,EAAY/a,EAAIjD,EAAOC,UAErB8d,EADY,IAAVpb,EACW,GAECwG,EAAEhL,OAAOG,OAAS0f,GAAapiB,KAAK2gB,IAAI3gB,KAAKgU,KAAOjN,KAI/Dqb,EAAY7U,EAAEhL,OAAOG,OAAS8d,EAAU+B,iBAAqBJ,EAAa3B,EAAUgC,eAKrF/B,IACE2B,EAAY7U,EAAEhL,OAAOG,OAAU6K,EAAEnM,EAAIqf,EAAKrf,GAAM+gB,EAAc5U,EAAElM,EAAIof,EAAKpf,KAfpE,CAoBX,GAAI+C,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKmM,EAAEhL,OAAOG,OAAS0f,EACxD/gB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAK8gB,GAG1B,CACZ/gB,EAAG,UAAOgM,OAAOhM,EAAImM,EAAEhL,OAAOG,OAAS0f,EACvC/gB,EAAG,UAAO+L,OAAO/L,EAAI8gB,GAGzB,EAAA3kB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAKV,GAFA2Z,EAAkB9B,EAAU4C,6BAA6B/b,EAAGkG,EAAG4U,GAE3DG,EAAiB,CACnBD,EAAmB,CAAEjhB,GAAKghB,EAAY7U,EAAEhL,OAAOG,OAAQrB,GAAI8gB,GAC3D,K,GAEA9a,C,CAMJ,IAIIsb,EACAC,EALAC,EAA4B,KAC5BC,EAA0B,KAE1BC,EAAI,EAIR,KACEH,EAAYG,EAAI3e,EAAOC,YACT,IAAV0C,IAGF4b,GAAcpV,EAAEhL,OAAOC,MAAQogB,GAAa5iB,KAAK2gB,IAAI3gB,KAAKgU,KAAOjN,GAI9D6b,EAAYrV,EAAEhL,OAAOC,MAAQge,EAAUgC,eAAmBG,EAAanC,EAAU+B,kBAKlF9B,IACEmC,EAAYrV,EAAEhL,OAAOC,MAAS+K,EAAElM,EAAIof,EAAKpf,GAAMrB,KAAKwI,MAAMma,GAAepV,EAAEnM,EAAIqf,EAAKrf,KAf/E,CAoBX,GAAIgD,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKuhB,EACtCthB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAKkM,EAAEhL,OAAOC,MAAQogB,GAG3C,CACZxhB,EAAG,UAAOgM,OAAOhM,EAAIuhB,EACrBthB,EAAG,UAAO+L,OAAO/L,EAAIkM,EAAEhL,OAAOC,MAAQogB,GAG1C,EAAAplB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAIV,GAAIwZ,EAAaS,EACf,MAKF,GAFAE,EAAoBtC,EAAU6C,+BAA+BN,EAAGxV,EAAGoV,GAE/DG,EAAmB,CACrBD,EAAqB,CAAEzhB,GAAIuhB,EAAYthB,GAAIuhB,EAAYrV,EAAEhL,OAAOC,OAChE,K,GAEAugB,C,CAOJ,GAAIV,GAA2C,OAAvBQ,EACtB,MAAO,CACLpM,SAAY4L,EACZ3L,QAAU4L,GAGT,GAAIO,GAA2C,OAArBR,EAC7B,MAAO,CACL5L,SAAYoM,EACZnM,QAAUoM,GAGT,GAAID,GAAsBR,EAG7B,OAFwCriB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,GAIX,GAA2B,OAAvBO,GAAoD,OAArBR,EAA2B,CAEjE,MAAMQ,EAAqB,CAAEzhB,GAAIuhB,EAAYthB,GAAIuhB,EAAYrV,EAAEhL,OAAOC,OAChE6f,EAAqB,CAAEjhB,GAAKghB,EAAY7U,EAAEhL,OAAOG,OAAQrB,GAAI8gB,GAGnE,OAFwCniB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,E,CAIlB,CAGQ5kB,2BAA2B6P,EAAUxG,EAAe0Z,GAI1D,IAII0B,EACAC,EALAC,EAA0B,KAC1BC,EAAwB,KAExBjb,EAAI,EAIR,KACE+a,EAAY/a,EAAIjD,EAAOC,UAErB8d,EADY,IAAVpb,EACW,GAECwG,EAAEhL,OAAOG,OAAS0f,GAAapiB,KAAK2gB,IAAI3gB,KAAKgU,GAAKjN,KAI7Dqb,EAAY7U,EAAEhL,OAAOG,OAAS8d,EAAU+B,iBAAqBJ,EAAa3B,EAAUgC,eAKrF/B,IACE2B,EAAY7U,EAAEhL,OAAOG,OAAU6K,EAAEnM,EAAIqf,EAAKrf,GAAM+gB,EAAc1B,EAAKpf,EAAIkM,EAAElM,KAfpE,CAoBX,GAAI+C,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKmM,EAAEhL,OAAOG,OAAS0f,EACxD/gB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAK8gB,GAG1B,CACZ/gB,EAAG,UAAOgM,OAAOhM,EAAImM,EAAEhL,OAAOG,OAAS0f,EACvC/gB,EAAG,UAAO+L,OAAO/L,EAAI8gB,GAGzB,EAAA3kB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAKV,GAFA2Z,EAAkB9B,EAAU8C,6BAA6Bjc,EAAGkG,EAAG4U,GAE3DG,EAAiB,CACnBD,EAAmB,CAAEjhB,GAAIghB,EAAY7U,EAAEhL,OAAOG,OAAQrB,EAAG8gB,GACzD,K,GAEA9a,C,CAMJ,IAIIsb,EACAC,EALAC,EAA4B,KAC5BC,EAA0B,KAE1BC,EAAI,EAIR,KACEH,EAAYG,EAAI3e,EAAOC,YACT,IAAV0C,IAGF4b,GAAcpV,EAAEhL,OAAOE,SAAWmgB,GAAa5iB,KAAK2gB,IAAI5Z,GAIrD6b,EAAYrV,EAAEhL,OAAOE,SAAW+d,EAAUgC,gBAAoBG,EAAanC,EAAU+B,kBAKtF9B,IACGmC,EAAYrV,EAAEhL,OAAOE,SAAYge,EAAKpf,EAAIkM,EAAElM,IAASshB,EAAcpV,EAAEnM,EAAIqf,EAAKrf,KAf1E,CAoBX,GAAIgD,EAAOuH,MAAM8W,UAAW,CAC1B,IAAInC,EAEFA,EADEG,EACY,CACZrf,EAAG,UAAOgM,OAAOhM,GAAKqf,EAAKrf,EAAImM,EAAEnM,GAAKuhB,EACtCthB,EAAG,UAAO+L,OAAO/L,GAAKof,EAAKpf,EAAIkM,EAAElM,GAAKkM,EAAEhL,OAAOE,SAAWmgB,GAG9C,CACZxhB,EAAG,UAAOgM,OAAOhM,EAAIuhB,EACrBthB,EAAG,UAAO+L,OAAO/L,EAAIkM,EAAEhL,OAAOE,SAAWmgB,GAG7C,EAAAplB,QAAQyP,YAAc,UACtB,EAAAzP,QAAQ4K,YACR,EAAA5K,QAAQ2a,IAAImI,EAAYlf,EAAGkf,EAAYjf,EAAG,EAAG,EAAI,EAAIrB,KAAKgU,IAC1D,EAAAxW,QAAQmL,Q,CAIV,GAAIwZ,EAAaS,EACf,MAKF,GAFAE,EAAoBtC,EAAU+C,+BAA+BR,EAAGxV,EAAGoV,GAE/DG,EAAmB,CACrBD,EAAqB,CAAEzhB,EAAGuhB,EAAYthB,EAAGuhB,EAAYrV,EAAEhL,OAAOE,UAC9D,K,GAEAsgB,C,CAOJ,GAAIV,GAA2C,OAAvBQ,EACtB,MAAO,CACLpM,SAAW4L,EACX3L,QAAW4L,GAGV,GAAIO,GAA2C,OAArBR,EAC7B,MAAO,CACL5L,SAAWoM,EACXnM,QAAWoM,GAGV,GAAID,GAAsBR,EAG7B,OAFwCriB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAWoM,EACXnM,QAAWoM,GAGN,CACLrM,SAAW4L,EACX3L,QAAW4L,GAIZ,GAA2B,OAAvBO,GAAoD,OAArBR,EAA2B,CAEjE,MAAMQ,EAAqB,CAAEzhB,EAAGuhB,EAAYthB,EAAGuhB,EAAYrV,EAAEhL,OAAOE,UAC9D4f,EAAqB,CAAEjhB,GAAIghB,EAAY7U,EAAEhL,OAAOG,OAAQrB,EAAG8gB,GAGjE,OAFwCniB,KAAKiP,KAAKjP,KAAKijB,IAAMZ,EAAiBjhB,EAAG,GAAKpB,KAAKijB,IAAMZ,EAAiBhhB,EAAG,IAC7ErB,KAAKiP,KAAKjP,KAAKijB,IAAIJ,EAAmBzhB,EAAG,GAAKpB,KAAKijB,IAAIJ,EAAmBxhB,EAAG,IAE5G,CACLoV,SAAYoM,EACZnM,QAAUoM,GAGL,CACLrM,SAAY4L,EACZ3L,QAAU4L,E,CAIlB,CAEQ5kB,oCAAoC2J,EAAWkG,EAAU4U,GAC/D,MAAMqB,EAAQ,EAAIjW,EAAEjJ,IAAM+C,EACpBoc,EAAQlW,EAAEpJ,IAAMnE,KAAKC,OAAOsN,EAAEhL,OAAOC,MAAQ2f,GAAc/d,EAAOC,WAClEqf,EAAwBnW,EAAEpJ,IAAMnE,KAAKC,OAAOsN,EAAEhL,OAAOC,MAAQ2f,EAAa,GAAK/d,EAAOC,WAE5F,IAAIqS,EAAU,KAcd,OAbI,UAAIzR,MAAMwe,KACR,UAAIxe,MAAMwe,GAAOD,GACnB9M,EAAU,UAAIzR,MAAMwe,GAAOD,GAEpB,UAAIve,MAAMye,GAAuBF,KACxC9M,EAAU,UAAIzR,MAAMye,GAAuBF,KAI3Cpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CACQhZ,sCAAsC2J,EAAWkG,EAAUoV,GACjE,MAAMa,EAAQjW,EAAEjJ,IAAMtE,KAAKC,OAAOsN,EAAEhL,OAAOG,OAASigB,GAAcve,EAAOC,WACnEof,EAAQlW,EAAEpJ,IAAMkD,EAAI,EAE1B,IAAIqP,EAAU,KASd,OARI,UAAIzR,MAAMwe,IAAU,UAAIxe,MAAMwe,GAAOD,KACvC9M,EAAU,UAAIzR,MAAMwe,GAAOD,IAGzBpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CAEQhZ,oCAAoC2J,EAAWkG,EAAU4U,GAC/D,MAAMqB,EAAQ,EAAIjW,EAAEjJ,IAAM+C,EACpBoc,EAAQlW,EAAEpJ,IAAMnE,KAAKC,OAAOsN,EAAEhL,OAAOC,MAAQ2f,GAAc/d,EAAOC,WAExE,IAAIqS,EAAU,KASd,OARI,UAAIzR,MAAMwe,IAAU,UAAIxe,MAAMwe,GAAOD,KACvC9M,EAAU,UAAIzR,MAAMwe,GAAOD,IAGzBpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CACQhZ,sCAAsC2J,EAAWkG,EAAUoV,GACjE,MAAMa,EAAQjW,EAAEjJ,IAAMtE,KAAKC,OAAOsN,EAAEhL,OAAOG,OAASigB,GAAcve,EAAOC,WACnEsf,EAAuBpW,EAAEjJ,IAAMtE,KAAKC,OAAOsN,EAAEhL,OAAOG,OAASigB,EAAa,GAAKve,EAAOC,WACtFof,EAAQlW,EAAEpJ,IAAMkD,EAAI,EAE1B,IAAIqP,EAAU,KAcd,OAbI,UAAIzR,MAAMwe,KACR,UAAIxe,MAAMwe,GAAOD,GACnB9M,EAAU,UAAIzR,MAAMwe,GAAOD,GAEpB,UAAIve,MAAMwe,GAAOE,KACxBjN,EAAU,UAAIzR,MAAMwe,GAAOE,KAI3Bvf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CAEQhZ,oCAAoC2J,EAAWkG,EAAU4U,GAC/D,MAAMqB,GAAU,EAAIjW,EAAEjJ,IAAM+C,EACtBoc,EAAQlW,EAAEpJ,IAAMnE,KAAKC,OAAOsN,EAAEhL,OAAOC,MAAQ2f,GAAc/d,EAAOC,WAExE,IAAIqS,EAAU,KASd,OARI,UAAIzR,MAAMwe,IAAU,UAAIxe,MAAMwe,GAAOD,KACvC9M,EAAU,UAAIzR,MAAMwe,GAAOD,IAGzBpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CACQhZ,sCAAsC2J,EAAWkG,EAAUoV,GACjE,MAAMa,EAAQjW,EAAEjJ,IAAMtE,KAAKC,OAAOsN,EAAEhL,OAAOI,QAAUggB,GAAcve,EAAOC,WACpEof,EAAQlW,EAAEpJ,IAAMkD,EAAI,EAE1B,IAAIqP,EAAU,KASd,OARI,UAAIzR,MAAMwe,IAAU,UAAIxe,MAAMwe,GAAOD,KACvC9M,EAAU,UAAIzR,MAAMwe,GAAOD,IAGzBpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CAEQhZ,oCAAoC2J,EAAWkG,EAAU4U,GAC/D,MAAMqB,EAAQjW,EAAEjJ,IAAM+C,EAAI,EACpBoc,EAAQlW,EAAEpJ,IAAMnE,KAAKC,OAAOsN,EAAEhL,OAAOC,MAAQ2f,GAAc/d,EAAOC,WAClEqf,EAAwBnW,EAAEpJ,IAAMnE,KAAKC,OAAOsN,EAAEhL,OAAOC,MAAQ2f,EAAa,GAAK/d,EAAOC,WAE5F,IAAIqS,EAAU,KAcd,OAbI,UAAIzR,MAAMwe,KACR,UAAIxe,MAAMwe,GAAOD,GACnB9M,EAAU,UAAIzR,MAAMwe,GAAOD,GAEpB,UAAIve,MAAMye,GAAuBF,KACxC9M,EAAU,UAAIzR,MAAMye,GAAuBF,KAI3Cpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,CACQhZ,sCAAsC2J,EAAWkG,EAAUoV,GACjE,MAAMa,EAAQjW,EAAEjJ,IAAMtE,KAAKC,OAAOsN,EAAEhL,OAAOI,QAAUggB,GAAcve,EAAOC,WACpEof,EAAQlW,EAAEpJ,IAAMkD,EAAI,EAE1B,IAAIqP,EAAU,KASd,OARI,UAAIzR,MAAMwe,IAAU,UAAIxe,MAAMwe,GAAOD,KACvC9M,EAAU,UAAIzR,MAAMwe,GAAOD,IAGzBpf,EAAOuH,MAAM8W,WACf,EAAAjlB,QAAQiL,SAAS,QAAQ+a,WAAeC,WAAe/M,EAAU,CAACA,EAAQvS,IAAKuS,EAAQpS,KAAO,OAAQ,GAAI,IAAU,GAAJ+C,GAG3GqP,CACT,EAh/BF,YAwKiB,EAAAkN,sBAA2C,EAAnBxf,EAAOC,UAC/B,EAAAke,gBAA0B,UAAO1d,UAAa2b,EAAUoD,sBACxD,EAAApB,cAA0B,UAAO1d,WAA+C,EAAlC0b,EAAUoD,sBAy0BzE,MAAMC,EAAqB,CACzBziB,EAAG,EACHC,EAAG,EACHkB,OAAQ,CACNC,MAAW,EACXC,SAAW,EACXC,OAAW,EACXC,QAAW,IAGTmhB,EAAmB,IAAKD,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9DwhB,EAAmB,IAAKF,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9DyhB,EAAmB,IAAKH,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9D0hB,EAAmB,IAAKJ,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9D2hB,EAAmB,IAAKL,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9D4hB,EAAmB,IAAKN,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9D6hB,EAAmB,IAAKP,EAAathB,OAAQ,IAAKshB,EAAYthB,SAC9D8hB,EAAmB,IAAKR,EAAathB,OAAQ,IAAKshB,EAAYthB,SAEpE,SAAS2f,EAAcf,EAAsBC,GAmB3C,OAlBA0C,EAAU1iB,EAAI+f,EAAG/f,EAAI+f,EAAG7f,aAAauD,UACrCif,EAAUziB,EAAI8f,EAAG9f,EAAI8f,EAAG7f,aAAawD,WACrCgf,EAAU3f,IAAMnE,KAAKC,MAAM6jB,EAAUziB,EAAI+C,EAAOC,WAChDyf,EAAUxf,IAAMtE,KAAKC,MAAM6jB,EAAU1iB,EAAIgD,EAAOC,WAChDyf,EAAUvhB,OAAOC,MAAQshB,EAAUziB,EAAI+C,EAAOC,UAC9Cyf,EAAUvhB,OAAOE,SAAW2B,EAAOC,UAAYyf,EAAUvhB,OAAOC,MAChEshB,EAAUvhB,OAAOG,OAASohB,EAAU1iB,EAAIgD,EAAOC,UAC/Cyf,EAAUvhB,OAAOI,QAAUyB,EAAOC,UAAYyf,EAAUvhB,OAAOG,OAE/DqhB,EAAU3iB,EAAIggB,EAAGhgB,EAAIggB,EAAG9f,aAAauD,UACrCkf,EAAU1iB,EAAI+f,EAAG/f,EAAI+f,EAAG9f,aAAawD,WACrCif,EAAU5f,IAAMnE,KAAKC,MAAM8jB,EAAU1iB,EAAI+C,EAAOC,WAChD0f,EAAUzf,IAAMtE,KAAKC,MAAM8jB,EAAU3iB,EAAIgD,EAAOC,WAChD0f,EAAUxhB,OAAOC,MAAQuhB,EAAU1iB,EAAI+C,EAAOC,UAC9C0f,EAAUxhB,OAAOE,SAAW2B,EAAOC,UAAY0f,EAAUxhB,OAAOC,MAChEuhB,EAAUxhB,OAAOG,OAASqhB,EAAU3iB,EAAIgD,EAAOC,UAC/C0f,EAAUxhB,OAAOI,QAAUyB,EAAOC,UAAY0f,EAAUxhB,OAAOG,OAExD,CAAEohB,EAAWC,EACtB,CAEA,SAASvC,EAAcL,EAAsBC,GAmB3C,OAlBA4C,EAAU5iB,EAAI+f,EAAG/f,EAAI+f,EAAG7f,aAAauD,UACrCmf,EAAU3iB,EAAI8f,EAAG9f,EAAI8f,EAAG7f,aAAawD,WACrCkf,EAAU7f,IAAMnE,KAAKC,MAAM+jB,EAAU3iB,EAAI+C,EAAOC,WAChD2f,EAAU1f,IAAMtE,KAAKC,MAAM+jB,EAAU5iB,EAAIgD,EAAOC,WAChD2f,EAAUzhB,OAAOC,MAAQwhB,EAAU3iB,EAAI+C,EAAOC,UAC9C2f,EAAUzhB,OAAOE,SAAW2B,EAAOC,UAAY2f,EAAUzhB,OAAOC,MAChEwhB,EAAUzhB,OAAOG,OAASshB,EAAU5iB,EAAIgD,EAAOC,UAC/C2f,EAAUzhB,OAAOI,QAAUyB,EAAOC,UAAY2f,EAAUzhB,OAAOG,OAE/DuhB,EAAU7iB,EAAIggB,EAAGhgB,EAAIggB,EAAG9f,aAAauD,UACrCof,EAAU5iB,EAAI+f,EAAG/f,EAAI+f,EAAG9f,aAAawD,WACrCmf,EAAU9f,IAAMnE,KAAKC,MAAMgkB,EAAU5iB,EAAI+C,EAAOC,WAChD4f,EAAU3f,IAAMtE,KAAKC,MAAMgkB,EAAU7iB,EAAIgD,EAAOC,WAChD4f,EAAU1hB,OAAOC,MAAQyhB,EAAU5iB,EAAI+C,EAAOC,UAC9C4f,EAAU1hB,OAAOE,SAAW2B,EAAOC,UAAY4f,EAAU1hB,OAAOC,MAChEyhB,EAAU1hB,OAAOG,OAASuhB,EAAU7iB,EAAIgD,EAAOC,UAC/C4f,EAAU1hB,OAAOI,QAAUyB,EAAOC,UAAY4f,EAAU1hB,OAAOG,OAExD,CAAEshB,EAAWC,EACtB,CAEA,SAASlC,EAAcZ,EAAsBC,GAmB3C,OAlBA8C,EAAU9iB,EAAI+f,EAAG/f,EAAI+f,EAAG7f,aAAauD,UACrCqf,EAAU7iB,EAAI8f,EAAG9f,EAAI8f,EAAG7f,aAAawD,WACrCof,EAAU/f,IAAMnE,KAAKC,MAAMikB,EAAU7iB,EAAI+C,EAAOC,WAChD6f,EAAU5f,IAAMtE,KAAKC,MAAMikB,EAAU9iB,EAAIgD,EAAOC,WAChD6f,EAAU3hB,OAAOC,MAAQ0hB,EAAU7iB,EAAI+C,EAAOC,UAC9C6f,EAAU3hB,OAAOE,SAAW2B,EAAOC,UAAY6f,EAAU3hB,OAAOC,MAChE0hB,EAAU3hB,OAAOG,OAASwhB,EAAU9iB,EAAIgD,EAAOC,UAC/C6f,EAAU3hB,OAAOI,QAAUyB,EAAOC,UAAY6f,EAAU3hB,OAAOG,OAE/DyhB,EAAU/iB,EAAIggB,EAAGhgB,EAAIggB,EAAG9f,aAAauD,UACrCsf,EAAU9iB,EAAI+f,EAAG/f,EAAI+f,EAAG9f,aAAawD,WACrCqf,EAAUhgB,IAAMnE,KAAKC,MAAMkkB,EAAU9iB,EAAI+C,EAAOC,WAChD8f,EAAU7f,IAAMtE,KAAKC,MAAMkkB,EAAU/iB,EAAIgD,EAAOC,WAChD8f,EAAU5hB,OAAOC,MAAQ2hB,EAAU9iB,EAAI+C,EAAOC,UAC9C8f,EAAU5hB,OAAOE,SAAW2B,EAAOC,UAAY8f,EAAU5hB,OAAOC,MAChE2hB,EAAU5hB,OAAOG,OAASyhB,EAAU/iB,EAAIgD,EAAOC,UAC/C8f,EAAU5hB,OAAOI,QAAUyB,EAAOC,UAAY8f,EAAU5hB,OAAOG,OAExD,CAAEwhB,EAAWC,EACtB,CAEA,SAASxC,EAAcR,EAAsBC,GAmB3C,OAlBAgD,EAAUhjB,EAAI+f,EAAG/f,EAAI+f,EAAG7f,aAAauD,UACrCuf,EAAU/iB,EAAI8f,EAAG9f,EAAI8f,EAAG7f,aAAawD,WACrCsf,EAAUjgB,IAAMnE,KAAKC,MAAMmkB,EAAU/iB,EAAI+C,EAAOC,WAChD+f,EAAU9f,IAAMtE,KAAKC,MAAMmkB,EAAUhjB,EAAIgD,EAAOC,WAChD+f,EAAU7hB,OAAOC,MAAQ4hB,EAAU/iB,EAAI+C,EAAOC,UAC9C+f,EAAU7hB,OAAOE,SAAW2B,EAAOC,UAAY+f,EAAU7hB,OAAOC,MAChE4hB,EAAU7hB,OAAOG,OAAS0hB,EAAUhjB,EAAIgD,EAAOC,UAC/C6f,EAAU3hB,OAAOI,QAAUyB,EAAOC,UAAY+f,EAAU7hB,OAAOG,OAE/D2hB,EAAUjjB,EAAIggB,EAAGhgB,EAAIggB,EAAG9f,aAAauD,UACrCwf,EAAUhjB,EAAI+f,EAAG/f,EAAI+f,EAAG9f,aAAawD,WACrCuf,EAAUlgB,IAAMnE,KAAKC,MAAMokB,EAAUhjB,EAAI+C,EAAOC,WAChDggB,EAAU/f,IAAMtE,KAAKC,MAAMokB,EAAUjjB,EAAIgD,EAAOC,WAChDggB,EAAU9hB,OAAOC,MAAQ6hB,EAAUhjB,EAAI+C,EAAOC,UAC9CggB,EAAU9hB,OAAOE,SAAW2B,EAAOC,UAAYggB,EAAU9hB,OAAOC,MAChE6hB,EAAU9hB,OAAOG,OAAS2hB,EAAUjjB,EAAIgD,EAAOC,UAC/C8f,EAAU5hB,OAAOI,QAAUyB,EAAOC,UAAYggB,EAAU9hB,OAAOG,OAExD,CAAE0hB,EAAWC,EACtB,C,kECzmCA,gBAEA,UACA,SACA,UAEA,UACA,UACA,UACA,UACA,UAEA,MAAqBC,EAOnBnjB,cACEojB,OAAOC,QAAU,KACf,UAAUC,SAAS,EAGrBH,EAAKI,kBAAkBC,IAAI,UAAWC,SAAU,CAAEC,OAAQ,GAAKC,OAAQ,IACvER,EAAKI,kBAAkBC,IAAI,UAAWI,MAAU,CAAEF,OAAQ,GAAKC,OAAQ,IAEvE,UAAYlnB,MAAQonB,GAAcjnB,KAAKknB,gBAAgB,UAAWF,MAAOC,KACzE,UAAepnB,MAAKonB,GAAcjnB,KAAKknB,gBAAgB,UAAWL,SAAUI,IAC9E,CAEOvlB,QACL,MAAMylB,EAAeC,aAAY,KAC3Bb,EAAKQ,SACPM,cAAcF,GACdZ,EAAKja,aAAaM,SAAS,UAAY0a,W,GAExC,KAEHtnB,KAAKunB,SAAS,EAChB,CAEQL,gBAAgBM,EAAmBP,GACzC,MAAMQ,EAAalB,EAAKI,kBAAkBe,IAAIF,GAC9CC,EAAWV,OAASE,EACpBV,EAAKI,kBAAkBC,IAAIY,EAAOC,GAElClB,EAAKoB,iBAAmB,EACxB,IAAK,MAAOC,EAAMrmB,KAAUglB,EAAKI,kBAC/BJ,EAAKoB,kBAAoBpmB,EAAMwlB,OAASxlB,EAAMulB,OAGlB,IAA1BP,EAAKoB,mBACPpB,EAAKQ,QAAS,EAElB,CAEQQ,SAASM,QAEoBC,IAA/B,UAAS1G,oBACX,UAASA,kBAAoByG,GAE/B,UAASE,oBAAoBF,EAAY,UAASzG,mBAElDphB,KAAKoM,SACLpM,KAAKwQ,SACL,UAAUwX,mBAAmB,UAAS5G,kBAAmB,UAAShX,kBAElE,UAASgX,kBAAoByG,EAC7BrB,OAAOyB,uBAAuBC,GAAOloB,KAAKunB,SAASW,IACrD,CAEQ9b,SACNma,EAAKja,aAAaF,QACpB,CAEQoE,SACN,UAAOxG,QACPuc,EAAKja,aAAakE,SACdnK,EAAOuH,MAAM8S,KACf,UAAUyH,eAEd,EAtEF,YACgB,EAAApB,QAAkB,EAClB,EAAAY,iBAA2B,EAC3B,EAAAhB,kBAAyE,IAAIlU,IAE7E,EAAAnG,aAAiC,IAAI,S,kECjBrD,gBAEA,UAEA,UACA,UAGA,UAEA,8BAgBU,KAAA8b,iBAAoBpX,IAClBA,EAAEoG,UACH,EAAAC,cAAcgR,OACjB,UAAK/b,aAAaM,SAAS,UAAY0a,U,CAgB/C,CAlCSgB,QACL9B,OAAO+B,iBAAiB,UAAWvoB,KAAKooB,iBAC1C,CACOI,OACLhC,OAAOiC,oBAAoB,UAAWzoB,KAAKooB,iBAC7C,CAEOhc,SAEP,CAEOoE,SACLxQ,KAAK0oB,oBACP,CAUQA,qBACN,EAAAjpB,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SACN,YACArE,EAAOwK,aAAe,EAAI,GACzBxK,EAAOsE,cAAgB,EAAK,IAEjC,EAAAlL,QAAQmL,QACV,E,kEC5CF,gBAEA,UAEA,UACA,UAGA,UAEA,UAEA,8BAgBU,KAAAwd,iBAAoBpX,IACtBA,EAAEoG,UAAY,EAAAC,cAAcgR,QAC1B,UAAMM,eACR,UAAMC,uBACN,UAAKtc,aAAaM,SAAS,UAAYic,WAEvC,UAAMC,YACN,UAAKxc,aAAaM,SAAS,UAAYJ,U,CA0B/C,CAhDS8b,QACL9B,OAAO+B,iBAAiB,UAAWvoB,KAAKooB,iBAC1C,CACOI,OACLhC,OAAOiC,oBAAoB,UAAWzoB,KAAKooB,iBAC7C,CAEOhc,SAEP,CAEOoE,SACLxQ,KAAK+oB,4BACP,CAcQA,6BACN,EAAAtpB,QAAQ4K,YAEN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SACN,SAAS,UAAMd,wBACfvD,EAAOwK,aAAe,EAAI,IACzBxK,EAAOsE,cAAgB,GAI1B,EAAAlL,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQiL,SACN,SAASzI,KAAKwI,MAAM,EAAAX,WAAWK,wBAA0B,eACzD9D,EAAOwK,aAAe,EAAI,IACzBxK,EAAOsE,cAAgB,EAAK,IAEjC,EAAAlL,QAAQmL,QACV,E,iEC5DF,gBAGA,UACA,UAEA,gBACS0d,QAEP,CACOE,OAEP,CAEOpc,SAEP,CAEOoE,SACLxQ,KAAKgpB,mBACP,CAEQA,oBACN,EAAAvpB,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SAAS,YAAsC,IAAxB,UAAKid,oBAA4BthB,EAAOwK,aAAe,EAAI,GAAIxK,EAAOsE,cAAgB,EAAI,IAC3H,EAAAlL,QAAQmL,QACV,E,kEC5BF,gBAEA,UAEA,UACA,UACA,UAGA,UAEA,8BACU,KAAApI,kBAA4B,EAC5B,KAAAG,gBAA0B,UAASwe,WACnC,KAAA8H,qBAA+B,EAoC/B,KAAAC,oBAAuBlY,IACrBA,EAAEoG,UACH,EAAAC,cAAcgR,OACjB,UAAK/b,aAAaM,SAAS,UAAYJ,Q,CAI/C,CAzCS8b,QACL9B,OAAO+B,iBAAiB,UAAWvoB,KAAKkpB,oBAC1C,CACOV,OACLhC,OAAOiC,oBAAoB,UAAWzoB,KAAKkpB,oBAC7C,CAEO9c,SACLpM,KAAKwC,mBAAqBxC,KAAKwC,kBAAoB,UAAS4H,kBAAoBpK,KAAK2C,gBACjF3C,KAAKwC,mBAAqBxC,KAAK2C,gBAAkB,EACnD3C,KAAKipB,qBAAsB,EAE3BjpB,KAAKipB,qBAAsB,CAG/B,CAEOzY,SACLxQ,KAAKmpB,cACP,CAEQA,eACN,EAAA1pB,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UAEpB,EAAA7K,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SAAS,gCAAiCrE,EAAOwK,aAAe,EAAI,IAAKxK,EAAOsE,cAAgB,EAAI,IACxG3K,KAAKipB,sBACP,EAAAxpB,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SAAS,uBAAwBrE,EAAOwK,aAAe,EAAI,IAAKxK,EAAOsE,cAAgB,EAAI,KAEvG,EAAAlL,QAAQmL,QACV,E,kEC/CF,gBAEA,8BACU,KAAAwe,aAA2B,UAAYC,OAmBjD,CAjBS9c,WACL,OAAOvM,KAAKopB,YACd,CACOxc,SAAS0c,GACdtpB,KAAKopB,aAAaZ,KAAKc,GACvB,MAAMtlB,EAAgBhE,KAAKopB,aAG3B,OAFAE,EAAUhB,MAAMtkB,GAChBhE,KAAKopB,aAAeE,EACbtpB,KAAKopB,YACd,CAEOhd,SACLpM,KAAKopB,aAAahd,QACpB,CACOoE,SACLxQ,KAAKopB,aAAa5Y,QACpB,E,kECtBF,gBAEA,UAEA,UACA,UAEA,UAEA,8BAkBU,KAAA+Y,aAAgBvY,IACtB,OAAQA,EAAEoG,SACR,KAAK,EAAAC,cAAcmS,IACjBxY,EAAEyY,iBACF,UAAYjd,QAAQkd,cACpB,UAAKpd,aAAaM,SAAS,UAAY0a,WACvC,MACF,KAAK,EAAAjQ,cAAc7H,EACjB,UAAKlD,aAAaM,SAAS,UAAYJ,S,CAgB/C,CAzCS8b,QACL9B,OAAO+B,iBAAiB,UAAWvoB,KAAKupB,aAC1C,CAEOf,OACLhC,OAAOiC,oBAAoB,UAAWzoB,KAAKupB,aAC7C,CAEOnd,SAEP,CAEOoE,SACL,UAAYhE,QAAQgE,SACpBxQ,KAAK2pB,eACP,CAeQA,gBACN,EAAAlqB,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,iBAEf,EAAA9K,QAAQiL,SAAS,SAAUrE,EAAOwK,aAAe,EAAI,GAAIxK,EAAOsE,cAAgB,EAAI,IACpF,EAAAlL,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SAAS,eAAmBrE,EAAOwK,aAAe,EAAI,GAAIxK,EAAOsE,cAAgB,EAAI,IAC7F,EAAAlL,QAAQiL,SAAS,kBAAmBrE,EAAOwK,aAAe,EAAI,GAAIxK,EAAOsE,cAAgB,EAAI,IAC/F,EAAAlL,QAAQmL,QACV,E,kEClDF,gBAGA,UAEA,UACA,UAEA,UACA,UACA,UACA,UAEA,UAEA,UAEA,8BAwFS,KAAAgf,sBAAyB5Y,IAC9BhR,KAAKqM,OAAO4M,aAAY,EAAK,EAExB,KAAA4Q,uBAA0B7Y,IAC/BhR,KAAKqM,OAAO4M,aAAY,EAAM,EAGxB,KAAAsQ,aAAgBvY,IACtB,OAAQA,EAAEoG,SACR,KAAK,EAAAC,cAAcmS,IACnB,KAAK,EAAAnS,cAAc7H,EACjBwB,EAAEyY,iBACF,UAAKnd,aAAaM,SAAS,UAAYkd,Q,CAI/C,CApGSxB,MAAMtkB,GACPA,IAAkB,UAAY8lB,QAChC9pB,KAAK+pB,eAEP/pB,KAAKgqB,wBACP,CAEQA,yBACNxD,OAAOyD,OAAS,KACd,UAAK3d,aAAaM,SAAS,UAAYkd,OAAO,EAEhDtD,OAAO+B,iBAAiB,UAAWvoB,KAAKupB,aAC1C,CAEOf,KAAKc,GACVtpB,KAAKkqB,yBACDZ,IAAc,UAAYQ,QAC5B9pB,KAAK0pB,aAET,CAEQQ,yBACN1D,OAAOyD,OAAS,KAChBzD,OAAOiC,oBAAoB,UAAWzoB,KAAKupB,aAC7C,CAEOnd,SACDpM,KAAKqM,OAAOyK,OACd,UAAOqT,sBACP,UAAS/d,OAAOpM,KAAKqM,QACrBrM,KAAKqM,OAAOD,SACZpM,KAAKgU,IAAI5H,SACTpM,KAAKoqB,gCAEL,EAAAtgB,WAAWugB,qCAEX,UAAMzB,uBACN,UAAKtc,aAAaM,SAAS,UAAY0d,WAE3C,CAEO9Z,SACLxQ,KAAKgU,IAAIjR,OACT/C,KAAKqM,OAAOtJ,OACRsD,EAAOuH,MAAM2c,iBACf,EAAAzgB,WAAW0gB,sCAEf,CAEQT,eACN/pB,KAAKgU,IAAM,IAAI,UACfhU,KAAKqM,OAASrM,KAAKgU,IAAI3H,OAEvB,UAASoe,mBAAmBzqB,KAAKqM,OAAO4L,gBACxC,UAASyS,iBAAiB1qB,KAAKqM,OAAOqL,cAEtC,UAAMiT,KAAK3qB,KAAK4pB,sBAAuB5pB,KAAK6pB,uBAC9C,CAEQO,gCAEuB,IAA3B,UAAIQ,oBACJ5qB,KAAK6qB,mCAEH,UAAKve,aAAaM,SAAS,UAAYke,cAE7C,CAEQD,kCACN,OACE7qB,KAAKqM,OAAOjG,MAAQ,UAAI8M,WAAW9M,KACnCpG,KAAKqM,OAAO9F,MAAQ,UAAI2M,WAAW3M,GAEvC,CAEOmjB,cACL,UAASqB,+BAA+B/qB,KAAKqM,OAAO4L,gBACpD,UAAM+S,8BAA8BhrB,KAAK4pB,sBAAuB5pB,KAAK6pB,wBAErE7pB,KAAKgU,IAAIjB,UACT/S,KAAKgU,IAAM,KACXhU,KAAKqM,OAAS,IAChB,E,kECvGF,gBAEA,UAEA,UACA,UAGA,UAEA,8BAgBU,KAAA+b,iBAAoBpX,IAClBA,EAAEoG,UACH,EAAAC,cAAcgR,OACjB,UAAK/b,aAAaM,SAAS,UAAY0a,U,CAgB/C,CAlCSgB,QACL9B,OAAO+B,iBAAiB,UAAWvoB,KAAKooB,iBAC1C,CACOI,OACLhC,OAAOiC,oBAAoB,UAAWzoB,KAAKooB,iBAC7C,CAEOhc,SAEP,CAEOoE,SACLxQ,KAAKirB,mBACP,CAUQA,oBACN,EAAAxrB,QAAQ4K,YACN,EAAA5K,QAAQ6K,UAAY,UACpB,EAAA7K,QAAQ8K,KAAO,iBACf,EAAA9K,QAAQiL,SACN,WACArE,EAAOwK,aAAe,EAAI,GACzBxK,EAAOsE,cAAgB,EAAK,IAEjC,EAAAlL,QAAQmL,QACV,E,kEC3CF,eACA,UACA,UACA,UACA,UACA,UACA,UAEMsgB,EAA8C,CAClD7B,QAAgB,IAAI,UACpB/B,UAAgB,IAAI,UACpB9a,QAAgB,IAAI,UACpBse,cAAgB,IAAI,UACpBhB,OAAgB,IAAI,UACpBQ,UAAgB,IAAI,UACpBzB,QAAgB,IAAI,WAGtB,UAAeqC,C,sKCnBf,gBAeA,gCAAqCnb,EAAWC,GAC9C,OAAO/N,KAAKiP,MAAMlB,EAAG3M,EAAI0M,EAAG1M,IAAM2M,EAAG3M,EAAI0M,EAAG1M,IAAM2M,EAAG1M,EAAIyM,EAAGzM,IAAM0M,EAAG1M,EAAIyM,EAAGzM,GAC9E,EAEA,8BAAmCyM,EAAWC,GAE5C,OADc/N,KAAKkpB,MAAOpb,EAAGzM,EAAI0M,EAAG1M,EAAKyM,EAAG1M,EAAI2M,EAAG3M,EAErD,EAEA,sCAA2CmM,GACzCA,EAAEpJ,IAAMnE,KAAKC,MAAMsN,EAAElM,EAAI+C,EAAOC,WAChCkJ,EAAEjJ,IAAMtE,KAAKC,MAAMsN,EAAEnM,EAAIgD,EAAOC,UAClC,EAEA,6BAAkCkJ,GAChCA,EAAEhL,OAAOC,MAAQ+K,EAAElM,EAAI+C,EAAOC,UAC9BkJ,EAAEhL,OAAOE,SAAW2B,EAAOC,UAAYkJ,EAAEhL,OAAOC,MAChD+K,EAAEhL,OAAOG,OAAS6K,EAAEnM,EAAIgD,EAAOC,UAC/BkJ,EAAEhL,OAAOI,QAAUyB,EAAOC,UAAYkJ,EAAEhL,OAAOG,MACjD,C,iHClCa,EAAAkf,aAAe5hB,KAAKgU,GAAGoC,QAAQ,GAE5C,kBAAuB8H,EAAaC,GAClC,OAAOD,EAAMle,KAAKC,MAAMD,KAAKE,UAAYie,EAAMD,EAAM,GACvD,EAEA,4BAAiCiL,GAC/B,OAAOA,GAAW,IAAMnpB,KAAKgU,GAC/B,C,kECPA,gBAEA,MAAqBoV,EACZ1rB,cAAc0M,GACnB,MAAMif,EAAWC,UAAUC,cACvBF,EAAS,KACXtrB,KAAKyrB,eAAeH,EAAS,GAAIjf,GACjCrM,KAAK0rB,aAAaJ,EAAS,IAC3BtrB,KAAK2rB,cAAcL,EAAS,GAAIjf,GAEpC,CAIQ1M,sBAAsBisB,EAAcvf,GAC1C,MAAMwf,GAAyBD,EAAQE,KAAK,GAAGzT,QAAQ,GACnDwT,EAAgB,GAClBxf,EAAO/H,OAAOH,OAAQ,EACtBkI,EAAOpI,iBAAiBE,OAAQ,GAEzB0nB,EAAgB,GACvBxf,EAAO/H,OAAOJ,MAAO,EACrBmI,EAAOpI,iBAAiBC,MAAO,IAG/BmI,EAAO/H,OAAOJ,MAAO,EACrBmI,EAAOpI,iBAAiBC,MAAO,EAE/BmI,EAAO/H,OAAOH,OAAQ,EACtBkI,EAAOpI,iBAAiBE,OAAQ,GAGlC,MAAM4nB,GAAyBH,EAAQE,KAAK,GAAGzT,QAAQ,GACnD0T,EAAgB,GAClB1f,EAAO/H,OAAOD,MAAO,EACrBgI,EAAOpI,iBAAiBI,MAAO,GAExB0nB,EAAgB,GACvB1f,EAAO/H,OAAOF,IAAK,EACnBiI,EAAOpI,iBAAiBG,IAAK,IAG7BiI,EAAO/H,OAAOF,IAAK,EACnBiI,EAAOpI,iBAAiBG,IAAK,EAE7BiI,EAAO/H,OAAOD,MAAO,EACrBgI,EAAOpI,iBAAiBI,MAAO,EAEnC,CAEQ1E,oBAAoBisB,GAC1B,MAAMI,EAAWJ,EAAQE,KAAK,GACxBG,EAAWL,EAAQE,KAAK,GACD,IAAxBE,EAAS3T,QAAQ,KACpB,UAAMhV,GAAK2oB,EAAWhsB,KAAKksB,aAEA,IAAxBD,EAAS5T,QAAQ,KACpB,UAAM/U,GAAK2oB,EAAWjsB,KAAKksB,YAE/B,CAEQvsB,qBAAqBisB,EAAcvf,GAC9Buf,EAAQO,QAAQ,GACpBC,QACL/f,EAAO4M,aAAY,GAGnB5M,EAAO4M,aAAY,EAEvB,EAnEF,YAUiB,EAAAiT,YAAsB,E,gECXvC,gBACSvsB,0BAA0B0sB,GAC/B7M,SAAS+I,iBAAiB,UAAW8D,EACvC,CACO1sB,wBAAwB0sB,GAC7B7M,SAAS+I,iBAAiB,QAAS8D,EACrC,CAEO1sB,sCAAsC0sB,GAC3C7M,SAASiJ,oBAAoB,QAAS4D,GACtC7M,SAASiJ,oBAAoB,UAAW4D,EAC1C,E,kECbF,gBAIA,MAAqBC,EAGZ3sB,YAAY4sB,EAAsCC,GACvDxsB,KAAKysB,mBACLzsB,KAAK0sB,qBACL1sB,KAAK2sB,oBAAoBJ,EAAmBC,EAC9C,CACQ7sB,0BACN6mB,OAAO+B,iBAAiB,eAAevX,IACrCA,EAAEyY,gBAAgB,IACjB,EACL,CAEQ9pB,4BAC4B,UAAOogB,sBAClCwI,iBAAiB,aAAavX,IACnChR,KAAKqD,EAAI2N,EAAE4b,MACX5sB,KAAKsD,EAAI0N,EAAE6b,KAAK,IACf,EACL,CAEQltB,2BAA2B4sB,EAAsCC,GACvE,MAAMjN,EAA4B,UAAOQ,sBACzCR,EAAOgJ,iBAAiB,YAAagE,GAAmB,GACxDhN,EAAOgJ,iBAAiB,UAAWiE,GAAiB,EACtD,CAEO7sB,qCAAqC4sB,EAAsCC,GAChF,MAAMjN,EAA4B,UAAOQ,sBACzCR,EAAOkJ,oBAAoB,YAAa8D,GACxChN,EAAOkJ,oBAAoB,UAAW+D,EACxC,EAhCF,YACgB,EAAAnpB,EAAYmjB,OAAOsG,WAAc,EAAI,IACrC,EAAAxpB,EAAYkjB,OAAOuG,YAAc,EAAI,E,uFCNxC,EAAA1V,cAAgB,CAC3BgR,MAAO,GACPmB,IAAK,GACLlS,EAAG,GACH9E,EAAG,GACH+E,EAAG,GACHC,EAAG,GACHhI,EAAG,GACH,EAAG,GACH,EAAG,G,wsHCRDwd,EAA2B,CAAC,GCCb,IDEnB,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBpF,IAAjBqF,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CAGjDE,QAAS,CAAC,GAOX,OAHAE,EAAoBJ,GAAUG,EAAQA,EAAOD,QAASH,GAG/CI,EAAOD,OACf,CCtBA,OAEuB,UAClB1rB,O","sources":["webpack://retro-2d-game-engine/./src/app/audio/AudioBufferLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioContext.ts","webpack://retro-2d-game-engine/./src/app/audio/AudioLoader.ts","webpack://retro-2d-game-engine/./src/app/audio/Mixer.ts","webpack://retro-2d-game-engine/./src/app/audio/SoundFX.ts","webpack://retro-2d-game-engine/./src/app/domain/AnimationState.ts","webpack://retro-2d-game-engine/./src/app/domain/AttackEdgeCases.ts","webpack://retro-2d-game-engine/./src/app/domain/Creature.ts","webpack://retro-2d-game-engine/./src/app/domain/CreatureState.ts","webpack://retro-2d-game-engine/./src/app/domain/Level.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/ConcreteEnemy.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationAttacking.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationAttackingCooldown.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationDecaying.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationDying.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationIdling.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationMoving.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/ConcreteEnemyAnimationMovingCooldown.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/ConcreteEnemy/animations/index.ts","webpack://retro-2d-game-engine/./src/app/domain/enemies/Enemy.ts","webpack://retro-2d-game-engine/./src/app/domain/map/Map.ts","webpack://retro-2d-game-engine/./src/app/domain/map/MapKeys.ts","webpack://retro-2d-game-engine/./src/app/domain/map/Maps.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/GameObject.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/portal/Portal.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/portal/PortalObject.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/wall/Wall.ts","webpack://retro-2d-game-engine/./src/app/domain/objects/wall/WallFactory.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Crosshair.ts","webpack://retro-2d-game-engine/./src/app/domain/player/Player.ts","webpack://retro-2d-game-engine/./src/app/domain/player/projectiles/Projectile.ts","webpack://retro-2d-game-engine/./src/app/domain/player/projectiles/ProjectileCircle.ts","webpack://retro-2d-game-engine/./src/app/domain/player/projectiles/ProjectileLine.ts","webpack://retro-2d-game-engine/./src/app/domain/player/weapons/RangedWeapon.ts","webpack://retro-2d-game-engine/./src/app/domain/player/weapons/RifleCircle.ts","webpack://retro-2d-game-engine/./src/app/domain/player/weapons/RifleLine.ts","webpack://retro-2d-game-engine/./src/app/domain/widgets/DamageNumbers.ts","webpack://retro-2d-game-engine/./src/app/graphics/GraphicsLoader.ts","webpack://retro-2d-game-engine/./src/app/graphics/Sprites.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/CreatureSprite.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/DecaySprite.ts","webpack://retro-2d-game-engine/./src/app/graphics/sprites/ZergSprite.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Canvas.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/CollisionBox.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Directions.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/FrameRate.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/GameAssets.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/GameTime.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Pathfinding.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/Raycaster.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/Game.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateGameOver.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateLevelCleared.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStateVictory.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/game/game_states/GameStates.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/geometry/Point.ts","webpack://retro-2d-game-engine/./src/app/infrastructure/math/MathUtils.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Gamepads.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Keyboard.ts","webpack://retro-2d-game-engine/./src/app/peripherals/Mouse.ts","webpack://retro-2d-game-engine/./src/app/peripherals/constants/KeyCodes.ts","webpack://retro-2d-game-engine/webpack/bootstrap","webpack://retro-2d-game-engine/./src/main.ts"],"sourcesContent":["import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static PLAYER_DEATH: AudioBuffer[] = []\n\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static PLAYER_HIT: AudioBuffer[] = []\n  private static PLAYER_HIT_INDEX = 0\n  private static PLAYER_HIT_READY: boolean = true\n\n  private static ENEMY_ATTACK: AudioBuffer[] = []\n  private static ENEMY_ATTACK_MISS: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/player_death_1.wav'),\n\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/player_hit_1.mp3'),\n      load('./audio/player_hit_2.mp3'),\n      load('./audio/player_hit_3.mp3'),\n      load('./audio/player_hit_4.mp3'),\n      load('./audio/player_hit_5.mp3'),\n\n      load('./audio/enemy_attack_1.wav'),\n      load('./audio/enemy_attack_2.wav'),\n      load('./audio/enemy_attack_miss.wav'),\n\n      load('./audio/enemy_hit_1.wav'),\n      load('./audio/enemy_hit_2.wav'),\n      load('./audio/enemy_hit_3.wav'),\n\n      load('./audio/enemy_death_1.wav'),\n      load('./audio/enemy_death_2.wav'),\n      load('./audio/enemy_death_3.wav'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.PLAYER_DEATH[0] = soundFxFiles[0]\n\n    this.SMG[0] = soundFxFiles[1]\n    this.SMG[1] = soundFxFiles[2]\n    this.SMG[2] = soundFxFiles[3]\n    this.SMG[3] = soundFxFiles[4]\n    this.SMG[4] = soundFxFiles[5]\n\n    this.CRATE_HIT[0] = soundFxFiles[6]\n\n    this.PLAYER_HIT[0] = soundFxFiles[7]\n    this.PLAYER_HIT[1] = soundFxFiles[8]\n    this.PLAYER_HIT[2] = soundFxFiles[9]\n    this.PLAYER_HIT[3] = soundFxFiles[10]\n    this.PLAYER_HIT[4] = soundFxFiles[11]\n\n    setLoadedPercentage(0.5)\n\n    this.ENEMY_ATTACK[0] = soundFxFiles[12]\n    this.ENEMY_ATTACK[1] = soundFxFiles[13]\n\n    this.ENEMY_ATTACK_MISS[0] = soundFxFiles[14]\n\n    this.ENEMY_HIT[0] = soundFxFiles[15]\n    this.ENEMY_HIT[1] = soundFxFiles[16]\n    this.ENEMY_HIT[2] = soundFxFiles[17]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[18]\n    this.ENEMY_DEATH[2] = soundFxFiles[19]\n    this.ENEMY_DEATH[2] = soundFxFiles[20]\n\n    setLoadedPercentage(1.0)\n  }\n\n  public static playPlayerDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.PLAYER_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playPlayerHit(): void {\n    if (this.PLAYER_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.PLAYER_HIT[this.PLAYER_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.PLAYER_HIT_INDEX = ++this.PLAYER_HIT_INDEX % this.PLAYER_HIT.length // Shuffle\n\n    this.PLAYER_HIT_READY = false\n    setTimeout(() => { this.PLAYER_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyAttack(): void {\n    const playSound = context.createBufferSource()\n\n    const randomIndex = Math.floor(Math.random() * this.ENEMY_ATTACK.length)\n    playSound.buffer = this.ENEMY_ATTACK[randomIndex]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playEnemyAttackMiss(): void {\n    const playSound = context.createBufferSource()\n\n    playSound.buffer = this.ENEMY_ATTACK_MISS[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    const randomIndex = Math.floor(Math.random() * this.ENEMY_HIT.length)\n    playSound.buffer = this.ENEMY_HIT[randomIndex]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 200)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n\n    const randomIndex = Math.floor(Math.random() * this.ENEMY_DEATH.length)\n    playSound.buffer = this.ENEMY_DEATH[randomIndex]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playWallHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport GameTime from '@app/infrastructure/GameTime'\n\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport Creature from '@app/domain/Creature'\n\nexport default abstract class AnimationState {\n  protected sprite: CreatureSprite\n\n  protected animationLength   : number // ms\n  protected animationProgress : number // ms\n\n  protected numberOfSpritesInAnimation : number // integer\n  protected animationSpritePosition    : number // integer\n\n  protected oneShotAnimation = false\n\n  public animationFinished: boolean\n  \n  public advanceAnimation(): void {\n    if (this.animationFinished && this.oneShotAnimation) {\n      return // don't animate\n    }\n\n    this.animationProgress = this.animationProgress + GameTime.elapsedTimeFactor\n    const animationProgressPercentage = this.animationProgress / this.animationLength\n    this.animationSpritePosition = Math.floor(animationProgressPercentage * this.numberOfSpritesInAnimation) % this.numberOfSpritesInAnimation\n\n    this.animationFinished = animationProgressPercentage >= 1.0\n  }\n\n  public resetAnimation(): void {\n    this.animationFinished = false\n    this.animationProgress = 0\n    this.animationSpritePosition = 0\n  }\n\n  public draw(c: Creature, playerCoordinates: Point): void {\n    this.sprite.draw(c, playerCoordinates, this.animationSpritePosition)\n  }\n}\n","enum AttackEdgeCases {\n  Miss     = 'Miss',\n  Critical = 'Critical', // TODO: Implement critical strike\n}\n\nexport default AttackEdgeCases","import * as CONFIG from '@app/configuration/config.json'\n\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\nimport GameTime from '@app/infrastructure/GameTime'\nimport CollisionBox, { collisionBoxesIntersect, ICollidable } from '@app/infrastructure/CollisionBox'\nimport { Directions, MovingDirections, getDirectionBasedOnAngle } from '@app/infrastructure/Directions'\n\nimport Map from '@app/domain/map/Map'\nimport CreatureState from '@app/domain/CreatureState'\nimport { Widget } from '@app/domain/widgets/DamageNumbers'\n\nexport default abstract class Creature {\n  private prevHistoryLength = 8\n  public prevX: number[] = [] // TODO: Make private?\n  public prevY: number[] = [] // TODO: Make private?\n\n  public nextX: number\n  public nextY: number\n\n  public row: number\n  public col: number\n\n  public maxHealth = 100\n  public health: number\n\n  public maxSpeed: number         // Derived from this.speed\n  public maxSpeedDiagonal: number // Derived from this.speed\n\n  public state: CreatureState = CreatureState.Idling\n  public previousState: CreatureState = CreatureState.Idling // TODO: Use `previousState` for something? (Currently it's unused)\n\n  public animationSpritePosition: number = 0\n\n  public direction: Directions\n\n  // Used for sprite orientation\n  // TODO: Find a better name\n  public movingDirections: { [key in MovingDirections]: boolean } = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public moving: { [key in MovingDirections]: boolean } = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public blocked: { [key in MovingDirections]: boolean } = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n\n  protected widgets: { [key: string]: Widget } = {}\n  \n  constructor(\n    public x: number,\n    public y: number,\n    public collisionBox: CollisionBox,\n    private speed: number,\n    healthPercentage: number,\n  ) {\n    this.maxSpeed = this.speed\n    this.maxSpeedDiagonal = Math.sin(45) * this.speed\n\n    this.initializeHealth(healthPercentage)\n    this.updateMapPosition()\n  }\n\n  protected resetMoving(): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n    this.movingDirections.left  = false\n    this.movingDirections.right = false\n    this.movingDirections.up    = false\n    this.movingDirections.down  = false\n  }\n\n  protected resetBlocked(): void {\n    this.blocked.up    = false\n    this.blocked.down  = false\n    this.blocked.left  = false\n    this.blocked.right = false\n  }\n\n  // TODO: This is not 100% correct, it's just an estimation based on previous frame's length\n  protected calculateNextCoordinates(): void {\n    this.nextX = this.x\n    this.nextY = this.y\n\n    if (this.moving.left) {\n      const isDiagonalMovement = (this.moving.up || this.moving.down)\n      this.nextX -= this.calculateMovementAmountPixels(MovingDirections.left, isDiagonalMovement, false)\n    }\n    if (this.moving.right) {\n      const isDiagonalMovement = (this.moving.up || this.moving.down)\n      this.nextX += this.calculateMovementAmountPixels(MovingDirections.right, isDiagonalMovement, false)\n    }\n    if (this.moving.up) {\n      const isDiagonalMovement = (this.moving.left || this.moving.right)\n      this.nextY -= this.calculateMovementAmountPixels(MovingDirections.up, isDiagonalMovement, false)\n    }\n    if (this.moving.down) {\n      const isDiagonalMovement = (this.moving.left || this.moving.right)\n      this.nextY += this.calculateMovementAmountPixels(MovingDirections.down, isDiagonalMovement, false)\n    }\n  }\n\n  protected move(): void {\n\n    if (this.moving.left && !this.blocked.left && this.horizontalMovementControlsAreNotJammed()) {\n      const isDiagonalMovement = (this.moving.up || this.moving.down)\n      this.x -= this.calculateMovementAmountPixels(MovingDirections.left, isDiagonalMovement)\n    }\n    if (this.moving.right && !this.blocked.right && this.horizontalMovementControlsAreNotJammed()) {\n      const isDiagonalMovement = (this.moving.up || this.moving.down)\n      this.x += this.calculateMovementAmountPixels(MovingDirections.right, isDiagonalMovement)\n    }\n\n    if (this.moving.up && !this.blocked.up && this.verticalMovementControlsAreNotJammed()) {\n      const isDiagonalMovement = (this.moving.left || this.moving.right)\n      this.y -= this.calculateMovementAmountPixels(MovingDirections.up, isDiagonalMovement)\n    }\n    if (this.moving.down && !this.blocked.down && this.verticalMovementControlsAreNotJammed()) {\n      const isDiagonalMovement = (this.moving.left || this.moving.right)\n      this.y += this.calculateMovementAmountPixels(MovingDirections.down, isDiagonalMovement)\n    }\n\n    this.updateMapPosition()\n  }\n\n  // TODO: Maybe find a better solution for this\n  private horizontalMovementControlsAreNotJammed() { // Detect control jamming by pressing `left` & `right` at the same time\n    return (this.moving.left && this.moving.right) === false\n  }\n  private verticalMovementControlsAreNotJammed() { // Detect control jamming by pressing `up` & `down` at the same time\n    return (this.moving.up && this.moving.down) === false\n  }\n\n  private movementAccumulator: { [key in MovingDirections]: number } = {\n    left  : 0.0,\n    right : 0.0,\n    up    : 0.0,\n    down  : 0.0,\n  }\n\n  /**\n   * For this Game Engine we want pixelated movement, meaning that the movement amounts are Integer values\n   *\n   * Slow game speed:\n   *   When the game is slowed down enough that one frame worth of movement is below 1,\n   *   the `movementAmountDecimalPart` is sent to the `movementAccumulator`, and the `movementAccumulator`\n   *   is added to the next movement calculation.\n   *   This means that it can take, for example, 3 frames to move 1 pixel.\n   *\n   * Fast game speed:\n   *   When the game is sped up so that one frame worht of movement is above 1,\n   *   we want to preserve the spillover `movementAmountDecimalPart` and add it to\n   *   the next movement calculation.\n   *\n   * This functions makes that happen - and the result is smooth Player/Creature movement :)\n   *\n   * @param direction  - One of four possible `MovingDirections`\n   * @param isDiagonalMovement - Specifies whether the movement is diagonal or not\n   * @param accumulate - We don't want to accumulate when calling from `calculateNextCoordinates()`\n   * @returns - Integer number of pixels to move\n   */\n  private calculateMovementAmountPixels(direction: MovingDirections, isDiagonalMovement: boolean, accumulate = true): number {\n    const movementAmount = isDiagonalMovement\n      ? (GameTime.elapsedTimeFactor * this.maxSpeedDiagonal) + this.movementAccumulator[direction]\n      : (GameTime.elapsedTimeFactor * this.maxSpeed        ) + this.movementAccumulator[direction]\n    const movementAmountPixels = Math.floor(movementAmount)\n\n    if (accumulate) {\n      const movementAmountDecimalPart = (movementAmount % 1)\n      this.movementAccumulator[direction] = movementAmountDecimalPart\n    }\n\n    return movementAmountPixels\n  }\n\n  protected updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  protected updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  protected checkIfBlockedByCreature(c: Creature, nextCreatureState: ICollidable) {\n    if (collisionBoxesIntersect(nextCreatureState, c)) {\n      let intersectionX: number\n      let intersectionY: number\n      if (nextCreatureState.x < c.x) {\n        intersectionX = (nextCreatureState.x + nextCreatureState.collisionBox.halfWidth) - (c.x - c.collisionBox.halfWidth)\n      } else if (nextCreatureState.x > c.x) {\n        intersectionX = (c.x + c.collisionBox.halfWidth) - (nextCreatureState.x - nextCreatureState.collisionBox.halfWidth)\n      }\n      if (nextCreatureState.y < c.y) {\n        intersectionY = (nextCreatureState.y + nextCreatureState.collisionBox.halfHeight) - (c.y - c.collisionBox.halfHeight)\n      } else if (nextCreatureState.y > c.y) {\n        intersectionY = (c.y + c.collisionBox.halfHeight) - (nextCreatureState.y - nextCreatureState.collisionBox.halfHeight)\n      }\n      if (!intersectionX || intersectionX >= intersectionY) {\n        if (nextCreatureState.y < c.y) {\n          this.blocked.down = true\n        } else {\n          this.blocked.up = true\n        }\n      } else if (!intersectionY || intersectionX < intersectionY) {\n        if (nextCreatureState.x < c.x) {\n          this.blocked.right = true\n        } else {\n          this.blocked.left = true\n        }\n      }\n    }\n  }\n\n  protected adjustCollisionWithWalls(): void {\n    let wall\n\n    ///////////////////////////////////////////////////////////////////////////\n    // West\n    ///////////////////////////////////////////////////////////////////////////\n    if (this.moving.left) {\n      wall = Map.walls[this.row][this.col - 1] // West\n      if (wall && this.x - this.collisionBox.halfWidth - 1 <= wall.mapX + wall.width) {\n        this.x = wall.mapX + wall.width + this.collisionBox.halfWidth + 1\n        this.movingDirections.left = false\n      }\n\n      const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n      if (SWVertexRow && SWVertexRow !== this.row) { // SW vertex overflows the Creature's Tile\n        wall = Map.walls[SWVertexRow][this.col - 1] // South West\n        if (wall && this.x - this.collisionBox.halfWidth - 1 <= wall.mapX + wall.width) {\n          if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n            this.x = wall.mapX + wall.width + this.collisionBox.halfWidth + 1\n            this.movingDirections.left = false\n          }\n        }\n      }\n\n      const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n      if (NWVertexRow && NWVertexRow !== this.row) { // NW vertex overflows the Creature's Tile\n        wall = Map.walls[NWVertexRow][this.col - 1] // North West\n        if (wall && this.x - this.collisionBox.halfWidth - 1 <= wall.mapX + wall.width) {\n          if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n            this.x = wall.mapX + wall.width + this.collisionBox.halfWidth + 1\n            this.movingDirections.left = false\n          }\n        }\n      }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // East\n    ///////////////////////////////////////////////////////////////////////////\n    if (this.moving.right) {\n      wall = Map.walls[this.row][this.col + 1] // East\n      if (wall && this.x + this.collisionBox.halfWidth + 1 >= wall.mapX) {\n        this.x = wall.mapX - this.collisionBox.halfWidth - 1\n        this.movingDirections.right = false\n      }\n\n      const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexRow && SEVertexRow !== this.row) { // SE vertex overflows the Creature's Tile\n        wall = Map.walls[SEVertexRow][this.col + 1] // South East\n        if (wall && this.x + this.collisionBox.halfWidth + 1 >= wall.mapX) {\n          if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n            this.x = wall.mapX - this.collisionBox.halfWidth - 1\n            this.movingDirections.right = false\n          }\n        }\n      }\n\n      const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n      if (SEVertexRow && NEVertexRow !== this.row) { // NE vertex overflows the Creature's Tile\n        wall = Map.walls[NEVertexRow][this.col + 1] // North East\n        if (wall && this.x + this.collisionBox.halfWidth + 1 >= wall.mapX) {\n          if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n            this.x = wall.mapX - this.collisionBox.halfWidth - 1\n            this.movingDirections.right = false\n          }\n        }\n      }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // North\n    ///////////////////////////////////////////////////////////////////////////\n    if (this.moving.up) {\n      wall = Map.walls[this.row - 1][this.col] // North\n      if (wall && this.y - this.collisionBox.halfHeight - 1 <= wall.mapY + wall.height) {\n        this.y = wall.mapY + wall.height + this.collisionBox.halfHeight + 1\n        this.movingDirections.up = false\n      }\n\n      const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (NEVertexCol && NEVertexCol !== this.col) { // NE vertex overflows the Creature's Tile\n        wall = Map.walls[this.row - 1][NEVertexCol] // North East\n        if (wall && this.y - this.collisionBox.halfHeight - 1 <= wall.mapY + wall.height) {\n          if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n            this.y = wall.mapY + wall.height + this.collisionBox.halfHeight + 1\n            this.movingDirections.up = false\n          }\n        }\n      }\n\n      const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (NWVertexCol && NWVertexCol !== this.col) { // NW vertex overflows the Creature's Tile\n        wall = Map.walls[this.row - 1][NWVertexCol] // North West\n        if (wall && this.y - this.collisionBox.halfHeight - 1 <= wall.mapY + wall.height) {\n          if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n            this.y = wall.mapY + wall.height + this.collisionBox.halfHeight + 1\n            this.movingDirections.up = false\n          }\n        }\n      }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // South \n    ///////////////////////////////////////////////////////////////////////////\n    if (this.moving.down) {\n      wall = Map.walls[this.row + 1][this.col] // South\n      if (wall && this.y + this.collisionBox.halfHeight + 1 >= wall.mapY) {\n        this.y = wall.mapY - this.collisionBox.halfHeight - 1\n        this.movingDirections.down = false\n      }\n    }\n\n    const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n    if (SEVertexCol && SEVertexCol !== this.col) { // SE vertex overflows the Creature's Tile\n      wall = Map.walls[this.row + 1][SEVertexCol] // South East\n      if (wall && this.y + this.collisionBox.halfHeight + 1 >= wall.mapY) {\n        if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n          this.y = wall.mapY - this.collisionBox.halfHeight - 1\n          this.movingDirections.down = false\n        }\n      }\n    }\n\n    const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n    if (SWVertexCol && SWVertexCol !== this.col) { // SW vertex overflows the Creature's Tile\n      wall = Map.walls[this.row + 1][SWVertexCol] // South West\n      if (wall && this.y + this.collisionBox.halfHeight + 1 >= wall.mapY) {\n        if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n          this.y = wall.mapY - this.collisionBox.halfHeight - 1\n          this.movingDirections.down = false\n        }\n      }\n    }\n  }\n\n  protected updatePreviousCoordinates(): void {\n    this.prevX.push(this.x)\n    if (this.prevX.length > this.prevHistoryLength) { this.prevX.shift() }\n\n    this.prevY.push(this.y)\n    if (this.prevY.length > this.prevHistoryLength) { this.prevY.shift() }\n  }\n\n  protected updateDirection(targetCreature: Creature): void {\n    if (this.state === CreatureState.Attacking         ||\n        this.state === CreatureState.AttackingCooldown ||\n        this.state === CreatureState.MovingCooldown\n    ) {\n      this.updateDirectionWhenNotMoving(targetCreature)\n    }\n    else {\n      this.updateDirectionWhenMoving()\n    }\n  }\n\n  private updateDirectionWhenMoving(): void {\n    const direction: string[] = []\n\n    if (this.movingDirections.down && this.blocked.down === false) {\n      direction.push(Directions.S)\n    }\n    else if (this.movingDirections.up && this.blocked.up === false) {\n      direction.push(Directions.N)\n    }\n\n    if (this.movingDirections.right && this.blocked.right === false) {\n      direction.push(Directions.E)\n    }\n    else if (this.movingDirections.left && this.blocked.left === false) {\n      direction.push(Directions.W)\n    }\n\n    const directionString = direction.join('') || this.direction || 'S'\n\n    this.direction = Directions[directionString as keyof typeof Directions]\n  }\n\n  private updateDirectionWhenNotMoving(targetCreature: Creature): void {\n    const theta = angleBetweenPoints(targetCreature, this)\n    this.direction = getDirectionBasedOnAngle(theta)\n  }\n\n  protected checkIfMoving(): boolean {\n    // Check if all of the recorded prevX & prevY positions are the same\n    const xUnchanged = this.prevX.every((prevX, i) => (i === 0) ? true : (prevX === this.prevX[0]))\n    const yUnchanged = this.prevY.every((prevY, i) => (i === 0) ? true : (prevY === this.prevY[0]))\n    if (xUnchanged && yUnchanged) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  protected initializeHealth(healthPercentage: number = 1.0): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n\n  // TODO: The color strings can be moved to a single hash map in order to optimize & localize the color searches\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.1) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.2) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.3) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.4) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.5) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.6) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.7) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.8) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.9) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n}\n","enum CreatureState {\n  Idling,\n  Moving,\n  MovingCooldown,    // TODO: Try removing this state\n  Attacking,\n  AttackingCooldown, // TODO: Try removing this state\n  Dying,\n  Decaying,\n  Removed,\n}\n\nexport default CreatureState\n","import Map from '@app/domain/map/Map'\n\nimport { totalNumberOfMaps } from '@app/domain/map/Maps'\n\nexport default class Level {\n  public static lastLevel = totalNumberOfMaps\n\n  public static readonly startingLevel = 1\n\n  public static currentLevel = Level.startingLevel\n\n  public static resetToStartingLevel() {\n    Level.currentLevel = Level.startingLevel\n\n    LevelTimer.reset()\n  }\n\n  public static nextLevel() {\n    Map.clear()\n\n    Level.currentLevel++\n\n    LevelTimer.reset()\n  }\n\n  public static isLastLevel() {\n    return (Level.currentLevel === Level.lastLevel)\n  }\n}\n\nimport * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport GameTime from '@app/infrastructure/GameTime'\n\nexport class LevelTimer {\n  public static timeSpentOnCurrentLevel = 0 // ms\n\n  public static incrementTimeSpentOnCurrentLevel() {\n    LevelTimer.timeSpentOnCurrentLevel += GameTime.frameElapsedTime\n  }\n\n  public static reset() {\n    LevelTimer.timeSpentOnCurrentLevel = 0\n  }\n\n  public static debug_displayTimeSpentOnCurrentLevel() {\n    context.beginPath()\n      context.fillStyle = '#9999ff'\n      context.font = '8px Monospace'\n      const levelTimeInSeconds = Math.round(LevelTimer.timeSpentOnCurrentLevel / 1000)\n      context.fillText(`Level ${Level.currentLevel} Time: ${levelTimeInSeconds}`, 10, CONFIG.CANVAS_HEIGHT - 24)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GameTime from '@app/infrastructure/GameTime'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, findShortestPath, debug_drawPathNodes, drawNode } from '@app/infrastructure/Pathfinding'\n\nimport CreatureState from '@app/domain/CreatureState'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nimport {\n  ConcreteEnemyAnimationIdling,\n  ConcreteEnemyAnimationMoving,\n  ConcreteEnemyAnimationMovingCooldown,\n  ConcreteEnemyAnimationAttacking,\n  ConcreteEnemyAnimationAttackingCooldown,\n  ConcreteEnemyAnimationDying,\n  ConcreteEnemyAnimationDecaying,\n} from './animations'\n\nexport default class ConcreteEnemy extends Enemy {\n  protected target: Point\n\n  // TODO: Extract to CreatureState objects\n  // TODO: Adjust the feeling of enemy attack & animation\n  protected attackSpeed = 0.45 // seconds\n  protected attackCooldownSpeed = 0.40 // seconds\n\n  protected maxAttackTime     : number = (1000 * this.attackSpeed        ) / CONFIG.GAME_SPEED\n  protected maxAttackCooldown : number = (1000 * this.attackCooldownSpeed) / CONFIG.GAME_SPEED\n\n  constructor(\n    x: number,\n    y: number,\n    speed: number,\n    healthPercentage: number,\n    pathfindingTimerStart: number\n  ) {\n    super(x, y, new CollisionBox(14, 14), speed, healthPercentage)\n\n    this.pathfindingTimer = (9 * pathfindingTimerStart) % this.pathfindingInterval\n\n    // TODO: Move this function to Weapon\n    this.resetAttackTime()\n    this.resetAttackCooldown()\n\n    this.animations = {\n      [CreatureState.Idling           ]: new ConcreteEnemyAnimationIdling(),\n      [CreatureState.Moving           ]: new ConcreteEnemyAnimationMoving(),\n      [CreatureState.MovingCooldown   ]: new ConcreteEnemyAnimationMovingCooldown(),\n      [CreatureState.Attacking        ]: new ConcreteEnemyAnimationAttacking(),\n      [CreatureState.AttackingCooldown]: new ConcreteEnemyAnimationAttackingCooldown(),\n      [CreatureState.Dying            ]: new ConcreteEnemyAnimationDying(),\n      [CreatureState.Decaying         ]: new ConcreteEnemyAnimationDecaying(),\n    }\n  }\n\n  // TODO: See what more can be moved to `Enemy.update()`\n  public update(player: Player): void {\n    if (this.state >= CreatureState.Dying) {\n      super.update(player)\n\n      if (Game.stateManager.getState() === GAME_STATES.PLAYING) {\n        this.advanceAnimation(false)\n      }\n      return\n    }\n\n    if (!this.target) {\n      this.target = player\n    }\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n    this.updatePreviousCoordinates()\n\n    this.stuck = this.checkIfStuck() // TODO: Extract to state\n\n    if (\n      this.state !== CreatureState.Idling            &&\n      this.state !== CreatureState.MovingCooldown    &&\n      this.state !== CreatureState.Attacking         &&\n      this.state !== CreatureState.AttackingCooldown &&\n      this.previousState !== CreatureState.AttackingCooldown &&\n      this.previousState !== CreatureState.MovingCooldown    &&\n      this.checkIfMoving() === false\n    ) {\n      this.setState(CreatureState.Idling)\n    }\n\n    this.distanceFromTarget = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   },\n    )\n\n    const targetIsInRange = this.targetInRange(player)\n    if (\n      this.state !== CreatureState.Attacking         &&\n      this.state !== CreatureState.AttackingCooldown &&\n      targetIsInRange\n    ) {\n      this.resetAttackTime()\n      this.setState(CreatureState.Attacking)\n    }\n\n    if (\n      this.state === CreatureState.AttackingCooldown &&\n      targetIsInRange === false\n    ) {\n      this.setState(CreatureState.Moving)\n    }\n\n    if (this.state === CreatureState.Attacking) {\n\n      if (this.attackTime <= 0 && this.attackCooldown <= 0) {\n        this.attack(player)\n        this.resetAttackTime()\n        this.resetAttackCooldown()\n        if (targetIsInRange) {\n          this.setState(CreatureState.AttackingCooldown)\n          return\n        }\n      }\n\n      const attackInProgress = this.attackTime !== this.maxAttackTime\n\n      if (\n        targetIsInRange  === false &&\n        attackInProgress === false\n      ) {\n        this.setState(CreatureState.Moving)\n      }\n    }\n\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy =\n      Raycaster.determineIfThereAreObstaclesBetweenTwoPathNodes(this, player)\n\n    if ( // TODO: Clean this if statement up, if possible?\n      this.state === CreatureState.Idling ||\n      this.state === CreatureState.Moving\n    ) {\n      this.findPathToPlayer(player, this.thereAreObstaclesBetweenPlayerAndThisEnemy)\n\n      if (\n        this.state !== CreatureState.Moving &&\n        (\n          this.thereAreObstaclesBetweenPlayerAndThisEnemy === false ||\n          this.shortestPath.length > 0\n        )\n      ) {\n        this.setState(CreatureState.Moving)\n      }\n    }\n\n    this.checkForCollisionWithOtherEnemies(player) // Must come before move()\n    this.checkForCollisionWithPlayer(player)       // Must come before move()\n\n    if (this.state === CreatureState.Moving) {\n      this.move()\n    }\n\n    this.updateTileDeltas()\n\n    this.adjustCollisionWithWalls() // Must come after move()\n\n    this.updateDirection(player) // Must come after adjustCollisionWithWalls()\n\n    super.update(player)\n\n    if (Game.stateManager.getState() === GAME_STATES.PLAYING) {\n      this.advanceAttackTimeAndCooldown() // Must come before `advanceAnimation()`\n\n      this.advanceAnimation(targetIsInRange)\n    }\n  }\n\n  // TODO: See what more can be moved to `Enemy.draw()`\n  public draw(player: Player): void {\n    if (CONFIG.DEBUG.ENEMY_COLLISION_BOX) {\n      if (this.state < CreatureState.Dying) {\n        this.debug_drawCollisionBox(player)\n      }\n    }\n    if (CONFIG.DEBUG.RAY_TO_PLAYER) {\n      this.debug_drawRayToPlayer(player)\n    }\n    if (CONFIG.DEBUG.PATHFINDING_NODES) {\n      debug_drawPathNodes(this.pathfindingNodes, player, this.getHealthColor())\n    }\n    if (CONFIG.DEBUG.SHORTEST_PATH_TO_PLAYER) {\n      this.debug_drawShortestPathToPlayer(player)\n    }\n\n    super.draw(player)\n\n    if (CONFIG.DEBUG.ENEMY_STATE) {\n      this.debug_drawState(player)\n    }\n  }\n\n  // TODO: Extract to ConcreteEnemyAnimationLifecycle object (or something like that)\n  protected advanceAnimation(targetIsInRange: boolean): void {\n    if (this.state === CreatureState.Attacking) {\n      const attackInProgress = this.attackTime !== this.maxAttackTime\n      if (attackInProgress) {\n        this.animations[this.state].advanceAnimation()\n      }\n    }\n    if (this.state === CreatureState.AttackingCooldown) {\n      this.animations[this.state].advanceAnimation()\n      if (this.animations[this.state].animationFinished) {\n        if (targetIsInRange === true) {\n          this.setState(CreatureState.Attacking)\n        }\n        else {\n          this.setState(CreatureState.Moving)\n        }\n      }\n    }\n    else if (this.state === CreatureState.Moving) {\n      this.animations[this.state].advanceAnimation()\n    }\n    else if (this.state === CreatureState.Dying) {\n      this.animations[this.state].advanceAnimation()\n      if (this.animations[this.state].animationFinished) {\n        this.setState(CreatureState.Decaying)\n      }\n    }\n    else if (this.state === CreatureState.Decaying) {\n      this.animations[this.state].advanceAnimation()\n      if (this.animations[this.state].animationFinished) {\n        this.setState(CreatureState.Removed)\n      }\n    }\n  }\n\n  // TODO: Move to Enemy\n  private findPathToPlayer(player: Player, thereAreObstaclesBetweenPlayerAndThisEnemy: boolean) {\n    if (thereAreObstaclesBetweenPlayerAndThisEnemy) { // TODO: || this.isStuck()\n      if (this.pathfindingTimer === 0) {\n        this.pathfindingNodes = generatePathNodes( // TODO: Move to Pathfinding or Player\n          Math.round(Math.abs(player.row + this.row) / 2),\n          Math.round(Math.abs(player.col + this.col) / 2),\n          this.collisionBox,\n        )\n        this.shortestPath = findShortestPath(this, player, this.pathfindingNodes)\n      }\n\n      this.pathfindingTimer += GameTime.frameElapsedTime // Game speed independent\n      if (this.pathfindingTimer > this.pathfindingInterval) {\n        this.pathfindingTimer = 0\n      }\n\n      if (this.shortestPath.length > 0) {\n        this.followTheShortestPath()\n      }\n    }\n    else { // Target is in line of sight\n      if (this.pathfindingNodes) {\n        this.pathfindingNodes = null\n      }\n      if (this.shortestPath) {\n        this.shortestPath = []\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private followTheShortestPath(): void {\n    // If the enemy is close to the path node, pop that node and move to the next one\n    let nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n    let nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    if (\n      this.shortestPath.length > 1 &&\n      Math.abs(nextNodeX - this.x) < 3 &&\n      Math.abs(nextNodeY - this.y) < 3\n    ) {\n      this.shortestPath.pop()\n      nextNodeX = this.shortestPath[this.shortestPath.length - 1].x\n      nextNodeY = this.shortestPath[this.shortestPath.length - 1].y\n    }\n    this.moveTowards(nextNodeX, nextNodeY)\n  }\n\n  private moveTowardsPlayer(player: Point): void {\n    if (this.distanceFromTarget > this.collisionBox.width) {\n      this.moveTowards(player.x, player.y)\n    }\n    else {\n      this.resetMoving()\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.resetMoving()\n\n    if (this.x < x) {\n      this.moving.right = true\n      this.movingDirections.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n      this.movingDirections.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n      this.movingDirections.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n      this.movingDirections.up = true\n    }\n  }\n\n  private advanceAttackTimeAndCooldown(): void {\n    if (this.state === CreatureState.Attacking && this.attackTime > 0 && this.attackCooldown === 0) {\n      this.attackTime -= GameTime.frameElapsedTime\n    }\n\n    // Bring down the AttackCooldown...\n    const attackNotInProgress = this.attackTime === this.maxAttackTime\n    if (attackNotInProgress && this.attackCooldown >= 0) {\n      this.attackCooldown -= GameTime.frameElapsedTime\n      if (this.attackCooldown < 0) {\n        this.attackCooldown = 0\n      }\n    }\n  }\n\n  // TODO: Move to Creature since it's shared between enemies and player\n  private debug_drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.2\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo(\n        -0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,\n        -0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight,\n      )\n      context.lineTo(\n         0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,\n        -0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight,\n      )\n      context.lineTo(\n        0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,\n        0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight,\n      )\n      context.lineTo(\n        -0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,\n         0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight,\n      )\n      context.lineTo(\n        -0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,\n        -0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight,\n      )\n    context.stroke()\n  }\n\n  private debug_drawState(player: Player) {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n      context.fillText(\n        this.state.toString(),\n        Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,\n        Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight\n      )\n    context.stroke()\n  }\n\n  private debug_drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n\n  private debug_drawShortestPathToPlayer(p: Player) {\n    this.shortestPath\n      .forEach((n, i) => {\n        drawNode(n, p, n.visited ? '#FF0000' : '#FF00FF')\n      })\n    if (this.shortestPath.length > 0) {\n      this.shortestPath.forEach((node, i) => {\n        this.debug_drawRayFromPointToPoint(node, this.shortestPath[i - 1] || p, p)\n      })\n    }\n  }\n\n  private debug_drawRayFromPointToPoint(p1: Point, p2: Point, player: Player) {\n    context.strokeStyle = '#FF00FF'\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (p2.x - player.x), Canvas.center.y + (p2.y - player.y))\n      context.lineTo(Canvas.center.x + (p1.x - player.x), Canvas.center.y + (p1.y - player.y))\n    context.stroke()\n  }\n}\n","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationAttacking extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Zerg\n\n  protected animationLength   = 420\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 5\n\n  protected oneShotAnimation = true\n}","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationAttackingCooldown extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Zerg\n\n  protected animationLength   = 0\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 0\n}","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationDecaying extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Decay\n\n  protected animationLength   = 10000\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 3\n}","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationDying extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Zerg\n\n  protected animationLength   = 500\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 7\n}","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationIdling extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Zerg\n\n  protected animationLength   = 0\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 0\n}","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationMoving extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Zerg\n\n  protected animationLength   = 330\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 7\n}","import Sprites from '@app/graphics/Sprites'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport AnimationState from '@app/domain/AnimationState'\n\nexport default class ConcreteEnemyAnimationMovingCooldown extends AnimationState {\n  protected sprite: CreatureSprite = Sprites.Zerg\n\n  protected animationLength   = 0\n  protected animationProgress = 0\n\n  protected animationSpritePosition    = 0\n  protected numberOfSpritesInAnimation = 0\n}","import ConcreteEnemyAnimationIdling from './ConcreteEnemyAnimationIdling'\nimport ConcreteEnemyAnimationMoving from './ConcreteEnemyAnimationMoving'\nimport ConcreteEnemyAnimationMovingCooldown from './ConcreteEnemyAnimationMovingCooldown'\nimport ConcreteEnemyAnimationAttacking from './ConcreteEnemyAnimationAttacking'\nimport ConcreteEnemyAnimationAttackingCooldown from './ConcreteEnemyAnimationAttackingCooldown'\nimport ConcreteEnemyAnimationDying from './ConcreteEnemyAnimationDying'\nimport ConcreteEnemyAnimationDecaying from './ConcreteEnemyAnimationDecaying'\n\nexport {\n  ConcreteEnemyAnimationIdling,\n  ConcreteEnemyAnimationMoving,\n  ConcreteEnemyAnimationMovingCooldown,\n  ConcreteEnemyAnimationAttacking,\n  ConcreteEnemyAnimationAttackingCooldown,\n  ConcreteEnemyAnimationDying,\n  ConcreteEnemyAnimationDecaying,\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport { PathNode } from '@app/infrastructure/Pathfinding'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nimport Creature from '@app/domain/Creature'\nimport CreatureState from '@app/domain/CreatureState'\nimport AnimationState from '@app/domain/AnimationState'\nimport AttackEdgeCases from '@app/domain/AttackEdgeCases'\nimport Player from '@app/domain/player/Player'\nimport Map from '@app/domain/map/Map'\nimport DamageNumbers, { DamageNumberFactory } from '@app/domain/widgets/DamageNumbers'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default abstract class Enemy extends Creature {\n  protected stuck: boolean // TODO: Use stuck for something?\n\n  protected distanceFromTarget: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathfindingTimer: number = 0\n  protected pathfindingInterval: number = 500 // ms\n  protected pathfindingNodes: PathNode[]\n  protected shortestPath: PathNode[] = []\n\n  protected sprite: CreatureSprite\n\n  // TODO: Move this to Weapon\n  protected readonly attackSpeed: number // seconds\n  protected attackTime      : number // ms\n  protected maxAttackTime   : number // ms\n  protected attackCooldown    : number // ms\n  protected maxAttackCooldown : number // ms\n\n  protected animations: { [key in CreatureState]?: AnimationState }\n\n  constructor(\n    x: number,\n    y: number,\n    collisionBox: CollisionBox,\n    speed: number,\n    healthPercentage: number,\n  ) {\n    super(x, y, collisionBox, speed, healthPercentage)\n\n    // Widgets\n    this.widgets.damageNumbers = new DamageNumbers()\n  }\n\n  public draw(player: Player): void {\n    this.animations[this.state].draw(this, { x: player.x, y: player.y })\n\n    Object.values(this.widgets).forEach(widget => widget.render(player.x, player.y)) // Render widgets\n\n  }\n\n  public update(player: Player): void {\n    Object.values(this.widgets).forEach(widget => widget.update()) // Update widgets\n  }\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    const offScreenOffset = CONFIG.TILE_SIZE * 2\n    return (\n      Math.abs(this.x - playerX) < CONFIG.CANVAS_WIDTH / 2 + offScreenOffset &&\n      Math.abs(this.y - playerY) < CONFIG.CANVAS_HEIGHT / 2 + offScreenOffset\n    )\n  }\n\n  protected abstract advanceAnimation(targetIsInRange: boolean): void\n\n  protected checkForCollisionWithPlayer(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    this.checkIfBlockedByCreature(player, nextEnemyState)\n  }\n\n  protected checkForCollisionWithOtherEnemies(player: Player): void {\n    const nextEnemyState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesInScreenRangeFromThis = Map.getEnemiesOnScreen(this.x, this.y)\n\n    enemiesInScreenRangeFromThis.forEach((e) => {\n      if (e.state >= CreatureState.Dying) {\n        return\n      }\n      if (this !== e) {\n        this.checkIfBlockedByCreature(e, nextEnemyState)\n      }\n    })\n  }\n\n  protected targetInRange(target: Creature) {\n    const sumOfCollisionBoxHalfDiagonals = (target.collisionBox.halfWidth + this.collisionBox.halfWidth) * Math.sqrt(2)\n    return this.distanceFromTarget < sumOfCollisionBoxHalfDiagonals\n  }\n\n  protected targetInEffectiveRange(target: Creature) {\n    const sumOfCollisionBoxHalfDiagonals = (target.collisionBox.halfWidth + this.collisionBox.halfWidth) * Math.sqrt(2)\n    const outerRangeMultiplier = 4\n    return this.distanceFromTarget < sumOfCollisionBoxHalfDiagonals * outerRangeMultiplier\n  }\n\n  protected checkIfStuck(): boolean {\n    const xIsStatic = this.prevX.every((x) => x === this.prevX[0])\n    const yIsStatic = this.prevY.every((y) => y === this.prevY[0])\n    if (xIsStatic && yIsStatic) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  protected attack(p: Player): void {\n    const targetIsBehindAnObstacle = Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(this, p)\n\n    if (\n      this.targetInEffectiveRange(p) &&\n      targetIsBehindAnObstacle === false // Miss when target goes behind an obstacle!\n    ) {\n      SoundFX.playEnemyAttack()\n      this.dealDamage(p)\n    }\n    else { // Attack is a miss!\n      SoundFX.playEnemyAttackMiss()\n      this.dealDamage(p, AttackEdgeCases.Miss)\n    }\n  }\n\n  protected attackIsMiss(): boolean {\n    return Math.random() >= 0.7\n  }\n\n  protected resetAttackTime() {\n    this.attackTime = this.maxAttackTime\n  }\n  protected resetAttackCooldown() {\n    this.attackCooldown = this.maxAttackCooldown\n  }\n\n  public takeDamage(damageAmount: number): void {\n    this.health -= damageAmount\n\n    this.widgets.damageNumbers.push(DamageNumberFactory.create(this.x, this.y, this.collisionBox, damageAmount))\n\n    if (this.health <= 0) {\n      this.die()\n    }\n    else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.setState(CreatureState.Dying)\n  }\n\n  protected dealDamage(p: Player, attackEdgeCase: AttackEdgeCases = null) {\n    if (attackEdgeCase === AttackEdgeCases.Miss) {\n      p.takeDamage(0, attackEdgeCase)\n    }\n    else {\n      p.takeDamage(this.getDamage())\n    }\n  }\n\n  // TODO: Implement damage range\n  protected getDamage() {\n    return 10\n  }\n\n  public setState(newState: CreatureState) {\n    this.previousState = this.state\n    this.state = newState\n    this.resetAnimations()\n  }\n\n  protected resetAnimations() {\n    Object.values(this.animations).forEach(( a: AnimationState ) => a.resetAnimation())\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Player from '@app/domain/player/Player'\nimport CreatureState from '@app/domain/CreatureState'\nimport ConcreteEnemy from '@app/domain/enemies/ConcreteEnemy/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport MapKeys, { isWall } from '@app/domain/map/MapKeys'\nimport Wall from '@app/domain/objects/wall/Wall'\nimport WallFactory from '@app/domain/objects/wall/WallFactory'\nimport Portal from '@app/domain/objects/portal/Portal'\n\nimport IMap from './IMap'\nimport getMapData from '@app/domain/map/Maps'\nimport Level from '@app/domain/Level'\n\nexport default class Map {\n  public static walls: Wall[][] = []\n  public static enemies: Enemy[] = []\n  public static enemiesDecaying: Enemy[] = []\n  public static exitPortal: Portal\n\n  public player: Player\n\n  public static getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n    return Map.enemies.filter(e => e.isOnScreen(playerX, playerY))\n  }\n\n  public static getDecayingOnScreen(playerX: number, playerY: number): Enemy[] {\n    return Map.enemiesDecaying.filter(e => e.isOnScreen(playerX, playerY))\n  }\n\n  public static enemiesRemaining(): number {\n    return Map.enemies.length\n  }\n\n  public static clear(): void {\n    Map.enemiesDecaying = []\n  }\n\n  constructor() {\n    const mapData = getMapData(Level.currentLevel)\n    this.loadMap(mapData)\n    this.player = new Player(mapData.player.x, mapData.player.y)\n  }\n\n  public destroy() {\n    while (Map.enemies.length) {\n      Map.enemies.pop()\n    }\n  }\n\n  public update(): void {\n    Map.enemies.forEach((e, i) => {\n      if (e.state === CreatureState.Decaying) {\n        // Remove from `enemies` & add to `enemiesDecaying`\n        Map.enemies.splice(i, 1)\n        Map.enemiesDecaying.push(e)\n      }\n      e.update(this.player)\n    })\n\n    Map.enemiesDecaying.forEach((e, i) => {\n      e.update(this.player)\n      if (e.state === CreatureState.Removed) {\n        Map.enemiesDecaying.splice(i, 1)\n      }\n    })\n\n    this.openPortalWhenAllEnemiesAreKilled()\n  }\n\n  private openPortalWhenAllEnemiesAreKilled() {\n    if (\n      Map.exitPortal.isOpen === false &&\n      (\n        Map.enemies.length === 0 ||\n        Map.enemies.every(e => e.state >= CreatureState.Dying)\n      )\n    ) {\n      Map.exitPortal.open()\n    }\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n\n    // First draw decaying enemies\n    Map.getDecayingOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n\n    // Then draw alive enemies on top\n    Map.getEnemiesOnScreen(this.player.x, this.player.y)\n      .filter(e => e.state !== CreatureState.Removed)\n      .forEach(e => {\n        if (e.state === CreatureState.Removed) {\n          return\n        }\n        e.draw(this.player)\n      })\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n\n    // Limits the rendering range to only what is visible on the screen\n    let wall\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (Map.walls[row] && Map.walls[row][col]) {\n          wall = Map.walls[row][col]\n          wall.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          wall.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          wall.draw()\n        }\n        if (Map.exitPortal.row === row && Map.exitPortal.col === col) {\n          Map.exitPortal.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          Map.exitPortal.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          Map.exitPortal.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    this.loadGameObjects(map)\n    this.loadEnemies(map)\n  }\n\n  // Inefficient - provides clearer separation (loading happens once - so it's not a big deal)\n  private loadGameObjects(map: IMap) {\n    this.loadWalls(map)\n    this.loadExitPortal(map)\n  }\n\n  private loadWalls(map: IMap) {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      Map.walls[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        const mapKey = map.gameObjects[row][col] \n        Map.walls[row][col] = null\n        if (isWall(mapKey)) {\n          Map.walls[row][col] = WallFactory.createWall(row, col, mapKey)\n        }\n      }\n    }\n  }\n\n  private loadExitPortal(map: IMap) {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        const mapKey = map.gameObjects[row][col] \n        if (mapKey === MapKeys.ExitPortal) {\n          Map.exitPortal = new Portal(row, col)\n        }\n      }\n    }\n  }\n\n  private loadEnemies(map: IMap) {\n    map.enemies.forEach((e, i) => {\n      Map.enemies.push(new ConcreteEnemy(e.x, e.y, 0.125, e.healthPercentage, i))\n    })\n  }\n}\n","enum MapKeys {\n  Empty      = 0,\n  WallGray   = 1,\n  WallGreen  = 2,\n  WallBlue   = 3,\n  ExitPortal = 9,\n}\n\nexport function isWall(mapKey: MapKeys) {\n  return (\n    mapKey ===  MapKeys.WallGray  ||\n    mapKey ===  MapKeys.WallGreen ||\n    mapKey ===  MapKeys.WallBlue\n  )\n}\n\nexport default MapKeys\n","import IMap from './IMap'\n\nimport * as Map01 from '@app/resources/maps/Map-01.json'\nimport * as Map02 from '@app/resources/maps/Map-02.json'\n\nconst Maps: { [key: string]: IMap } = {\n  Map01,\n  Map02,\n}\n\nexport const totalNumberOfMaps = Object.keys(Maps).length\n\nexport default function getMapData(levelNumber: number): IMap {\n  const zeroPaddedLevelNumber = String(levelNumber).padStart(2, '0')\n  return Maps[`Map${zeroPaddedLevelNumber}`]\n}","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport Game from '@app/infrastructure/game/Game'\nimport GameTime from '@app/infrastructure/GameTime'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\n\nimport PortalObject from './PortalObject'\n\nexport default class Portal extends PortalObject {\n  public isOpen = false\n\n  protected static openColor   = '50, 120, 50'\n  protected static closedColor = '180, 50, 50'\n  protected static opacityBaseline = 0.05\n  protected static opacityRange    = 0.2\n\n  private opacity = Portal.opacityRange\n\n  // Adjust for animation feel\n  private animationElapsed              = 0    // Milliseconds\n  private animationLength               = 4000 // Milliseconds\n  private animationCompletionPercentage = 0.0  // 0.0 - 1.0\n\n  draw(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PLAYING) {\n      this.advanceAnimation()\n    }\n\n    context.fillStyle = this.getColor()\n    context.beginPath()\n      context.rect(\n        this.x,\n        this.y,\n        CONFIG.TILE_SIZE,\n        CONFIG.TILE_SIZE\n      );\n    context.fill()\n  }\n\n  public advanceAnimation() {\n    this.animationElapsed = (this.animationElapsed + GameTime.elapsedTimeFactor) % this.animationLength\n\n    this.animationCompletionPercentage = this.animationElapsed / this.animationLength\n\n    const sineFunction = Math.sin(this.animationCompletionPercentage * (Math.PI * 2)) // returns: -1 to 1 (approximately, because of float arithmetic)\n\n    this.opacity = Portal.opacityBaseline + ((sineFunction + 1) / 2) * Portal.opacityRange\n  }\n\n  public open() {\n    this.isOpen = true\n  }\n\n  private getColor(): string {\n    if (this.isOpen) {\n      return `rgba(${Portal.openColor}, ${this.opacity})`\n    }\n    else {\n      return `rgba(${Portal.closedColor}, ${this.opacity})`\n    }\n  }\n}\n","export default abstract class GameObject {\n  public x: number\n  public y: number\n\n  public isOpen: boolean\n\n  protected static openColor   : string\n  protected static closedColor : string\n\n  constructor(\n    public row: number,\n    public col: number,\n  ) {\n  }\n\n  public abstract draw(): void\n  public abstract open(): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Wall extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw the 'x'\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playWallHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Wall from '@app/domain/objects/wall/Wall'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class WallFactory {\n  public static createWall(row: number, col: number, mapKey: MapKeys): Wall {\n    switch (mapKey) {\n      case MapKeys.WallGray:\n        return new Wall(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.WallGreen:\n        return new Wall(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.WallBlue:\n        return new Wall(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such Wall!')\n    }\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox, {\n  collisionBoxesIntersect,\n} from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport Creature from '@app/domain/Creature'\nimport CreatureState from '@app/domain/CreatureState'\nimport AttackEdgeCases from '@app/domain/AttackEdgeCases'\nimport Map from '@app/domain/map/Map'\n\nimport Crosshair from './Crosshair'\nimport RangedWeapon from './weapons/RangedWeapon'\nimport RifleLine from './weapons/RifleLine'\nimport RifleCircle from './weapons/RifleCircle'\n\nimport DamageNumbers, { DamageNumberColors, DamageNumberFactory } from '@app/domain/widgets/DamageNumbers'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nexport default class Player extends Creature {\n  public alive: boolean = true\n  public rotation: number = 0\n  public sightLineLength = 10\n\n  private AvailableWeapons: { [key: number]: RangedWeapon } = {\n    1: new RifleCircle(),\n    2: new RifleLine(),\n  }\n\n  private equipedWeapon: RangedWeapon = this.AvailableWeapons[1]\n\n  constructor(public x: number, public y: number) {\n    super(x, y, new CollisionBox(12, 12), 0.18, 1)\n\n    // Widgets\n    if (CONFIG.FEATURES.DAMAGE_NUMBERS_ON_PLAYER) {\n      this.widgets.damageNumbers = new DamageNumbers() // TODO: Move to Creature?\n    }\n  }\n\n  public update(): void {\n    this.resetBlocked()\n    this.calculateNextCoordinates()\n\n    this.checkForCollisionWithEnemies()\n    this.move()\n    this.adjustCollisionWithWalls() // Must come after move()\n    this.updateTileDeltas()         // Must come after adjustCollisionWithWalls()\n    this.updateMapPosition()        // Must come after adjustCollisionWithWalls()\n\n    Object.values(this.AvailableWeapons).forEach(w => w.update(this.x, this.y))\n\n    Object.values(this.widgets).forEach(widget => widget.update()) // Update widgets\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRays(theta)\n\n    Crosshair.draw()\n\n    Object.values(this.AvailableWeapons).forEach(w => w.draw(this.x, this.y))\n  }\n\n  private _keydownHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.w:\n        this.moving.up = true\n        this.movingDirections.up = true\n        break\n      case KEYBOARD_KEYS.a:\n        this.moving.left = true\n        this.movingDirections.left = true\n        break\n      case KEYBOARD_KEYS.s:\n        this.moving.down = true\n        this.movingDirections.down = true\n        break\n      case KEYBOARD_KEYS.d:\n        this.moving.right = true\n        this.movingDirections.right = true\n        break\n      case KEYBOARD_KEYS[1]:\n        this.switchWeapons(1)\n        break\n      case KEYBOARD_KEYS[2]:\n        this.switchWeapons(2)\n        break\n    }\n  }\n  public get keydownHandler() {\n    return this._keydownHandler\n  }\n  public set keydownHandler(value) {\n    this._keydownHandler = value\n  }\n  public keyupHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.w:\n        this.moving.up = false\n        break\n      case KEYBOARD_KEYS.a:\n        this.moving.left = false\n        break\n      case KEYBOARD_KEYS.s:\n        this.moving.down = false\n        break\n      case KEYBOARD_KEYS.d:\n        this.moving.right = false\n        break\n      }\n  }\n\n  public takeDamage(damageAmount: number, attackEdgeCase: AttackEdgeCases = null): void {\n    this.health = this.health - damageAmount\n\n    if (this.widgets.damageNumbers) {\n      this.widgets.damageNumbers.push(\n        DamageNumberFactory.create(this.x, this.y, this.collisionBox, damageAmount, DamageNumberColors.gray, attackEdgeCase)\n      )\n    }\n\n    if (this.health <= 0) {\n      this.die()\n    }\n    else {\n      switch (attackEdgeCase) {\n        case null:\n          SoundFX.playPlayerHit()\n          break\n      }\n    }\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n    context.fillStyle = '#00AA00'\n    context.font = '10px Monospace'\n\n    context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n    context.strokeStyle = '#523DA5'\n    context.lineWidth = 2\n    context.moveTo(Canvas.center.x, Canvas.center.y)\n    context.lineTo(\n      Canvas.center.x + this.sightLineLength * Math.cos(theta),\n      Canvas.center.y + this.sightLineLength * Math.sin(theta),\n    )\n    context.stroke()\n\n    if (CONFIG.DEBUG.PLAYER_COLLISION_BOX) {\n      this.debug_drawCollisionBox()\n    }\n\n    Object.values(this.widgets).forEach(widget => widget.render(this.x, this.y)) // Render widgets\n  }\n\n  private drawPlayerVisionRays(theta: number) {\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    if (CONFIG.DEBUG.PLAYER_VISION_RAY_SHOTGUN) {\n      this.drawPlayerVisionRay(theta - 0.45)\n      this.drawPlayerVisionRay(theta - 0.4)\n      this.drawPlayerVisionRay(theta - 0.35)\n      this.drawPlayerVisionRay(theta - 0.3)\n      this.drawPlayerVisionRay(theta - 0.25)\n      this.drawPlayerVisionRay(theta - 0.2)\n      this.drawPlayerVisionRay(theta - 0.15)\n      this.drawPlayerVisionRay(theta - 0.1)\n      this.drawPlayerVisionRay(theta - 0.05)\n      this.drawPlayerVisionRay(theta + 0.05)\n      this.drawPlayerVisionRay(theta + 0.1)\n      this.drawPlayerVisionRay(theta + 0.15)\n      this.drawPlayerVisionRay(theta + 0.2)\n      this.drawPlayerVisionRay(theta + 0.25)\n      this.drawPlayerVisionRay(theta + 0.3)\n      this.drawPlayerVisionRay(theta + 0.35)\n      this.drawPlayerVisionRay(theta + 0.4)\n      this.drawPlayerVisionRay(theta + 0.45)\n    }\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, wallHit } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (wallHit) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private checkForCollisionWithEnemies(): void { // TODO: Extract to Creature?\n    const nextPlayerState = {\n      x: this.nextX,\n      y: this.nextY,\n      collisionBox: this.collisionBox,\n    }\n    const enemiesOnScreen = Map.getEnemiesOnScreen(this.x, this.y)\n\n    if (\n      enemiesOnScreen.some((e) => collisionBoxesIntersect(e, nextPlayerState))\n    ) {\n      enemiesOnScreen.forEach((e) => {\n        if (e.state >= CreatureState.Dying) {\n          return\n        }\n        this.checkIfBlockedByCreature(e, nextPlayerState)\n      })\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    Object.values(this.AvailableWeapons).forEach(w => w.setShooting(false))\n    this.equipedWeapon.setShooting(isShooting)\n  }\n\n  private switchWeapons(weaponIndex: number) {\n    this.equipedWeapon = this.AvailableWeapons[weaponIndex]\n  }\n\n  private die(): void {\n    // TODO: Re-use CreatureState\n    this.alive = false\n\n    SoundFX.playPlayerDeath()\n  }\n\n  private debug_drawCollisionBox() {\n    context.strokeStyle = this.getHealthColor()\n\n    context.lineWidth = 0.5\n    context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // cache the vertex calculations.\n    context.moveTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n       0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      0.5 + Canvas.center.x + this.collisionBox.halfWidth,\n      0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n       0.5 + Canvas.center.y + this.collisionBox.halfHeight,\n    )\n    context.lineTo(\n      -0.5 + Canvas.center.x - this.collisionBox.halfWidth,\n      -0.5 + Canvas.center.y - this.collisionBox.halfHeight,\n    )\n    context.stroke()\n  }\n}\n","export default abstract class Projectile {\n  public speed: number\n  public damage: number\n  public alive: boolean\n  public row: number\n  public col: number\n  protected previousX: number\n  protected previousY: number\n\n  public abstract update(playerX: number, playerY: number): void\n  public abstract draw(playerX: number, playerY: number): void\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Map from '@app/domain/map/Map'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureState from '@app/domain/CreatureState'\n\nimport Projectile from './Projectile'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\n// TODO: Extract as much as possible to the base Projectile class...\n\nexport default class ProjectileCircle extends Projectile {\n  public speed: number = 24\n  public damage: number = 5\n  public alive: boolean = true\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    x: number,\n    y: number,\n    directionX: number,\n    directionY: number,\n  ) {\n    super(x, y, directionX, directionY)\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithWall(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithWall()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      0.7,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...Map.enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | ProjectileCircle): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n\n        if (e.state >= CreatureState.Dying) {\n          return\n        }\n\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithWall(point?: IntermediatePoint | ProjectileCircle): void {\n    if (!point) {\n      point = this\n    }\n\n    const wall = Map.walls[point.row][point.col]\n    if (wall) {\n        wall.takeDamage(this.getDamage())\n        this.alive = false\n        if (wall.destructable) {\n          Map.walls[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Map from '@app/domain/map/Map'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureState from '@app/domain/CreatureState'\n\nimport Projectile from './Projectile'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class ProjectileLine extends Projectile {\n  public speed: number = 24\n  public damage: number = 5\n  public alive: boolean = true\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    x: number,\n    y: number,\n    directionX: number,\n    directionY: number,\n  ) {\n    super(x, y, directionX, directionY)\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithWall(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithWall()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#FFFFF'\n    context.lineWidth = 1\n\n    context.beginPath()\n      context.beginPath()\n        context.moveTo(\n          this.x + Canvas.center.x - playerX,\n          this.y + Canvas.center.y - playerY,\n        )\n        context.lineTo(\n          this.previousX + Canvas.center.x - playerX,\n          this.previousY + Canvas.center.y - playerY,\n        )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...Map.enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | ProjectileLine): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n\n        if (e.state >= CreatureState.Dying) {\n          return\n        }\n\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithWall(point?: IntermediatePoint | ProjectileLine): void {\n    if (!point) {\n      point = this\n    }\n\n    const wall = Map.walls[point.row][point.col]\n    if (wall) {\n        wall.takeDamage(this.getDamage())\n        this.alive = false\n        if (wall.destructable) {\n          Map.walls[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas from \"@app/infrastructure/Canvas\"\nimport GameTime from \"@app/infrastructure/GameTime\"\n\nimport Projectile from \"../projectiles/Projectile\"\n\nimport SoundFX from \"@app/audio/SoundFX\"\n\nexport default abstract class RangedWeapon {\n  // TODO: Adjust for attack feeling\n  protected firingSpeed : number // seconds\n  protected cooldown    : number // ms\n  protected maxCooldown : number // ms\n\n  protected shooting = false\n\n  protected projectileConstructor: new (\n    x: number,\n    y: number,\n    directionX: number,\n    directionY: number,\n  ) => Projectile\n\n  public projectiles: Projectile[] = []\n\n  public update(playerX: number, playerY: number) {\n    this.shoot(playerX, playerY)\n    this.projectiles.forEach((p, i) => {\n      p.update(playerX, playerY)\n      if (p.alive === false) {\n        this.removeProjectile(i)\n      }\n    })\n  }\n\n  public draw(playerX: number, playerY: number): void {\n    this.projectiles.forEach((p) => p.draw(playerX, playerY))\n  }\n\n  public shoot(playerX: number, playerY: number): void {\n    if (this.cooldown >= 0) {\n      this.cooldown -= GameTime.frameElapsedTime\n      if (this.cooldown < 0) {\n        this.cooldown = 0\n      }\n    }\n\n    if (this.shooting === false) {\n      return\n    }\n\n    if (this.cooldown <= 0) {\n\n      this.fireProjectile(playerX, playerY)\n      this.resetAttackCooldown()\n\n      SoundFX.playSMG()\n    }\n  }\n\n  public fireProjectile(playerX: number, playerY: number): void {\n    const dx = Canvas.mousePosition.x - Canvas.center.x\n    const dy = Canvas.mousePosition.y - Canvas.center.y\n    let xVel = dx / (Math.abs(dx) + Math.abs(dy))\n    let yVel = dy / (Math.abs(dx) + Math.abs(dy))\n\n    // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n    // TODO: Fix the problem with different bullet speeds caused by randomness\n    if (CONFIG.FEATURES.SCATTER_PROJECTILES) {\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n    }\n\n    this.projectiles.push(new this.projectileConstructor(playerX, playerY, xVel, yVel))\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  protected removeProjectile(projectileIndex: number) {\n    this.projectiles.splice(projectileIndex, 1) // Remove the projectile\n  }\n\n  protected resetAttackCooldown() {\n    this.cooldown = this.maxCooldown\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport ProjectileCircle from '@app/domain/player/projectiles/ProjectileCircle'\n\nimport RangedWeapon from './RangedWeapon'\n\nexport default class RifleLine extends RangedWeapon {\n  // TODO: Adjust for attack feeling\n  protected firingSpeed = 0.1 // seconds\n  protected cooldown    = 0   // ms\n  protected maxCooldown = (1000 * this.firingSpeed) / CONFIG.GAME_SPEED\n\n  protected projectileConstructor = ProjectileCircle\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport ProjectileLine from '@app/domain/player/projectiles/ProjectileLine'\n\nimport RangedWeapon from './RangedWeapon'\n\nexport default class RifleLine extends RangedWeapon {\n  // TODO: Adjust for attack feeling\n  protected firingSpeed = 0.05 // seconds\n  protected cooldown    = 0    // ms\n  protected maxCooldown = (1000 * this.firingSpeed) / CONFIG.GAME_SPEED\n\n  protected projectileConstructor = ProjectileLine\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Game from \"@app/infrastructure/game/Game\"\nimport GameTime from '@app/infrastructure/GameTime'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport GAME_STATES from \"@app/infrastructure/game/game_states/GameStates\"\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport AttackEdgeCases from '@app/domain/AttackEdgeCases'\nexport interface IWidget {\n  update(): void\n  render(playerX: number, playerY: number): void\n}\n\nexport enum DamageNumberColors {\n  red    = '220, 50, 50',\n  yellow = '180, 180, 50',\n  gray   = '180, 180, 180',\n}\n\nexport class DamageNumberFactory {\n  public static create(\n    x: number,\n    y: number,\n    collisionBox: CollisionBox,\n    damage: number,\n    color: DamageNumberColors = DamageNumberColors.red,\n    attackEdgeCase: AttackEdgeCases = null,\n  ): DamageNumber {\n    return new DamageNumber(\n      x,\n      y - collisionBox.halfHeight * 0.9,\n      (Math.random() * collisionBox.height)       - collisionBox.halfHeight,\n      (Math.random() * collisionBox.width  / 1.5) - collisionBox.halfWidth / 1.5,\n      attackEdgeCase ? attackEdgeCase : damage.toString(),\n      color\n    )\n  }\n}\n\nexport class DamageNumber {\n  constructor(\n    public x: number,\n    public y: number,\n    protected randomFactorX: number,\n    protected randomFactorY: number,\n    private damage: string,\n    private color: string\n  ) {\n    this.damageTextHalfWidth = (this.damage.length * this.fontWidth) / 2\n  }\n\n  public animationFinished = false\n\n  // Adjust for animation feel\n  private animationElapsed              = 0   // Milliseconds\n  private animationLength               = 800 // Milliseconds\n  private animationCompletionPercentage = 0.0 // 0.0 - 1.0\n  private maxHeight                     = 30  // px\n\n  public advanceAnimation() {\n    this.animationElapsed += GameTime.elapsedTimeFactor\n    this.animationCompletionPercentage = this.animationElapsed / this.animationLength\n    if (this.animationHasFinished()) {\n      this.animationFinished = true\n    }\n  }\n  public animationHasFinished() {\n    return (this.animationElapsed >= this.animationLength)\n  }\n\n  private fontSize = 8\n  private font = `${this.fontSize}px Monospace`\n  private fontWidth = this.fontSize / 2\n  private damageTextHalfWidth: number = 0\n\n  public draw(playerX: number, playerY: number) {\n    context.beginPath()\n      const opacity = 1 - this.animationCompletionPercentage\n      context.fillStyle = `rgba(${this.color}, ${opacity})`\n      context.font = this.font\n      context.fillText(\n        `${this.damage}`,\n        this.randomFactorX + (this.x + Canvas.center.x - playerX) - this.damageTextHalfWidth,\n        this.randomFactorY + (this.y + Canvas.center.y - playerY) - (this.animationCompletionPercentage * this.maxHeight),\n      )\n    context.stroke()\n  }\n}\n\nexport default class DamageNumbers implements IWidget {\n\n  private damageNumbers: DamageNumber[] = []\n\n  public update(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PLAYING) {\n      this.damageNumbers.forEach((dmgNum, i) => {\n        dmgNum.advanceAnimation()\n\n        if (dmgNum.animationFinished === true) {\n          this.damageNumbers.splice(i, 1) // Remove the DamageNumber\n        }\n      })\n    }\n  }\n\n  public render(playerX: number, playerY: number): void {\n    if (CONFIG.FEATURES.DAMAGE_NUMBERS_SHOW) {\n      this.feature_drawDamageNumbers(playerX, playerY)\n    }\n  }\n\n  public push(damageNumber: DamageNumber): void {\n    this.damageNumbers.push(damageNumber)\n  }\n\n\n  public feature_drawDamageNumbers(playerX: number, playerY: number) {\n    this.damageNumbers.forEach(dmgNumber => dmgNumber.draw(playerX, playerY))\n  }\n}\n\nexport type Widget = IWidget & DamageNumbers","import Sprites from './Sprites'\n\nexport default class GraphicsLoader {\n  public static async load(setLoadedPercentage: (percentage: number) => void) {\n    Sprites.load(setLoadedPercentage)\n  }\n}","import CreatureSprite from './sprites/CreatureSprite'\nimport ZergSprite from './sprites/ZergSprite'\nimport DecaySprite from './sprites/DecaySprite'\n\nexport default class Sprites {\n  public static Zerg : CreatureSprite = new ZergSprite()\n  public static Decay: CreatureSprite = new DecaySprite()\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    await Sprites.Decay.load(() => setLoadedPercentage(0.5))\n    await Sprites.Zerg.load(() => setLoadedPercentage(1.0))\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport Creature from '@app/domain/Creature'\n\nexport default abstract class CreatureSprite {\n  public spriteSheet: HTMLImageElement\n\n  protected abstract url: string\n  public abstract draw(c: Creature, playerCoordinates: Point, animationSpritePosition?: number): void\n\n  public load(callback: () => void): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      this.spriteSheet = new Image()\n      this.spriteSheet.src = this.url\n      this.spriteSheet.onload = () => {\n        callback()\n        resolve()\n      }\n    })\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport CreatureState from '@app/domain/CreatureState'\n\nimport CreatureSprite from './CreatureSprite'\nimport Creature from '@app/domain/Creature'\n\nexport default class DecaySprite extends CreatureSprite {\n  public url: string = './graphics/spritesheets/decay.png'\n\n\n  private spriteProperties = {\n    decay: {\n      width: 56,\n      height: 56,\n      gapX: 3,\n      gapY: 3,\n    }\n  }\n\n  private manuallyCalculatedSprites = {\n    decay: [\n      {\n        sy: 2 * (this.spriteProperties.decay.height + this.spriteProperties.decay.gapY) + 2,\n      },\n      {\n        sy: 1 * (this.spriteProperties.decay.height + this.spriteProperties.decay.gapY) + 2,\n      },\n      {\n        sy: 0 * (this.spriteProperties.decay.height + this.spriteProperties.decay.gapY) + 2,\n      },\n    ]\n  }\n\n  constructor() {\n    super()\n  }\n\n  public draw(creature: Creature, playerCoordinates: Point, animationSpritePosition: number) {\n    this.drawSpritedecay(creature, playerCoordinates, animationSpritePosition)\n  }\n\n  private drawSpritedecay(\n    creature: Creature,\n    playerCoordinates: Point,\n    animationSpritePosition: number\n  ) {\n\n    const { x, y } = creature\n    const { x: px, y: py } = playerCoordinates\n\n    const desinationWidth  = Math.floor(this.spriteProperties.decay.width  * (creature.collisionBox.width  / 15))\n    const desinationHeight = Math.floor(this.spriteProperties.decay.height * (creature.collisionBox.height / 20))\n\n    const totalColumnsInSprite = 4\n    const randomSxColumn = (creature.x + creature.y) % totalColumnsInSprite\n    const randomSx = 2 + (randomSxColumn * (this.spriteProperties.decay.width + this.spriteProperties.decay.gapX))\n\n    context.drawImage(\n      this.spriteSheet,\n      randomSx,\n      this.manuallyCalculatedSprites.decay[animationSpritePosition].sy,\n      this.spriteProperties.decay.width,  // Draw width\n      this.spriteProperties.decay.height, // Draw height\n      Canvas.center.x + (x - px - desinationWidth  / 2), // Canvas Desination X\n      Canvas.center.y + (y - py - desinationHeight / 2), // Canvas Desination Y\n      desinationWidth,\n      desinationHeight,\n    )\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport CreatureState from '@app/domain/CreatureState'\n\nimport CreatureSprite from './CreatureSprite'\nimport Creature from '@app/domain/Creature'\n\nexport default class ZergSprite extends CreatureSprite {\n  public url: string = './graphics/spritesheets/zergling.png'\n\n  private spriteLocations: { [key: string]: { col: number, flip: boolean } } = {\n    N : { col: 0, flip: false },\n    NE: { col: 2, flip: false },\n    E : { col: 4, flip: false },\n    SE: { col: 6, flip: false },\n    S : { col: 8, flip: false },\n    SW: { col: 6, flip: true  },\n    W : { col: 4, flip: true  },\n    NW: { col: 2, flip: true  },\n  }\n\n  private spriteProperties = {\n    default: {\n      width: 32,\n      height: 32,\n    },\n    dying: {\n      width: 65,\n      height: 53,\n      gapX: 3,\n      sy: 548,\n    }\n  }\n\n  private manuallyCalculatedSprites = {\n    dying: [\n      {\n        sx: 0 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n      {\n        sx: 1 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n      {\n        sx: 2 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n      {\n        sx: 3 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n      {\n        sx: 4 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n      {\n        sx: 5 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n      {\n        sx: 6 * (this.spriteProperties.dying.width + this.spriteProperties.dying.gapX) + 2,\n        sy: this.spriteProperties.dying.sy,\n      },\n    ]\n  }\n\n  constructor() {\n    super()\n  }\n\n  public draw(creature: Creature, playerCoordinates: Point, animationSpritePosition: number) {\n    if (creature.state === CreatureState.Dying) {\n      this.drawSpriteDying(creature, playerCoordinates, animationSpritePosition)\n    }\n    else {\n      const spriteWidth  = this.spriteProperties.default.width\n      const spriteHeight = this.spriteProperties.default.height\n      const spriteStep: Point = { x: spriteWidth + 11, y: spriteHeight + 10 }\n      const spriteOffsets: Point = this.getSpriteOffsets(creature.state, spriteStep)\n      const spriteLocation = this.spriteLocations[creature.direction]\n      this.drawSprite(creature, playerCoordinates, spriteOffsets, spriteStep, spriteLocation, spriteWidth, spriteHeight, animationSpritePosition)\n    }\n  }\n\n  private getSpriteOffsets(creatureState: CreatureState, spriteStep: Point) {\n    const defaultSpriteOffset = {\n      x: 7,\n      y: 5\n    }\n    switch (creatureState) {\n      case CreatureState.Idling:\n      case CreatureState.Moving:\n      case CreatureState.MovingCooldown:\n      case CreatureState.AttackingCooldown:\n        return defaultSpriteOffset\n      case CreatureState.Attacking:\n        const ATTACK_SPRITES_ROW = 7\n        return {\n          x: defaultSpriteOffset.x,\n          y: defaultSpriteOffset.y + (ATTACK_SPRITES_ROW * spriteStep.y)\n        }\n    }\n  }\n\n  private drawSpriteDying(\n    creature: Creature,\n    playerCoordinates: Point,\n    animationSpritePosition: number\n  ) {\n\n    const { x, y } = creature\n    const { x: px, y: py } = playerCoordinates\n\n    const desinationWidth  = Math.floor(this.spriteProperties.dying.width  * (creature.collisionBox.width  / 20))\n    const desinationHeight = Math.floor(this.spriteProperties.dying.height * (creature.collisionBox.height / 20))\n\n    context.drawImage(\n      this.spriteSheet,\n      this.manuallyCalculatedSprites.dying[animationSpritePosition].sx,\n      this.manuallyCalculatedSprites.dying[animationSpritePosition].sy,\n      this.spriteProperties.dying.width,  // Draw width\n      this.spriteProperties.dying.height, // Draw height\n      Canvas.center.x + (x - px - desinationWidth  / 2), // Canvas Desination X\n      Canvas.center.y + (y - py - desinationHeight / 2), // Canvas Desination Y\n      desinationWidth,\n      desinationHeight,\n    )\n  }\n\n  private drawSprite(\n    creature: Creature,\n    playerCoordinates: Point,\n    spriteOffsets: Point,\n    spriteStep: Point,\n    spriteLocation: { col: number, flip: boolean },\n    spriteWidth: number,\n    spriteHeight: number,\n    animationSpritePosition: number,\n  ) {\n\n    const { x, y, collisionBox: cBox } = creature\n    const { x: px, y: py } = playerCoordinates\n\n    if (spriteLocation.flip) {\n      context.save()\n      context.translate(\n        Canvas.center.x + (x - px - cBox.halfWidth),\n        Canvas.center.y + (y - py - cBox.halfHeight),\n      )\n      context.scale(-1, 1)\n    }\n\n    const desinationWidth  = creature.collisionBox.width  + 2\n    const desinationHeight = creature.collisionBox.height + 2\n\n    context.drawImage(\n      this.spriteSheet,\n      spriteOffsets.x + spriteStep.x * spriteLocation.col,\n      spriteOffsets.y + spriteStep.y * Math.floor(animationSpritePosition),\n      spriteWidth,\n      spriteHeight,\n      spriteLocation.flip ? 0 - spriteWidth / 2 : Canvas.center.x + (x - px - cBox.halfWidth),  // Canvas Desination X\n      spriteLocation.flip ? 0                   : Canvas.center.y + (y - py - cBox.halfHeight), // Canvas Desination Y\n      desinationWidth,\n      desinationHeight,\n    )\n\n    if (spriteLocation.flip) {\n      context.restore()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\ncontext.imageSmoothingEnabled = false // Disables anti-aliasing on Chrome\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    // TODO: Just a development warning, remove this in production\n    if (CONFIG.THROW_DEVELOPMENT_ERRORS) {\n      if (width % 2 !== 0 || height % 2 !== 0) {\n        throw new Error('Always use even numbers for collision box dimensions!')\n      }\n    }\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n\nexport interface ICollidable {\n  x: number\n  y: number\n  collisionBox: CollisionBox\n}\n\nexport function collisionBoxesIntersect(a: ICollidable, b: ICollidable): boolean {\n  return (\n    a.x - a.collisionBox.halfWidth  < b.x + b.collisionBox.halfWidth  &&\n    a.x + a.collisionBox.halfWidth  > b.x - b.collisionBox.halfWidth  &&\n    a.y - a.collisionBox.halfHeight < b.y + b.collisionBox.halfHeight &&\n    a.y + a.collisionBox.halfHeight > b.y - b.collisionBox.halfHeight\n  )\n}","import { Pi2Decimals, radiansToDegrees } from '@app/infrastructure/math/MathUtils'\n\nexport enum Directions {\n  N  = 'N',\n  NE = 'NE',\n  E  = 'E',\n  SE = 'SE',\n  S  = 'S',\n  SW = 'SW',\n  W  = 'W',\n  NW = 'NW',\n}\n\nexport enum MovingDirections {\n  up    = 'up',\n  right = 'right',\n  down  = 'down',\n  left  = 'left',\n}\n\nconst directionsAngleRangesLUT: { [key in Directions]: { min: number, max: number }} = {\n  [Directions.E ]: { min: 337, max: 22,  }, // min & max are degrees\n  [Directions.SE]: { min: 22,  max: 67,  },\n  [Directions.S ]: { min: 67,  max: 112, },\n  [Directions.SW]: { min: 112, max: 157, },\n  [Directions.W ]: { min: 157, max: 202, },\n  [Directions.NW]: { min: 202, max: 247, },\n  [Directions.N ]: { min: 247, max: 292, },\n  [Directions.NE]: { min: 292, max: 337, },\n}\n\n/*\n * Angles:\n *            N\n *            |\n *           270\n *   W - 180     0 - E\n *           90\n *            |\n *            S\n*/\nexport function getDirectionBasedOnAngle(theta: number): Directions {\n  if (theta < 0) {\n    theta = 2 * Math.PI - Math.abs(theta)\n  }\n  theta = radiansToDegrees(theta)\n\n  if (\n    theta >= 0 && theta < directionsAngleRangesLUT[Directions.E].max ||\n    theta >= directionsAngleRangesLUT[Directions.E].min && theta < 360 // deg\n  ) {\n    return Directions.E\n  }\n\n  const [ direction ] = Object.entries(directionsAngleRangesLUT).find(([direction, angleRange]) => {\n    return (theta >= angleRange.min && theta < angleRange.max)\n  })\n  return Directions[direction as Directions]\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\n\nexport default class FrameRate {\n\n  public static restart() {\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(lastFrameTime: number, frameElapsedTime: number): void {\n    if (!lastFrameTime) {\n      FPS = 0\n    } else {\n      FPS_ARR.unshift(1000 / frameElapsedTime)\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n    }\n  }\n\n  public static debug_drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","\nenum GameAssets {\n  Graphics,\n  Audio,\n}\n\nexport default GameAssets","import * as CONFIG from '@app/configuration/config.json'\n\nexport default class GameTime {\n  public static readonly ONE_SECOND = 1000\n\n  public static previousTimestamp = 0 // Milliseconds\n  public static frameElapsedTime  = 0 // Milliseconds\n\n  // Determines the game & animation speed\n  public static elapsedTimeFactor: number\n\n  public static setFrameElapsedTime(t: number) {\n    GameTime.frameElapsedTime  = t\n    GameTime.elapsedTimeFactor = CONFIG.GAME_SPEED * GameTime.frameElapsedTime\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport RaycastablePoint from './geometry/RaycastablePoint'\n\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): PathNode[] {\n  const path: PathNode[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!Map.walls[row] || !Map.walls[row][col]) {\n        if (col > 0 && row > 0) {\n          path.push(new PathNode({\n            x: col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n            y: row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,\n          }, cBox))\n        }\n      }\n    }\n  }\n\n  return path\n}\n\nexport function debug_drawPathNodes(path: PathNode[], player: Player, color: string): void {\n  if (path) {\n    path.forEach(node => drawNode(node, player, color))\n  }\n}\n\nexport function drawNode(node: PathNode, player: Player, color: string): void {\n  context.strokeStyle = color\n  context.lineWidth = 0.1\n  context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // optimize/cache the vertex calculations.\n    context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + node.collisionBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - node.collisionBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - node.collisionBox.halfHeight)\n  context.stroke()\n\n  context.beginPath()\n    context.arc(\n      Canvas.center.x + (node.x - player.x),\n      Canvas.center.y + (node.y - player.y),\n      1,\n      0,\n      (2 * Math.PI)\n    )\n  context.stroke()\n}\n\nexport function findShortestPath(enemy: Enemy, player: Player, pathfindingNodes: PathNode[]): PathNode[] {\n  const nodeGoal  = new PathNode(player, player.collisionBox)\n  const nodeStart = new PathNode(enemy,  enemy.collisionBox)\n\n  pathfindingNodes.push(nodeGoal)\n\n  nodeStart.f = 0\n  nodeStart.g = nodeStart.heuristic(nodeGoal)\n\n  const nodesNotTested: PathNode[] = [ nodeStart ]\n\n  let nodeCurrent: PathNode\n\n  while (nodesNotTested.length > 0 || nodeCurrent === nodeGoal) {\n    nodesNotTested.sort((a: PathNode, b: PathNode) => a.g - b.g)\n\n    while (nodesNotTested.length > 0 && nodesNotTested[0].visited === true) {\n      nodesNotTested.shift()\n    }\n\n    if (nodesNotTested.length <= 0) {\n      break\n    }\n\n    nodeCurrent = nodesNotTested.shift()\n    nodeCurrent.visited = true\n\n    // Get neighbour nodes.\n    nodeCurrent.neighbourNodes = [ ...pathfindingNodes ]\n      .filter(node => {\n        return (\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row    ) || // Center\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row - 1) || // N\n          (node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row    ) || // E\n          (node.col === nodeCurrent.col     && node.row === nodeCurrent.row + 1) || // S\n          (node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row    ) || // W\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row - 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col + 1] === null ||\n              !Map.walls[node.row + 1] || Map.walls[node.row + 1][node.col    ] === null\n            )\n          ) || // NW\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row - 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col - 1] === null ||\n              !Map.walls[node.row + 1] || Map.walls[node.row + 1][node.col    ] === null\n            )\n          ) || // NE\n          (\n            node.col === nodeCurrent.col + 1 && node.row === nodeCurrent.row + 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col - 1] === null ||\n              !Map.walls[node.row - 1] || Map.walls[node.row - 1][node.col    ] === null\n            )\n          ) || // SE\n          (\n            node.col === nodeCurrent.col - 1 && node.row === nodeCurrent.row + 1\n            && (\n              !Map.walls[node.row    ] || Map.walls[node.row    ][node.col + 1] === null ||\n              !Map.walls[node.row - 1] || Map.walls[node.row - 1][node.col    ] === null\n            )\n          ) // SW\n        )\n      })\n\n    nodeCurrent.neighbourNodes\n      .map(node => {\n        if (node.visited === false) {\n          nodesNotTested.push(node)\n        }\n\n        // Calculate local goal\n        const possiblyLowerLocalGoal = nodeCurrent.f + pointToPointDistance(nodeCurrent, node)\n\n        if (possiblyLowerLocalGoal < node.f) {\n          node.parent = nodeCurrent\n          node.f = possiblyLowerLocalGoal\n          node.g = node.f + node.heuristic(nodeGoal)\n        }\n\n        return node\n      })\n  }\n\n  const path = []\n  if (nodeGoal.parent) {\n    let n: PathNode = nodeGoal\n    while (n.parent) {\n      path.push(n)\n      n = n.parent\n    }\n  }\n  return path\n}\n\nexport class PathNode implements RaycastablePoint {\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  public collisionBox: CollisionBox\n\n  public visited: boolean = false\n  public g: number = Infinity // Global goal\n  public f: number = Infinity // Local goal\n  public parent: PathNode = null\n  public neighbourNodes: PathNode[]\n\n  constructor(coordinates: Point, cBox: CollisionBox) {\n    this.x = coordinates.x\n    this.y = coordinates.y\n    this.collisionBox = new CollisionBox(cBox.width, cBox.height)\n    this.updateTileDeltas()\n    this.updateMapPosition()\n  }\n\n  public heuristic(nodeGoal: PathNode): number {\n    return pointToPointDistance(this, nodeGoal)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\nimport Wall from '@app/domain/objects/wall/Wall'\nimport Map from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport RaycastablePoint from './geometry/RaycastablePoint'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { PathNode } from './Pathfinding'\nimport Player from '@app/domain/player/Player'\nimport { Pi2Decimals } from './math/MathUtils'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   wallHit, // the wall that has been hit. If no walls are hit - wallHit is `null`\n   *   hitPoint // can be either a point where the ray intersects a wall, or a just a point outside the screen if no wall is hit\n   * }\n   */\n  public static cast(\n    p: RaycastablePoint,\n    theta: number,\n    pEnd?: RaycastablePoint\n  ): { hitPoint: Point, wallHit: Wall } {\n    if (theta >= 0) { // South\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta, pEnd)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta, pEnd)\n      }\n    } else { // North\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta, pEnd)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta, pEnd)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  public static determineIfThereAreObstaclesBetweenTwoPoints(p1: RaycastablePoint, p2: RaycastablePoint): boolean {\n    const angleBetweenTwoGivenPoints = angleBetweenPoints(p2, p1)\n    const results = Raycaster.cast(p1, angleBetweenTwoGivenPoints, p2)\n\n    // I have to check if results exist because sometimes .cast() can return 'undefined'..\n    // Why .cast() sometimes returns 'undefined' could be worth investigating in the future..\n    if (results) {\n      return results.wallHit !== null\n    }\n    else {\n      return true\n    }\n  }\n\n  // This function is very computationaly expensive, see if it can be optimized\n  public static determineIfThereAreObstaclesBetweenTwoPathNodes(n1: PathNode | Enemy, n2: PathNode | Player) {\n    const angleBetweenNodes: number = +angleBetweenPoints(n2, n1).toFixed(2)\n\n    if (angleBetweenNodes === 0) { // 0deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > 0 && angleBetweenNodes < Pi2Decimals / 2) { // between 0deg and 90deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === (Pi2Decimals / 2)) { // 90deg\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > Pi2Decimals / 2 && angleBetweenNodes < Pi2Decimals) { // between 90deg and 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (Math.abs(angleBetweenNodes) === Pi2Decimals) { // 180deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Pi2Decimals && angleBetweenNodes < -Pi2Decimals / 2) { // between 180deg and 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSW1, vSW2] = getVerticesSW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSW1 as RaycastablePoint, vSW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes === -Pi2Decimals / 2) { // 270deg\n      const [vNE1, vNE2] = getVerticesNE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNE1 as RaycastablePoint, vNE2 as RaycastablePoint)) {\n        return true\n      }\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n\n    else if (angleBetweenNodes > -Pi2Decimals / 2 && angleBetweenNodes < 0) { // between 270deg and 360deg\n      const [vNW1, vNW2] = getVerticesNW(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vNW1 as RaycastablePoint, vNW2 as RaycastablePoint)) {\n        return true\n      }\n      const [vSE1, vSE2] = getVerticesSE(n1, n2)\n      if (Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(vSE1 as RaycastablePoint, vSE2 as RaycastablePoint)) {\n        return true\n      }\n      return false\n    }\n  }\n\n  private static outsideOfScreenOffset = CONFIG.TILE_SIZE * 2\n  private static rangeHorizontal: number = Canvas.halfWidth  + Raycaster.outsideOfScreenOffset\n  private static rangeVertical: number   = Canvas.halfHeight + Raycaster.outsideOfScreenOffset * 2\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalSE(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyBottom > (pEnd.y - p.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalSE(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        wallHit : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        wallHit : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: RaycastablePoint, theta: number, pEnd?: RaycastablePoint): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalNE(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y - tileStepY - p.deltas.dyTop,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalNE(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        wallHit : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        wallHit : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalNW(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (p.x - pEnd.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - xIntercept,\n            y: Canvas.center.y - p.deltas.dyTop - tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalNW(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        wallHit : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        wallHit : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, wallHit: Wall } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let wallHitVertical: Wall = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      wallHitVertical = Raycaster.checkWallCollisionVerticalSW(i, p, yIntercept)\n\n      if (wallHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let wallHitHorizontal: Wall = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (-xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if ((tileStepY + p.deltas.dyBottom > (pEnd.y - p.y)) || (-xIntercept > (p.x - pEnd.x))) {\n          break\n        }\n      }\n\n      if (CONFIG.DEBUG.RAYCASTER) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      wallHitHorizontal = Raycaster.checkWallCollisionHorizontalSW(j, p, xIntercept)\n\n      if (wallHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit wall\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint : hitPointVertical,\n        wallHit  : wallHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint : hitPointHorizontal,\n        wallHit  : wallHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint : hitPointHorizontal,\n          wallHit  : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint : hitPointVertical,\n          wallHit  : wallHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          wallHit : wallHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          wallHit : wallHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkWallCollisionVerticalSE(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile]) {\n      if (Map.walls[yTile][xTile]) {\n        wallHit = Map.walls[yTile][xTile]\n      }\n      else if (Map.walls[yTile_aboveByOnePixel][xTile]) {\n        wallHit = Map.walls[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalSE(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n\n  private static checkWallCollisionVerticalNE(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalNE(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const xTile_leftByOnePixel = p.col + Math.floor((p.deltas.dxLeft + xIntercept - 1) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let wallHit = null\n    if (Map.walls[yTile]) {\n      if (Map.walls[yTile][xTile]) {\n        wallHit = Map.walls[yTile][xTile]\n      }\n      else if (Map.walls[yTile][xTile_leftByOnePixel]) {\n        wallHit = Map.walls[yTile][xTile_leftByOnePixel]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n\n  private static checkWallCollisionVerticalNW(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalNW(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n\n  private static checkWallCollisionVerticalSW(i: number, p: Point, yIntercept: number): Wall {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let wallHit = null\n    if (Map.walls[yTile]) {\n      if (Map.walls[yTile][xTile]) {\n        wallHit = Map.walls[yTile][xTile]\n      }\n      else if (Map.walls[yTile_aboveByOnePixel][xTile]) {\n        wallHit = Map.walls[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return wallHit\n  }\n  private static checkWallCollisionHorizontalSW(i: number, p: Point, xIntercept: number): Wall {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let wallHit = null\n    if (Map.walls[yTile] && Map.walls[yTile][xTile]) {\n      wallHit = Map.walls[yTile][xTile]\n    }\n\n    if (CONFIG.DEBUG.RAYCASTER) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${wallHit ? [wallHit.row, wallHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return wallHit\n  }\n}\n\nconst blankVertex: Point = {\n  x: 0,\n  y: 0,\n  deltas: {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  },\n}\nconst vertexNW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexNE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSW2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE1: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\nconst vertexSE2: Point = { ...blankVertex, deltas: { ...blankVertex.deltas } }\n\nfunction getVerticesNW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexNW1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNW1.row = Math.floor(vertexNW1.y / CONFIG.TILE_SIZE)\n  vertexNW1.col = Math.floor(vertexNW1.x / CONFIG.TILE_SIZE)\n  vertexNW1.deltas.dyTop = vertexNW1.y % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW1.deltas.dyTop\n  vertexNW1.deltas.dxLeft = vertexNW1.x % CONFIG.TILE_SIZE\n  vertexNW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW1.deltas.dxLeft\n\n  vertexNW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexNW2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNW2.row = Math.floor(vertexNW2.y / CONFIG.TILE_SIZE)\n  vertexNW2.col = Math.floor(vertexNW2.x / CONFIG.TILE_SIZE)\n  vertexNW2.deltas.dyTop = vertexNW2.y % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNW2.deltas.dyTop\n  vertexNW2.deltas.dxLeft = vertexNW2.x % CONFIG.TILE_SIZE\n  vertexNW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNW2.deltas.dxLeft\n\n  return [ vertexNW1, vertexNW2 ]\n}\n\nfunction getVerticesNE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexNE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexNE1.y = n1.y - n1.collisionBox.halfHeight\n  vertexNE1.row = Math.floor(vertexNE1.y / CONFIG.TILE_SIZE)\n  vertexNE1.col = Math.floor(vertexNE1.x / CONFIG.TILE_SIZE)\n  vertexNE1.deltas.dyTop = vertexNE1.y % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE1.deltas.dyTop\n  vertexNE1.deltas.dxLeft = vertexNE1.x % CONFIG.TILE_SIZE\n  vertexNE1.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE1.deltas.dxLeft\n\n  vertexNE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexNE2.y = n2.y - n2.collisionBox.halfHeight\n  vertexNE2.row = Math.floor(vertexNE2.y / CONFIG.TILE_SIZE)\n  vertexNE2.col = Math.floor(vertexNE2.x / CONFIG.TILE_SIZE)\n  vertexNE2.deltas.dyTop = vertexNE2.y % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexNE2.deltas.dyTop\n  vertexNE2.deltas.dxLeft = vertexNE2.x % CONFIG.TILE_SIZE\n  vertexNE2.deltas.dxRight = CONFIG.TILE_SIZE - vertexNE2.deltas.dxLeft\n\n  return [ vertexNE1, vertexNE2 ]\n}\n\nfunction getVerticesSW(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSW1.x = n1.x - n1.collisionBox.halfWidth\n  vertexSW1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSW1.row = Math.floor(vertexSW1.y / CONFIG.TILE_SIZE)\n  vertexSW1.col = Math.floor(vertexSW1.x / CONFIG.TILE_SIZE)\n  vertexSW1.deltas.dyTop = vertexSW1.y % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW1.deltas.dyTop\n  vertexSW1.deltas.dxLeft = vertexSW1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW1.deltas.dxLeft\n\n  vertexSW2.x = n2.x - n2.collisionBox.halfWidth\n  vertexSW2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSW2.row = Math.floor(vertexSW2.y / CONFIG.TILE_SIZE)\n  vertexSW2.col = Math.floor(vertexSW2.x / CONFIG.TILE_SIZE)\n  vertexSW2.deltas.dyTop = vertexSW2.y % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSW2.deltas.dyTop\n  vertexSW2.deltas.dxLeft = vertexSW2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSW2.deltas.dxLeft\n\n  return [ vertexSW1, vertexSW2 ]\n}\n\nfunction getVerticesSE(n1: PathNode | Enemy, n2: PathNode | Player): [ Point, Point ] {\n  vertexSE1.x = n1.x + n1.collisionBox.halfWidth\n  vertexSE1.y = n1.y + n1.collisionBox.halfHeight\n  vertexSE1.row = Math.floor(vertexSE1.y / CONFIG.TILE_SIZE)\n  vertexSE1.col = Math.floor(vertexSE1.x / CONFIG.TILE_SIZE)\n  vertexSE1.deltas.dyTop = vertexSE1.y % CONFIG.TILE_SIZE\n  vertexSE1.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE1.deltas.dyTop\n  vertexSE1.deltas.dxLeft = vertexSE1.x % CONFIG.TILE_SIZE\n  vertexSW1.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE1.deltas.dxLeft\n\n  vertexSE2.x = n2.x + n2.collisionBox.halfWidth\n  vertexSE2.y = n2.y + n2.collisionBox.halfHeight\n  vertexSE2.row = Math.floor(vertexSE2.y / CONFIG.TILE_SIZE)\n  vertexSE2.col = Math.floor(vertexSE2.x / CONFIG.TILE_SIZE)\n  vertexSE2.deltas.dyTop = vertexSE2.y % CONFIG.TILE_SIZE\n  vertexSE2.deltas.dyBottom = CONFIG.TILE_SIZE - vertexSE2.deltas.dyTop\n  vertexSE2.deltas.dxLeft = vertexSE2.x % CONFIG.TILE_SIZE\n  vertexSW2.deltas.dxRight = CONFIG.TILE_SIZE - vertexSE2.deltas.dxLeft\n\n  return [ vertexSE1, vertexSE2 ]\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport AudioLoader from '@app/audio/AudioLoader'\nimport GraphicsLoader from '@app/graphics/GraphicsLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\nimport GameTime from '../GameTime'\nimport FrameRate from '../FrameRate'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0\n  public static loadedPercentages: Map<GameAssets, { loaded: number, weight: number }> = new Map()\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n\n    Game.loadedPercentages.set(GameAssets.Graphics, { weight: 0.3, loaded: 0.0 })\n    Game.loadedPercentages.set(GameAssets.Audio,    { weight: 0.7, loaded: 0.0 })\n\n    AudioLoader.load(   percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n    GraphicsLoader.load(percentage => this.gameAssetLoaded(GameAssets.Graphics, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop(0)\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const assetValue = Game.loadedPercentages.get(asset)\n    assetValue.loaded = percentage\n    Game.loadedPercentages.set(asset, assetValue)\n\n    Game.loadedPercentage = 0\n    for (const [_key, value] of Game.loadedPercentages) {\n      Game.loadedPercentage += value.loaded * value.weight\n    }\n\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(timestamp: number): void {\n\n    if (GameTime.previousTimestamp === undefined) {\n      GameTime.previousTimestamp = timestamp\n    }\n    GameTime.setFrameElapsedTime(timestamp - GameTime.previousTimestamp)\n  \n    this.update()\n    this.render()\n    FrameRate.calculateFrameRate(GameTime.previousTimestamp, GameTime.frameElapsedTime)\n  \n    GameTime.previousTimestamp = timestamp\n    window.requestAnimationFrame((ts) => this.gameLoop(ts))\n  }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    if (CONFIG.DEBUG.FPS) {\n      FrameRate.debug_drawFPS()\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateGameOver implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.handleEnterPress)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleEnterPress)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawGameOverScreen()\n  }\n\n  private handleEnterPress = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ENTER:\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n        break\n    }\n  }\n\n  private drawGameOverScreen(): void {\n    context.beginPath()\n      context.fillStyle = '#dd0000'\n      context.font = '32px Monospace'\n      context.fillText(\n        'YOU DIED!',\n        CONFIG.CANVAS_WIDTH / 2 - 80,\n        (CONFIG.CANVAS_HEIGHT / 2) + 10\n      )\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nimport Level, { LevelTimer } from '@app/domain/Level'\n\nexport default class GameStateLevelCleared implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.handleEnterPress)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleEnterPress)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLevelClearedStatistics()\n  }\n\n  private handleEnterPress = (e: KeyboardEvent) => {\n    if (e.keyCode === KEYBOARD_KEYS.ENTER) {\n      if (Level.isLastLevel()) {\n        Level.resetToStartingLevel()\n        Game.stateManager.setState(GAME_STATES.VICTORY)  \n      } else {\n        Level.nextLevel()\n        Game.stateManager.setState(GAME_STATES.PLAYING)\n      }\n    }\n  }\n\n  private drawLevelClearedStatistics(): void {\n    context.beginPath()\n      // Title\n      context.fillStyle = '#5555ff'\n      context.font = '22px Monospace'\n      context.fillText(\n        `Level ${Level.currentLevel} Cleared!`,\n        CONFIG.CANVAS_WIDTH / 2 - 100,\n        (CONFIG.CANVAS_HEIGHT / 2)\n      )\n      \n      // Level Time\n      context.font = '16px Monospace'\n      context.fillStyle = '#9999ff'\n      context.fillText(\n        `Time: ${Math.round(LevelTimer.timeSpentOnCurrentLevel / 1000)} seconds`,\n        CONFIG.CANVAS_WIDTH / 2 - 100,\n        (CONFIG.CANVAS_HEIGHT / 2) + 30\n      )\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GameTime from '@app/infrastructure/GameTime'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationProgress: number = 0\n  private animationLength: number = GameTime.ONE_SECOND\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationProgress = (this.animationProgress + GameTime.frameElapsedTime) % this.animationLength\n    if (this.animationProgress >= this.animationLength / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press Enter to start', CONFIG.CANVAS_WIDTH / 2 - 118, CONFIG.CANVAS_HEIGHT / 2 + 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ENTER:\n        Game.stateManager.setState(GAME_STATES.PLAYING)\n        break\n    }\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport Game from '@app/infrastructure/game/Game'\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.pauseHandler)\n  }\n\n  public exit(): void {\n    window.removeEventListener('keydown', this.pauseHandler)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private pauseHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ESC:\n        e.preventDefault()\n        GAME_STATES.PLAYING.destroyGame()\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n        break\n      case KEYBOARD_KEYS.p:\n        Game.stateManager.setState(GAME_STATES.PLAYING)\n        break\n    }\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport Level, { LevelTimer } from '@app/domain/Level'\n\nexport default class GameStatePlaying implements IGameState {\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n    this.setupOwnEventListeners()\n  }\n\n  private setupOwnEventListeners() {\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n    window.addEventListener('keydown', this.pauseHandler)\n  }\n\n  public exit(nextState: IGameState): void {\n    this.clearOwnEventListeners()\n    if (nextState !== GAME_STATES.PAUSED) {\n      this.destroyGame()\n    }\n  }\n\n  private clearOwnEventListeners() {\n    window.onblur = null\n    window.removeEventListener('keydown', this.pauseHandler)\n  }\n\n  public update(): void {\n    if (this.player.alive) {\n      Canvas.updateMousePosition()\n      Gamepads.update(this.player)\n      this.player.update()\n      this.map.update()\n      this.checkForLevelClearedCondition()\n\n      LevelTimer.incrementTimeSpentOnCurrentLevel()\n    } else {\n      Level.resetToStartingLevel()\n      Game.stateManager.setState(GAME_STATES.GAME_OVER)\n    }\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n    if (CONFIG.DEBUG.SHOW_LEVEL_TIME) {\n      LevelTimer.debug_displayTimeSpentOnCurrentLevel()\n    }\n  }\n\n  private startNewGame(): void {\n    this.map = new Map()\n    this.player = this.map.player\n\n    Keyboard.addListenerKeydown(this.player.keydownHandler)\n    Keyboard.addListenerKeyup(this.player.keyupHandler)\n\n    Mouse.init(this.playerSetShootingTrue, this.playerSetShootingFalse)\n  }\n\n  private checkForLevelClearedCondition() {\n    if ( // TODO: Extract Level Cleared conditions (they won't be the same for every level)\n      Map.enemiesRemaining() === 0 &&\n      this.checkIfPlayerIsInsideExitPortal()\n    ) {\n        Game.stateManager.setState(GAME_STATES.LEVEL_CLEARED)  \n    }\n  }\n\n  private checkIfPlayerIsInsideExitPortal(): boolean {\n    return (\n      this.player.row === Map.exitPortal.row &&\n      this.player.col === Map.exitPortal.col\n    )\n  }\n\n  public destroyGame(): void {\n    Keyboard.removeKeydownAndKeyupListeners(this.player.keydownHandler)\n    Mouse.removeMouseLeftClickListeners(this.playerSetShootingTrue, this.playerSetShootingFalse)\n\n    this.map.destroy()\n    this.map = null\n    this.player = null\n  }\n\n  public playerSetShootingTrue = (e: MouseEvent) => {\n    this.player.setShooting(true) // TODO: Move to state: player.setState(CreatureState.Attacking)\n  }\n  public playerSetShootingFalse = (e: MouseEvent) => {\n    this.player.setShooting(false)\n  }\n\n  private pauseHandler = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ESC:\n      case KEYBOARD_KEYS.p:\n        e.preventDefault()\n        Game.stateManager.setState(GAME_STATES.PAUSED)\n        break\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { KEYBOARD_KEYS } from '@app/peripherals/constants/KeyCodes'\n\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nimport IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateVictory implements IGameState {\n  public enter(): void {\n    window.addEventListener('keydown', this.handleEnterPress)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleEnterPress)\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawVictoryScreen()\n  }\n\n  private handleEnterPress = (e: KeyboardEvent) => {\n    switch (e.keyCode) {\n      case KEYBOARD_KEYS.ENTER:\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n        break\n    }\n  }\n\n  private drawVictoryScreen(): void {\n    context.beginPath()\n      context.fillStyle = '#00dd00'\n      context.font = '32px Monospace'\n      context.fillText(\n        'VICTORY!',\n        CONFIG.CANVAS_WIDTH / 2 - 80,\n        (CONFIG.CANVAS_HEIGHT / 2) + 10\n      )\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\nimport GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStateLevelCleared from './GameStateLevelCleared'\nimport GameStatePaused from './GameStatePaused'\nimport GameStateGameOver from './GameStateGameOver'\nimport GameStateVictory from './GameStateVictory'\n\nconst GAME_STATES: {[ key: string ]: IGameState } = {\n  LOADING       : new GameStateLoading(),\n  MAIN_MENU     : new GameStateMainMenu(),\n  PLAYING       : new GameStatePlaying(),\n  LEVEL_CLEARED : new GameStateLevelCleared(),\n  PAUSED        : new GameStatePaused(),\n  GAME_OVER     : new GameStateGameOver(),\n  VICTORY       : new GameStateVictory(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nexport default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}\n\nexport function updatePointRowAndColValues(p: Point): void {\n  p.row = Math.floor(p.y / CONFIG.TILE_SIZE)\n  p.col = Math.floor(p.x / CONFIG.TILE_SIZE)\n}\n\nexport function updatePointDeltas(p: Point): void {\n  p.deltas.dyTop = p.y % CONFIG.TILE_SIZE\n  p.deltas.dyBottom = CONFIG.TILE_SIZE - p.deltas.dyTop\n  p.deltas.dxLeft = p.x % CONFIG.TILE_SIZE\n  p.deltas.dxRight = CONFIG.TILE_SIZE - p.deltas.dxLeft\n}\n","export const Pi2Decimals = +Math.PI.toFixed(2)\n\nexport function random(min: number, max: number) {\n  return min + Math.floor(Math.random() * (max - min + 1))\n}\n\nexport function radiansToDegrees(radians: number) {\n  return radians * (180 / Math.PI)\n}","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n      player.movingDirections.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n      player.movingDirections.left = true\n    }\n    else {\n      player.moving.left = false\n      player.movingDirections.left = false\n\n      player.moving.right = false\n      player.movingDirections.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n      player.movingDirections.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n      player.movingDirections.up = true\n    }\n    else {\n      player.moving.up = false\n      player.movingDirections.up = false\n\n      player.moving.down = false\n      player.movingDirections.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","type KeyboardEventListener = ((e: KeyboardEvent) => void)\n\nexport default class Keyboard {\n  public static addListenerKeydown(listener: KeyboardEventListener) {\n    document.addEventListener('keydown', listener)\n  }\n  public static addListenerKeyup(listener: KeyboardEventListener) {\n    document.addEventListener('keyup', listener)\n  }\n\n  public static removeKeydownAndKeyupListeners(listener: KeyboardEventListener): void {\n    document.removeEventListener('keyup', listener)\n    document.removeEventListener('keydown', listener)\n  }\n}\n","import Canvas from '@app/infrastructure/Canvas'\n\ntype MouseEventHandler = (e: MouseEvent) => void\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(mouseDownListener: MouseEventHandler, mouseUpListener: MouseEventHandler) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(mouseDownListener, mouseUpListener)\n  }\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(mouseDownListener: MouseEventHandler, mouseUpListener: MouseEventHandler): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', mouseDownListener, false)\n    canvas.addEventListener('mouseup', mouseUpListener, false)\n  }\n\n  public static removeMouseLeftClickListeners(mouseDownListener: MouseEventHandler, mouseUpListener: MouseEventHandler) {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.removeEventListener('mousedown', mouseDownListener)\n    canvas.removeEventListener('mouseup', mouseUpListener)\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n  1: 49,\n  2: 50,\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n"],"names":["URI","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","buffer","send","context","AudioContext","static","loadCallback","load","Mixer","musicVolume","this","_musicVolume","vol","soundFxVolume","_soundFxVolume","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","all","PLAYER_DEATH","SMG","CRATE_HIT","PLAYER_HIT","ENEMY_ATTACK","ENEMY_ATTACK_MISS","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","gainNode","createGain","gain","value","connect","destination","start","SMG_INDEX","length","PLAYER_HIT_READY","PLAYER_HIT_INDEX","setTimeout","randomIndex","Math","floor","random","ENEMY_HIT_READY","oneShotAnimation","advanceAnimation","animationFinished","animationProgress","elapsedTimeFactor","animationProgressPercentage","animationLength","animationSpritePosition","numberOfSpritesInAnimation","resetAnimation","draw","c","playerCoordinates","sprite","AttackEdgeCases","constructor","x","y","collisionBox","speed","healthPercentage","prevHistoryLength","prevX","prevY","maxHealth","state","Idling","previousState","movingDirections","left","right","up","down","moving","blocked","deltas","dyTop","dyBottom","dxLeft","dxRight","widgets","movementAccumulator","maxSpeed","maxSpeedDiagonal","sin","initializeHealth","updateMapPosition","resetMoving","resetBlocked","calculateNextCoordinates","nextX","nextY","isDiagonalMovement","calculateMovementAmountPixels","MovingDirections","move","horizontalMovementControlsAreNotJammed","verticalMovementControlsAreNotJammed","direction","accumulate","movementAmount","movementAmountPixels","movementAmountDecimalPart","row","CONFIG","TILE_SIZE","col","updateTileDeltas","checkIfBlockedByCreature","nextCreatureState","collisionBoxesIntersect","intersectionX","intersectionY","halfWidth","halfHeight","adjustCollisionWithWalls","wall","walls","mapX","width","SWVertexRow","NWVertexRow","SEVertexRow","NEVertexRow","mapY","height","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","updatePreviousCoordinates","push","shift","updateDirection","targetCreature","Attacking","AttackingCooldown","MovingCooldown","updateDirectionWhenNotMoving","updateDirectionWhenMoving","Directions","S","N","E","W","directionString","join","theta","angleBetweenPoints","getDirectionBasedOnAngle","checkIfMoving","xUnchanged","every","i","yUnchanged","health","getHealthColor","CreatureState","Level","currentLevel","startingLevel","LevelTimer","reset","clear","lastLevel","totalNumberOfMaps","timeSpentOnCurrentLevel","frameElapsedTime","beginPath","fillStyle","font","levelTimeInSeconds","round","fillText","CANVAS_HEIGHT","stroke","ConcreteEnemy","pathfindingTimerStart","super","attackSpeed","attackCooldownSpeed","maxAttackTime","GAME_SPEED","maxAttackCooldown","pathfindingTimer","pathfindingInterval","resetAttackTime","resetAttackCooldown","animations","ConcreteEnemyAnimationIdling","Moving","ConcreteEnemyAnimationMoving","ConcreteEnemyAnimationMovingCooldown","ConcreteEnemyAnimationAttacking","ConcreteEnemyAnimationAttackingCooldown","Dying","ConcreteEnemyAnimationDying","Decaying","ConcreteEnemyAnimationDecaying","update","player","stateManager","getState","PLAYING","target","stuck","checkIfStuck","setState","distanceFromTarget","pointToPointDistance","targetIsInRange","targetInRange","attackTime","attackCooldown","attack","attackInProgress","thereAreObstaclesBetweenPlayerAndThisEnemy","determineIfThereAreObstaclesBetweenTwoPathNodes","findPathToPlayer","shortestPath","checkForCollisionWithOtherEnemies","checkForCollisionWithPlayer","advanceAttackTimeAndCooldown","DEBUG","ENEMY_COLLISION_BOX","debug_drawCollisionBox","RAY_TO_PLAYER","debug_drawRayToPlayer","PATHFINDING_NODES","debug_drawPathNodes","pathfindingNodes","SHORTEST_PATH_TO_PLAYER","debug_drawShortestPathToPlayer","ENEMY_STATE","debug_drawState","Removed","generatePathNodes","abs","findShortestPath","followTheShortestPath","moveTowardsPlayer","nextNodeX","nextNodeY","pop","moveTowards","strokeStyle","lineWidth","moveTo","center","lineTo","toString","p","forEach","n","drawNode","visited","node","debug_drawRayFromPointToPoint","p1","p2","Zerg","Decay","Enemy","damageNumbers","Object","values","widget","render","isOnScreen","playerX","playerY","offScreenOffset","CANVAS_WIDTH","nextEnemyState","getEnemiesOnScreen","e","sumOfCollisionBoxHalfDiagonals","sqrt","targetInEffectiveRange","xIsStatic","yIsStatic","targetIsBehindAnObstacle","determineIfThereAreObstaclesBetweenTwoPoints","playEnemyAttack","dealDamage","playEnemyAttackMiss","Miss","attackIsMiss","takeDamage","damageAmount","DamageNumberFactory","create","die","playEnemyHit","playEnemyDeath","attackEdgeCase","getDamage","newState","resetAnimations","a","Map","mapData","loadMap","enemies","filter","enemiesDecaying","destroy","splice","openPortalWhenAllEnemiesAreKilled","exitPortal","isOpen","drawGameObjects","getDecayingOnScreen","offsetLeft","colRemainder","offsetTop","rowRemainder","rowStart","halfRows","colStart","halfCols","rows","cols","map","loadGameObjects","loadEnemies","loadWalls","loadExitPortal","gameObjects","mapKey","isWall","createWall","ExitPortal","MapKeys","WallGray","WallGreen","WallBlue","Maps","Map01","Map02","keys","levelNumber","zeroPaddedLevelNumber","String","padStart","color","destructable","Portal","opacity","opacityRange","animationElapsed","animationCompletionPercentage","getColor","rect","fill","sineFunction","PI","opacityBaseline","openColor","closedColor","Wall","playWallHit","Error","canvasX","mousePosition","canvasY","offsetX","offsetY","Player","alive","rotation","sightLineLength","AvailableWeapons","equipedWeapon","_keydownHandler","keyCode","KEYBOARD_KEYS","w","s","d","switchWeapons","keyupHandler","FEATURES","DAMAGE_NUMBERS_ON_PLAYER","checkForCollisionWithEnemies","calculateTheta","drawPlayer","drawPlayerVisionRays","keydownHandler","DamageNumberColors","gray","playPlayerHit","toFixed","cos","PLAYER_COLLISION_BOX","drawPlayerVisionRay","PLAYER_VISION_RAY_SHOTGUN","hitPoint","wallHit","cast","drawRay","nextPlayerState","enemiesOnScreen","some","setShooting","isShooting","weaponIndex","playPlayerDeath","directionX","directionY","ProjectileCircle","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithWall","arc","intermediateIntervalX","intermediateIntervalY","point","ProjectileLine","shooting","projectiles","shoot","removeProjectile","cooldown","fireProjectile","playSMG","dx","dy","xVel","yVel","SCATTER_PROJECTILES","projectileConstructor","projectileIndex","maxCooldown","RifleLine","firingSpeed","red","DamageNumber","randomFactorX","randomFactorY","maxHeight","fontSize","fontWidth","damageTextHalfWidth","animationHasFinished","dmgNum","DAMAGE_NUMBERS_SHOW","feature_drawDamageNumbers","damageNumber","dmgNumber","Sprites","callback","_reject","spriteSheet","Image","src","url","DecaySprite","spriteProperties","decay","gapX","gapY","manuallyCalculatedSprites","sy","creature","drawSpritedecay","px","py","desinationWidth","desinationHeight","randomSx","drawImage","ZergSprite","spriteLocations","flip","NE","SE","SW","NW","default","dying","sx","drawSpriteDying","spriteWidth","spriteHeight","spriteStep","spriteOffsets","getSpriteOffsets","spriteLocation","drawSprite","creatureState","defaultSpriteOffset","cBox","save","translate","scale","restore","canvas","document","getElementById","style","SCALE","getContext","Canvas","clearRect","getCanvasDomElement","THROW_DEVELOPMENT_ERRORS","b","directionsAngleRangesLUT","min","max","radiansToDegrees","entries","find","angleRange","FPS_ARR","FPS","lastFrameTime","unshift","reduce","sum","current","GameAssets","GameTime","t","ONE_SECOND","previousTimestamp","startRow","startCol","path","rowEnd","colEnd","PathNode","enemy","nodeGoal","nodeStart","f","g","heuristic","nodesNotTested","nodeCurrent","sort","neighbourNodes","possiblyLowerLocalGoal","parent","coordinates","Infinity","Raycaster","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","getInterceptPointSE","getInterceptPointSW","angleBetweenTwoGivenPoints","results","n1","n2","angleBetweenNodes","vNE1","vNE2","getVerticesNE","vSE1","vSE2","getVerticesSE","Pi2Decimals","vSW1","vSW2","getVerticesSW","vNW1","vNW2","getVerticesNW","yIntercept","tileStepX","hitPointVertical","wallHitVertical","rangeHorizontal","rangeVertical","RAYCASTER","checkWallCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","wallHitHorizontal","j","checkWallCollisionHorizontalSE","pow","checkWallCollisionVerticalNE","checkWallCollisionHorizontalNE","checkWallCollisionVerticalNW","checkWallCollisionHorizontalNW","checkWallCollisionVerticalSW","checkWallCollisionHorizontalSW","xTile","yTile","yTile_aboveByOnePixel","xTile_leftByOnePixel","outsideOfScreenOffset","blankVertex","vertexNW1","vertexNW2","vertexNE1","vertexNE2","vertexSW1","vertexSW2","vertexSE1","vertexSE2","Game","window","onfocus","restart","loadedPercentages","set","Graphics","weight","loaded","Audio","percentage","gameAssetLoaded","loadInterval","setInterval","clearInterval","MAIN_MENU","gameLoop","asset","assetValue","get","loadedPercentage","_key","timestamp","undefined","setFrameElapsedTime","calculateFrameRate","requestAnimationFrame","ts","debug_drawFPS","handleEnterPress","ENTER","enter","addEventListener","exit","removeEventListener","drawGameOverScreen","isLastLevel","resetToStartingLevel","VICTORY","nextLevel","drawLevelClearedStatistics","drawLoadingDialog","instructionsVisible","handleMenuSelection","drawMainMenu","currentState","LOADING","nextState","pauseHandler","ESC","preventDefault","destroyGame","drawPauseMenu","playerSetShootingTrue","playerSetShootingFalse","PAUSED","startNewGame","setupOwnEventListeners","onblur","clearOwnEventListeners","updateMousePosition","checkForLevelClearedCondition","incrementTimeSpentOnCurrentLevel","GAME_OVER","SHOW_LEVEL_TIME","debug_displayTimeSpentOnCurrentLevel","addListenerKeydown","addListenerKeyup","init","enemiesRemaining","checkIfPlayerIsInsideExitPortal","LEVEL_CLEARED","removeKeydownAndKeyupListeners","removeMouseLeftClickListeners","drawVictoryScreen","GAME_STATES","atan2","radians","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","listener","Mouse","mouseDownListener","mouseUpListener","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","pageX","pageY","innerWidth","innerHeight","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}
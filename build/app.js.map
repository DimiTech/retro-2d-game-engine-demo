{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/infrastructure/Canvas.ts","webpack:///./src/app/infrastructure/game/Game.ts","webpack:///./src/app/infrastructure/game/game_states/GameStates.ts","webpack:///./src/app/domain/map/Map.ts","webpack:///./src/app/audio/SoundFX.ts","webpack:///./src/app/infrastructure/geometry/Point.ts","webpack:///./src/app/peripherals/Mouse.ts","webpack:///./src/app/infrastructure/Raycaster.ts","webpack:///./src/app/audio/AudioContext.ts","webpack:///./src/app/graphics/Sprites.ts","webpack:///./src/app/infrastructure/CollisionBox.ts","webpack:///./src/app/domain/Creature.ts","webpack:///./src/app/domain/map/MapKeys.ts","webpack:///./src/main.ts","webpack:///./src/app/audio/AudioLoader.ts","webpack:///./src/app/audio/Mixer.ts","webpack:///./src/app/audio/AudioBufferLoader.ts","webpack:///./src/app/graphics/GraphicsLoader.ts","webpack:///./src/app/infrastructure/FrameRate.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateLoading.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateMainMenu.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePlaying.ts","webpack:///./src/app/peripherals/Keyboard.ts","webpack:///./src/app/peripherals/constants/KeyCodes.ts","webpack:///./src/app/peripherals/Gamepads.ts","webpack:///./src/app/domain/Grid.ts","webpack:///./src/app/domain/enemies/ConcreteEnemy.ts","webpack:///./src/app/infrastructure/Pathfinding.ts","webpack:///./src/app/domain/enemies/Enemy.ts","webpack:///./src/app/infrastructure/Directions.ts","webpack:///./src/app/domain/objects/GameObjectFactory.ts","webpack:///./src/app/domain/objects/box/BoxFactory.ts","webpack:///./src/app/domain/objects/box/Box.ts","webpack:///./src/app/domain/objects/GameObject.ts","webpack:///./src/app/domain/player/Player.ts","webpack:///./src/app/domain/player/Crosshair.ts","webpack:///./src/app/domain/player/Projectile.ts","webpack:///./src/app/infrastructure/game/game_states/GameStatePaused.ts","webpack:///./src/app/infrastructure/game/game_states/GameStateManager.ts","webpack:///./src/app/infrastructure/GameAssets.ts","webpack:///./src/app/graphics/sprites/SpriteZerg.ts","webpack:///./src/app/graphics/sprites/CreatureSprite.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","Mouse_1","canvas","document","getElementById","width","CANVAS_WIDTH","height","CANVAS_HEIGHT","style","SCALE","context","getContext","Canvas","[object Object]","clearRect","this","mousePosition","x","Math","floor","default","offsetLeft","y","offsetTop","halfWidth","halfHeight","rows","TILE_SIZE","cols","halfRows","halfCols","rowRemainder","colRemainder","center","getCanvasDomElement","AudioLoader_1","GraphicsLoader_1","Canvas_1","FrameRate_1","GameStates_1","GameStateManager_1","GameAssets_1","Game","window","onfocus","restart","loadedPercentages","set","Graphics","weight","loaded","Audio","load","percentage","gameAssetLoaded","stateManager","getState","PAUSED","setState","PLAYING","loadInterval","setInterval","clearInterval","MAIN_MENU","gameLoop","asset","assetValue","loadedPercentage","_key","update","render","calculateFrameRate","requestAnimationFrame","clear","drawFPS","Map","GameStateLoading_1","GameStateMainMenu_1","GameStatePlaying_1","GameStatePaused_1","GAME_STATES","LOADING","ConcreteEnemy_1","GameObjectFactory_1","Map01","getEnemiesOnScreen","playerX","playerY","enemies","filter","e","isOnScreen","gameObjects","grid","player","loadMap","forEach","alive","splice","drawGameObjects","draw","deltas","dxLeft","dyTop","rowStart","row","colStart","col","gameObject","map","length","createGameObject","push","healthPercentage","Mixer_1","AudioContext_1","AudioBufferLoader_1","SoundFX","setLoadedPercentage","soundFxFilePromises","soundFxFiles","Promise","all","SMG","CRATE_HIT","ENEMY_HIT","ENEMY_DEATH","playSound","createBufferSource","buffer","SMG_INDEX","gainNode","createGain","gain","soundFxVolume","connect","destination","start","ENEMY_HIT_READY","ENEMY_HIT_INDEX","setTimeout","pointToPointDistance","p1","p2","sqrt","angleBetweenPoints","atan2","Mouse","hijackRightClick","trackMouseOnCanvas","listenForLeftClicks","addEventListener","preventDefault","pageX","pageY","setShooting","innerWidth","innerHeight","Point_1","Map_1","Raycaster","theta","pEnd","xInt","tan","xIntIsPositive","getInterceptPointNE","getInterceptPointNW","dyBottom","getInterceptPointSE","getInterceptPointSW","hitPoint","color","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","angleBetweenTwoGivenPoints","results","cast","hitObject","yIntercept","tileStepX","hitPointVertical","objectHitVertical","dxRight","rangeHorizontal","rangeVertical","RAYCASTER","DEBUG","coordinates","arc","PI","checkGameObjectCollisionVerticalSE","xIntercept","tileStepY","hitPointHorizontal","objectHitHorizontal","j","round","checkGameObjectCollisionHorizontalSE","pow","checkGameObjectCollisionVerticalNE","checkGameObjectCollisionHorizontalNE","checkGameObjectCollisionVerticalNW","checkGameObjectCollisionHorizontalNW","checkGameObjectCollisionVerticalSW","checkGameObjectCollisionHorizontalSW","xTile","yTile","yTile_aboveByOnePixel","gameObjectHit","fillText","xTile_leftByOnePixel","outsideOfScreenOffset","AudioContext","SpriteZerg_1","Sprites","Zerg","Directions_1","prevX","prevY","animationInterval","isMoving","moving","left","right","up","down","collisionBox","mapX","SWVertexRow","NWVertexRow","SEVertexRow","NEVertexRow","mapY","NEVertexCol","NWVertexCol","SEVertexCol","SWVertexCol","shift","direction","dx","dy","Directions","S","N","E","W","directionString","join","xUnchanged","yUnchanged","MapKeys","isBox","mapKey","startsWith","SoundFX_1","loadCallback","Mixer","musicVolume","_musicVolume","vol","_soundFxVolume","URI","resolve","reject","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send","Sprites_1","lastFrameTime","frameDeltaTime","FPS_ARR","FPS","now","performance","unshift","pop","reduce","sum","current","fillStyle","font","toFixed","Game_1","drawLoadingDialog","animationCounter","instructionsVisible","handleMenuSelection","removeEventListener","drawMainMenu","Keyboard_1","Gamepads_1","Grid_1","Player_1","previousState","startNewGame","nextState","onblur","updateMousePosition","init","KeyCodes_1","keyCode","KEYBOARD_KEYS","w","a","ESC","togglePause","ENTER","Gamepads","gamepads","navigator","getGamepads","handleMovement","handleAiming","handleButtons","gamepad","movementAxisX","axes","movementAxisY","aimAxisX","aimAxisY","aimModifier","buttons","pressed","CollisionBox_1","Raycaster_1","Pathfinding_1","Enemy_1","pathfindingInterval","super","sprite","updateMapPosition","updatePreviousCoordinates","stuck","checkIfStuck","checkIfMoving","adjustCollisionWithGameObjects","adjustCollisionWithOtherEnemies","distanceFromPlayer","thereAreObstaclesBetweenPlayerAndThisEnemy","determineIfThereAreObstaclesBetweenTwoPoints","findPathToPlayer","move","updateDirection","updateTileDeltas","advanceAnimation","drawCollisionBox","shortestPath","drawNode","visited","drawRayToPoint","damageAmount","playEnemyHit","health","die","playEnemyDeath","animationPeriods","walking","pathfindingNodes","generatePathNodes","abs","findShortestPath","pathfindingPeriod","moveTowards","moveTowardsPlayer","maxSpeedDiagonal","maxSpeed","getHealthColor","generateNodesAroundGameObject","path","cBox","neighbours","NE","SE","SW","NW","nodeNE","PathNode","generateNodeNE","nodeSE","generateNodeSE","nodeSW","generateNodeSW","nodeNW","generateNodeNW","node","startRow","startCol","rowEnd","colEnd","drawPathNodes","enemy","nodeGoal","nodeStart","f","g","heuristic","nodesNotTested","nodeCurrent","sort","b","neighbourNodes","possiblyLowerLocalGoal","parent","Infinity","Creature_1","maxHealth","initializeHealth","sin","offScreenOffset","playerCollisionBox","enemyX","enemyY","enemyCollisionBox","collidesWithEnemy","intersectionX","intersectionY","xIsStatic","every","yIsStatic","MapKeys_1","BoxFactory_1","createBox","Box_1","BoxGray","BoxGreen","BoxBlue","Error","GameObject_1","playCrateHit","destructable","Crosshair_1","Projectile_1","rotation","sightLineLength","shooting","shootingCooldown","projectiles","shoot","xVel","yVel","randomFactorX","random","randomFactorY","playSMG","isShooting","calculateTheta","drawPlayer","drawPlayerVisionRay","drawProjectiles","checkForCollisionWithEnemies","cos","drawRay","collidesWithPlayer","canvasX","canvasY","offsetX","offsetY","directionX","directionY","speed","damage","numberOfIntermediatePositions","intermediatePositions","previousX","previousY","nearbyEnemies","getNearbyEnemies","calculateIntermediatePoints","isOffScreen","intermediatePoint","checkCollisionWithEnemies","checkCollisionWithGameObject","intermediateIntervalX","intermediateIntervalY","point","takeDamage","getDamage","drawPauseMenu","currentState","exit","enter","GameAssets","CreatureSprite_1","url","playerCoordinates","spriteLocation","flip","SPRITE_OFFSETS","SPRITE_SIZE","px","py","save","translate","scale","drawImage","spriteSheet","restore","callback","_reject","Image","src"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point from '@app/infrastructure/geometry/Point'\nimport Mouse from '@app/peripherals/Mouse'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\ncanvas.width  = CONFIG.CANVAS_WIDTH\ncanvas.height = CONFIG.CANVAS_HEIGHT\ncanvas.style.width  = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_WIDTH ) + 'px' : 'auto'\ncanvas.style.height = CONFIG.SCALE !== 1 ? (CONFIG.SCALE * CONFIG.CANVAS_HEIGHT) + 'px' : 'auto'\nexport const context = canvas.getContext('2d')\n\nexport default class Canvas {\n  public static halfWidth  = canvas.width  / 2\n  public static halfHeight = canvas.height / 2\n  public static rows = Math.floor(canvas.height / CONFIG.TILE_SIZE)\n  public static cols = Math.floor(canvas.width  / CONFIG.TILE_SIZE)\n  public static halfRows = Math.floor((canvas.height / 2) / CONFIG.TILE_SIZE)\n  public static halfCols = Math.floor((canvas.width  / 2) / CONFIG.TILE_SIZE)\n  public static rowRemainder = (canvas.height / 2) % CONFIG.TILE_SIZE\n  public static colRemainder = (canvas.width  / 2) % CONFIG.TILE_SIZE\n  public static mousePosition: Point\n\n  public static center: Point = {\n    x: CONFIG.CANVAS_WIDTH  / 2,\n    y: CONFIG.CANVAS_HEIGHT / 2,\n  }\n\n  public static clear(): void {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n  }\n\n  public static getCanvasDomElement = (): HTMLCanvasElement => canvas\n\n  public static updateMousePosition() {\n    this.mousePosition = {\n      x: Math.floor((Mouse.x - canvas.offsetLeft) / CONFIG.SCALE),\n      y: Math.floor((Mouse.y - canvas.offsetTop ) / CONFIG.SCALE)\n    }\n  }\n}\n","import AudioLoader from '@app/audio/AudioLoader'\nimport GraphicsLoader from '@app/graphics/GraphicsLoader'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport FrameRate from '../FrameRate'\nimport GAME_STATES from './game_states/GameStates'\nimport GameStateManager from './game_states/GameStateManager'\nimport GameAssets from '../GameAssets'\n\nexport default class Game {\n  public static loaded: boolean = false\n  public static loadedPercentage: number = 0.0\n  public static loadedPercentages: Map<GameAssets, { loaded: number, weight: number }> = new Map()\n\n  public static stateManager: GameStateManager = new GameStateManager()\n\n  public static togglePause(): void {\n    if (Game.stateManager.getState() === GAME_STATES.PAUSED) {\n      Game.stateManager.setState(GAME_STATES.PLAYING)\n    } else {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n  }\n\n  constructor() {\n    window.onfocus = () => {\n      FrameRate.restart()\n    }\n\n    Game.loadedPercentages.set(GameAssets.Graphics, { weight: 0.3, loaded: 0.0 })\n    Game.loadedPercentages.set(GameAssets.Audio,    { weight: 0.7, loaded: 0.0 })\n\n    AudioLoader.load(   percentage => this.gameAssetLoaded(GameAssets.Audio, percentage))\n    GraphicsLoader.load(percentage => this.gameAssetLoaded(GameAssets.Graphics, percentage))\n  }\n\n  public start(): void {\n    const loadInterval = setInterval(() => {\n      if (Game.loaded) {\n        clearInterval(loadInterval)\n        Game.stateManager.setState(GAME_STATES.MAIN_MENU)\n      }\n    }, 250)\n\n    this.gameLoop()\n  }\n\n  private gameAssetLoaded(asset: GameAssets, percentage: number) {\n    const assetValue = Game.loadedPercentages.get(asset)\n    assetValue.loaded = percentage\n    Game.loadedPercentages.set(asset, assetValue)\n\n    Game.loadedPercentage = 0\n    for (const [_key, value] of Game.loadedPercentages) {\n      Game.loadedPercentage += value.loaded * value.weight\n    }\n\n    if (Game.loadedPercentage === 1.0) {\n      Game.loaded = true\n    }\n  }\n\n  private gameLoop(): void {\n    this.update()\n    this.render()\n\n    FrameRate.calculateFrameRate()\n\n    window.requestAnimationFrame(() => this.gameLoop())\n  }\n\n  private update(): void {\n    Game.stateManager.update()\n  }\n\n  private render(): void {\n    Canvas.clear()\n    Game.stateManager.render()\n    FrameRate.drawFPS() // TODO: Remove this, used just for debugging\n  }\n}\n","import GameStateLoading from './GameStateLoading'\nimport GameStateMainMenu from './GameStateMainMenu'\nimport GameStatePlaying from './GameStatePlaying'\nimport GameStatePaused from './GameStatePaused'\n\n// TODO: Add a IGameState type definition\nconst GAME_STATES = {\n  LOADING   : new GameStateLoading(),\n  MAIN_MENU : new GameStateMainMenu(),\n  PLAYING   : new GameStatePlaying(),\n  PAUSED    : new GameStatePaused(),\n}\n\nexport default GAME_STATES","import * as CONFIG from '@app/configuration/config.json'\n\nimport Grid from '@app/domain/Grid'\n\nimport Player from '@app/domain/player/Player'\nimport ConcreteEnemy from '@app/domain/enemies/ConcreteEnemy'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport Canvas from '@app/infrastructure/Canvas'\nimport GameObject from '@app/domain/objects/GameObject'\nimport GameObjectFactory from '@app/domain/objects/GameObjectFactory'\n\nimport IMap from './IMap'\nimport * as Map01 from '@app/resources/maps/Map-01.json'\n\nexport const gameObjects: GameObject[][] = []\nexport const enemies: Enemy[] = []\n\nexport function getEnemiesOnScreen(playerX: number, playerY: number): Enemy[] {\n  return enemies.filter(e => e.isOnScreen(playerX, playerY))\n}\n\nexport default class Map {\n  constructor(private grid: Grid, private player: Player) {\n    this.loadMap(Map01)\n  }\n\n  public update(): void {\n    enemies.forEach((e, i) => {\n      e.update(this.player, enemies)\n      if (e.alive === false) {\n        enemies.splice(i, 1) // Remove the enemy\n      }\n    })\n  }\n\n  public draw(): void {\n    this.drawGameObjects()\n    getEnemiesOnScreen(this.player.x, this.player.y)\n      .forEach(e => e.draw(this.player))\n  }\n\n  private drawGameObjects(): void {\n    const offsetLeft = this.player.deltas.dxLeft - Canvas.colRemainder\n    const offsetTop  = this.player.deltas.dyTop  - Canvas.rowRemainder\n\n    const rowStart = this.player.row - Canvas.halfRows\n    const colStart = this.player.col - Canvas.halfCols\n    let gameObject\n    for (let row = rowStart; row < rowStart + Canvas.rows + 1; ++row) {\n      for (let col = colStart - 1; col < colStart + Canvas.cols + 1; ++col) {\n        if (gameObjects[row] && gameObjects[row][col]) {\n          gameObject = gameObjects[row][col]\n          gameObject.x = (col - colStart) * CONFIG.TILE_SIZE - offsetLeft\n          gameObject.y = (row - rowStart) * CONFIG.TILE_SIZE - offsetTop\n          gameObject.draw()\n        }\n      }\n    }\n  }\n\n  private loadMap(map: IMap): void {\n    for (let row = 0; row < map.gameObjects.length; ++row) {\n      gameObjects[row] = []\n      for (let col = 0; col < map.gameObjects[row].length; ++col) {\n        gameObjects[row][col] = GameObjectFactory.createGameObject(row, col, map.gameObjects[row][col])\n      }\n    }\n\n    map.enemies.forEach((e, i) => {\n      enemies.push(new ConcreteEnemy(e.x, e.y, e.healthPercentage, i))\n    })\n  }\n}\n","import Mixer from './Mixer'\nimport context from './AudioContext'\nimport { load } from './AudioBufferLoader'\n\nexport default class SoundFX {\n  private static SMG: AudioBuffer[] = []\n  private static SMG_INDEX = 0\n\n  private static CRATE_HIT: AudioBuffer[] = []\n\n  private static ENEMY_HIT: AudioBuffer[] = []\n  private static ENEMY_HIT_INDEX = 0\n  private static ENEMY_HIT_READY: boolean = true\n\n  private static ENEMY_DEATH: AudioBuffer[] = []\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    const soundFxFilePromises = [\n      load('./audio/smg_1.wav'),\n      load('./audio/smg_2.wav'),\n      load('./audio/smg_3.wav'),\n      load('./audio/smg_4.wav'),\n      load('./audio/smg_5.wav'),\n\n      load('./audio/crate_hit_1.wav'),\n\n      load('./audio/enemy_hit_1.mp3'),\n      load('./audio/enemy_hit_2.mp3'),\n      load('./audio/enemy_hit_3.mp3'),\n      load('./audio/enemy_hit_4.mp3'),\n      load('./audio/enemy_hit_5.mp3'),\n\n      load('./audio/enemy_die_1.mp3'),\n    ]\n\n    // TODO: Show percentage\n    const soundFxFiles = await Promise.all(soundFxFilePromises)\n\n    this.SMG[0] = soundFxFiles[0]\n    this.SMG[1] = soundFxFiles[1]\n    this.SMG[2] = soundFxFiles[2]\n    this.SMG[3] = soundFxFiles[3]\n    this.SMG[4] = soundFxFiles[4]\n\n    this.CRATE_HIT[0] = soundFxFiles[5]\n\n    this.ENEMY_HIT[0] = soundFxFiles[6]\n    this.ENEMY_HIT[1] = soundFxFiles[7]\n    this.ENEMY_HIT[2] = soundFxFiles[8]\n    this.ENEMY_HIT[3] = soundFxFiles[9]\n    this.ENEMY_HIT[4] = soundFxFiles[10]\n\n    this.ENEMY_DEATH[0] = soundFxFiles[11]\n    setLoadedPercentage(1.0)\n  }\n\n  public static playSMG(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.SMG[this.SMG_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume * 0.2\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.SMG_INDEX = ++this.SMG_INDEX % this.SMG.length // Shuffle the SMG FX\n  }\n\n  public static playEnemyHit(): void {\n    if (this.ENEMY_HIT_READY === false) {\n      return\n    }\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_HIT[this.ENEMY_HIT_INDEX]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n    this.ENEMY_HIT_INDEX = ++this.ENEMY_HIT_INDEX % this.ENEMY_HIT.length // Shuffle\n\n    this.ENEMY_HIT_READY = false\n    setTimeout(() => { this.ENEMY_HIT_READY = true }, 500)\n  }\n\n  public static playEnemyDeath(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.ENEMY_DEATH[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n\n  public static playCrateHit(): void {\n    const playSound = context.createBufferSource()\n    playSound.buffer = this.CRATE_HIT[0]\n\n    const gainNode = context.createGain()\n    gainNode.gain.value = Mixer.soundFxVolume\n    playSound.connect(gainNode)\n\n    gainNode.connect(context.destination)\n\n    playSound.start()\n  }\n}\n","export default interface Point {\n  x: number\n  y: number\n  row?: number\n  col?: number\n  deltas?: {\n    dyTop    : number\n    dyBottom : number\n    dxLeft   : number\n    dxRight  : number\n  }\n}\n\nexport function pointToPointDistance(p1: Point, p2: Point) {\n  return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y))\n}\n\nexport function angleBetweenPoints(p1: Point, p2: Point): number {\n  const theta = Math.atan2((p1.y - p2.y), (p1.x - p2.x))\n  return theta\n}","import Canvas from '@app/infrastructure/Canvas'\nimport Player from '@app/domain/player/Player'\n\nexport default class Mouse {\n  public static x: number = window.innerWidth  / 2 + 100\n  public static y: number = window.innerHeight / 2 + 50\n  public static init(player: Player) {\n    this.hijackRightClick()\n    this.trackMouseOnCanvas()\n    this.listenForLeftClicks(player)\n  }\n\n  private static hijackRightClick(): void {\n    window.addEventListener('contextmenu', e => {\n      e.preventDefault()\n    }, false)\n  }\n\n  private static trackMouseOnCanvas(): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousemove', e => {\n      this.x = e.pageX\n      this.y = e.pageY\n    }, false)\n  }\n\n  private static listenForLeftClicks(player: Player): void {\n    const canvas: HTMLCanvasElement = Canvas.getCanvasDomElement()\n    canvas.addEventListener('mousedown', e => {\n      player.setShooting(true)\n    }, false)\n    canvas.addEventListener('mouseup', e => {\n      player.setShooting(false)\n    }, false)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Point, { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\nimport GameObject from '@app/domain/objects/GameObject'\nimport { gameObjects } from '@app/domain/map/Map'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Raycaster {\n  /**\n   * @param p     - Point from which to start Raycasting\n   * @param theta - Ray angle\n   * @param pEnd? - Optional ending point up to which the cast will be performed\n   *\n   * @returns {\n   *   hitObject, // the game object that has been hit. If no object are hit - hitObject is `null`\n   *   hitPoint   // can be either a point where the ray intersects a game object, or a just a point outside the screen if no object is hit\n   * }\n   */\n  public static cast(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    if (theta >= 0) { // South\n      const xInt = p.deltas.dyBottom / Math.tan(theta)\n\n      if (xInt >= 0) { // South East\n        return Raycaster.getInterceptPointSE(p, theta, pEnd)\n      }\n      else if (xInt < 0) { // South West\n        return Raycaster.getInterceptPointSW(p, theta, pEnd)\n      }\n    } else { // North\n      const xInt = p.deltas.dyTop / Math.tan(-theta)\n\n      // We must check if xInt is positive because sometimes it can be: 0 or -0\n      const xIntIsPositive = (1 / xInt) > 0\n\n      if (xInt >= 0 && xIntIsPositive) { // North East\n        return Raycaster.getInterceptPointNE(p, theta, pEnd)\n      }\n      else { // North West\n        return Raycaster.getInterceptPointNW(p, theta, pEnd)\n      }\n    }\n  }\n\n  public static drawRay(hitPoint: Point, color: string = '#4444FF'): void {\n    context.strokeStyle = color\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.halfWidth, Canvas.halfHeight)\n      context.lineTo(\n        Canvas.halfWidth + hitPoint.x,\n        Canvas.halfHeight + hitPoint.y\n      )\n    context.stroke()\n    context.lineWidth = 1\n  }\n\n  public static determineIfThereAreObstaclesBetweenTwoPoints(p1: Point, p2: Point): boolean {\n    const angleBetweenTwoGivenPoints = angleBetweenPoints(p2, p1)\n    const results = Raycaster.cast(p1, angleBetweenTwoGivenPoints, p2)\n\n    // I have to check if results exist because sometimes .cast() can return 'undefined'..\n    // Why .cast() sometimes returns 'undefined' could be worth investigating in the future..\n    if (results) {\n      return results.hitObject !== null\n    }\n    else {\n      return true\n    }\n  }\n\n  private static outsideOfScreenOffset = CONFIG.TILE_SIZE * 2\n  private static rangeHorizontal: number = Canvas.halfWidth  + Raycaster.outsideOfScreenOffset\n  private static rangeVertical: number   = Canvas.halfHeight + Raycaster.outsideOfScreenOffset\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSE(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyBottom > (pEnd.y - p.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNE(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxRight + tileStepX) * Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxRight > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxRight > (pEnd.x - p.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + p.deltas.dxRight + tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNE(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(-theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (pEnd.x - p.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y - tileStepY - p.deltas.dyTop,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNE(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: tileStepX + p.deltas.dxRight, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointNW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (p.y - pEnd.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) - yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalNW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyTop + tileStepY) / Math.tan(Math.PI - (-theta))\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyTop > Raycaster.rangeVertical) || (xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepY + p.deltas.dyTop > (p.y - pEnd.y) || Math.round(xIntercept) > (p.x - pEnd.x)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) - p.deltas.dyTop - tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - xIntercept,\n            y: Canvas.center.y - p.deltas.dyTop - tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalNW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: -xIntercept, y: -tileStepY - p.deltas.dyTop }\n      const hitPointVertical   = { x: - tileStepX - p.deltas.dxLeft, y: -yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  // TODO: This is a naive implementation! Add 6x optimization\n  private static getInterceptPointSW(p: Point, theta: number, pEnd?: Point): { hitPoint: Point, hitObject: GameObject } {\n    // ########################################################################\n    // Vertical Intercepts\n    // ########################################################################\n    let hitPointVertical: Point = null\n    let objectHitVertical: GameObject = null\n\n    let i = 0\n    let yIntercept\n    let tileStepX\n\n    while (true) {\n      tileStepX = i * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        yIntercept = 0\n      } else {\n        yIntercept = (p.deltas.dxLeft + tileStepX) * Math.tan(Math.PI - theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepX + p.deltas.dxLeft > Raycaster.rangeHorizontal) || (yIntercept > Raycaster.rangeVertical)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if (tileStepX + p.deltas.dxLeft > (p.x - pEnd.x) || yIntercept > (pEnd.y - p.y)) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y - (pEnd.y - p.y) + yIntercept,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x - p.deltas.dxLeft - tileStepX,\n            y: Canvas.center.y + yIntercept,\n          }\n        }\n        context.strokeStyle = '#4444FF'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      objectHitVertical = Raycaster.checkGameObjectCollisionVerticalSW(i, p, yIntercept)\n\n      if (objectHitVertical) {\n        hitPointVertical = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n        break\n      }\n      ++i\n    }\n\n    // ########################################################################\n    // Horizontal Intercepts\n    // ########################################################################\n    let hitPointHorizontal: Point = null\n    let objectHitHorizontal: GameObject = null\n\n    let j = 0\n    let xIntercept\n    let tileStepY\n\n    while (true) {\n      tileStepY = j * CONFIG.TILE_SIZE\n      if (theta === 0) {\n        break\n      } else {\n        xIntercept = (p.deltas.dyBottom + tileStepY) / Math.tan(theta)\n      }\n\n      // Outside of screen check\n      if ((tileStepY + p.deltas.dyBottom > Raycaster.rangeVertical) || (-xIntercept > Raycaster.rangeHorizontal)) {\n        break\n      }\n\n      // Don't cast beyond pEnd\n      if (pEnd) {\n        if ((tileStepY + p.deltas.dyBottom > (pEnd.y - p.y)) || (-xIntercept > (p.x - pEnd.x))) {\n          break\n        }\n      }\n\n      if (CONFIG.RAYCASTER.DEBUG) {\n        let coordinates: Point\n        if (pEnd) {\n          coordinates = {\n            x: Canvas.center.x - (pEnd.x - p.x) + xIntercept,\n            y: Canvas.center.y - (pEnd.y - p.y) + p.deltas.dyBottom + tileStepY,\n          }\n        } else {\n          coordinates = {\n            x: Canvas.center.x + xIntercept,\n            y: Canvas.center.y + p.deltas.dyBottom + tileStepY,\n          }\n        }\n        context.strokeStyle = '#44FF44'\n        context.beginPath()\n        context.arc(coordinates.x, coordinates.y, 2, 0, (2 * Math.PI))\n        context.stroke()\n      }\n\n      // Catch up with the horizontal intercept\n      if (yIntercept < tileStepY) {\n        break\n      }\n\n      objectHitHorizontal = Raycaster.checkGameObjectCollisionHorizontalSW(j, p, xIntercept)\n\n      if (objectHitHorizontal) {\n        hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n        break\n      }\n      ++j\n    }\n\n    // ########################################################################\n    // Return the closer hit point & hit object\n    // ########################################################################\n\n    if (hitPointVertical && hitPointHorizontal === null) {\n      return {\n        hitPoint  : hitPointVertical,\n        hitObject : objectHitVertical\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical === null) {\n      return {\n        hitPoint  : hitPointHorizontal,\n        hitObject : objectHitHorizontal\n      }\n    }\n    else if (hitPointHorizontal && hitPointVertical) {\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n    else if (hitPointHorizontal === null && hitPointVertical === null) {\n      // If nothing is hit, just return the last closest point!\n      const hitPointHorizontal = { x: xIntercept, y: tileStepY + p.deltas.dyBottom }\n      const hitPointVertical   = { x: -tileStepX - p.deltas.dxLeft, y: yIntercept }\n      const verticalHitDistanceFromPlayer   = Math.sqrt(Math.pow(  hitPointVertical.x, 2) + Math.pow(  hitPointVertical.y, 2))\n      const horizontalHitDistanceFromPlayer = Math.sqrt(Math.pow(hitPointHorizontal.x, 2) + Math.pow(hitPointHorizontal.y, 2))\n      if (verticalHitDistanceFromPlayer > horizontalHitDistanceFromPlayer) {\n        return {\n          hitPoint  : hitPointHorizontal,\n          hitObject : objectHitHorizontal\n        }\n      } else {\n        return {\n          hitPoint  : hitPointVertical,\n          hitObject : objectHitVertical\n        }\n      }\n    }\n  }\n\n  private static checkGameObjectCollisionVerticalSE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNE(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = 1 + p.col + i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNE(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col + Math.floor((p.deltas.dxLeft + xIntercept) / CONFIG.TILE_SIZE)\n    const xTile_leftByOnePixel = p.col + Math.floor((p.deltas.dxLeft + xIntercept - 1) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile][xTile_leftByOnePixel]) {\n        gameObjectHit = gameObjects[yTile][xTile_leftByOnePixel]\n      }\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalNW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = - 1 + p.col - i\n    const yTile = p.row + Math.floor((p.deltas.dyTop - yIntercept) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalNW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight + xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row - i - 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n\n  private static checkGameObjectCollisionVerticalSW(i: number, p: Point, yIntercept: number): GameObject {\n    const xTile = p.col - i - 1\n    const yTile = p.row + Math.floor((p.deltas.dyTop + yIntercept) / CONFIG.TILE_SIZE)\n    const yTile_aboveByOnePixel = p.row + Math.floor((p.deltas.dyTop + yIntercept - 1) / CONFIG.TILE_SIZE)\n\n    let gameObjectHit = null\n    if (gameObjects[yTile]) {\n      if (gameObjects[yTile][xTile]) {\n        gameObjectHit = gameObjects[yTile][xTile]\n      }\n      else if (gameObjects[yTile_aboveByOnePixel][xTile]) {\n        gameObjectHit = gameObjects[yTile_aboveByOnePixel][xTile]\n      }\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 112 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n  private static checkGameObjectCollisionHorizontalSW(i: number, p: Point, xIntercept: number): GameObject {\n    const xTile = p.col - Math.floor((p.deltas.dxRight - xIntercept) / CONFIG.TILE_SIZE)\n    const yTile = p.row + i + 1\n\n    let gameObjectHit = null\n    if (gameObjects[yTile] && gameObjects[yTile][xTile]) {\n      gameObjectHit = gameObjects[yTile][xTile]\n    }\n\n    if (CONFIG.RAYCASTER.DEBUG) {\n      context.fillText(`col: ${xTile}, row: ${yTile}, hit: ${gameObjectHit ? [gameObjectHit.row, gameObjectHit.col] : null}`, 10, 212 + i * 12)\n    }\n\n    return gameObjectHit\n  }\n}\n","const context: AudioContext = new AudioContext()\n\nexport default context\n","import CreatureSprite from './sprites/CreatureSprite'\nimport SpriteZerg from './sprites/SpriteZerg'\n\nexport default class Sprites {\n  public static Zerg: CreatureSprite = new SpriteZerg()\n\n  public static async load(setLoadedPercentage: (percentage: number) => void): Promise<void> {\n    await Sprites.Zerg.load(() => setLoadedPercentage(1.0))\n  }\n}\n","export default class CollisionBox {\n  public halfWidth: number\n  public halfHeight: number\n  constructor(\n    public width: number,\n    public height: number,\n  ) {\n    this.halfWidth  = this.width  / 2\n    this.halfHeight = this.height / 2\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox from '@app/infrastructure/CollisionBox'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport { Directions } from '@app/infrastructure/Directions'\n\nexport default abstract class Creature {\n  public prevX: number[] = [] // TODO: Make private?\n  public prevY: number[] = [] // TODO: Make private?\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n\n  public animationInterval: number = 0\n\n  public direction: Directions\n  public isMoving: boolean = false\n  public moving = {\n    left  : false,\n    right : false,\n    up    : false,\n    down  : false,\n  }\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n  protected collisionBox: CollisionBox\n\n  protected adjustCollisionWithGameObjects(): void {\n    let o\n    if (gameObjects[this.row]) {\n      if (this.moving.left) {\n        o = gameObjects[this.row][this.col - 1] // West\n        if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n          this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n        }\n\n        const SWVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SWVertexRow && SWVertexRow !== this.row) { // SW vertex overflows the player grid\n          o = gameObjects[SWVertexRow][this.col - 1] // South West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n\n        const NWVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (NWVertexRow && NWVertexRow !== this.row) { // NW vertex overflows the player grid\n          o = gameObjects[NWVertexRow][this.col - 1] // North West\n          if (o && this.x - this.collisionBox.halfWidth <= o.mapX + o.width) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxRight)) {\n              this.x = o.mapX + o.width + this.collisionBox.halfWidth + 1\n            }\n          }\n        }\n      }\n      if (this.moving.right) {\n        o = gameObjects[this.row][this.col + 1] // East\n        if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n          this.x = o.mapX - this.collisionBox.halfWidth - 1\n        }\n\n        const SEVertexRow = Math.floor((this.y + this.collisionBox.halfHeight - 1) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && SEVertexRow !== this.row) { // SE vertex overflows the player grid\n          o = gameObjects[SEVertexRow][this.col + 1] // South East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.down && this.deltas.dyTop <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n\n        const NEVertexRow = Math.floor((this.y - this.collisionBox.halfHeight) / CONFIG.TILE_SIZE)\n        if (SEVertexRow && NEVertexRow !== this.row) { // NE vertex overflows the player grid\n          o = gameObjects[NEVertexRow][this.col + 1] // North East\n          if (o && this.x + this.collisionBox.halfWidth >= o.mapX) {\n            if (!(this.moving.up && this.deltas.dyBottom <= this.deltas.dxLeft)) {\n              this.x = o.mapX - this.collisionBox.halfWidth - 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row - 1]) {\n      if (this.moving.up) {\n        o = gameObjects[this.row - 1][this.col] // North\n        if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n          this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n        }\n\n        const NEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n        if (NEVertexCol && NEVertexCol !== this.col) { // NE vertex overflows the player grid\n          o = gameObjects[this.row - 1][NEVertexCol] // North East\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.right && this.deltas.dyBottom > this.deltas.dxLeft)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n\n        const NWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n        if (NWVertexCol && NWVertexCol !== this.col) { // NW vertex overflows the player grid\n          o = gameObjects[this.row - 1][NWVertexCol] // North West\n          if (o && this.y - this.collisionBox.halfHeight <= o.mapY + o.height) {\n            if (!(this.moving.left && this.deltas.dyBottom > this.deltas.dxRight)) {\n              this.y = o.mapY + o.height + this.collisionBox.halfHeight + 1\n            }\n          }\n        }\n      }\n    }\n    if (gameObjects[this.row + 1]) {\n      if (this.moving.down) {\n        o = gameObjects[this.row + 1][this.col] // South\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          this.y = o.mapY - this.collisionBox.halfHeight - 1\n        }\n      }\n\n      const SEVertexCol = Math.floor((this.x + this.collisionBox.halfWidth - 1) / CONFIG.TILE_SIZE)\n      if (SEVertexCol && SEVertexCol !== this.col) { // SE vertex overflows the player grid\n        o = gameObjects[this.row + 1][SEVertexCol] // South East\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.right && this.deltas.dyTop > this.deltas.dxLeft)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n\n      const SWVertexCol = Math.floor((this.x - this.collisionBox.halfWidth) / CONFIG.TILE_SIZE)\n      if (SWVertexCol && SWVertexCol !== this.col) { // SW vertex overflows the player grid\n        o = gameObjects[this.row + 1][SWVertexCol] // South West\n        if (o && this.y + this.collisionBox.halfHeight >= o.mapY) {\n          if (!(this.moving.left && this.deltas.dyTop > this.deltas.dxRight)) {\n            this.y = o.mapY - this.collisionBox.halfHeight - 1\n          }\n        }\n      }\n    }\n  }\n\n  protected updatePreviousCoordinates(): void {\n    this.prevX.push(this.x)\n    if (this.prevX.length > 5) { this.prevX.shift() }\n\n    this.prevY.push(this.y)\n    if (this.prevY.length > 5) { this.prevY.shift() }\n  }\n\n  protected updateDirection(): void {\n    const direction: string[] = []\n\n    const dx = this.x - this.prevX[this.prevX.length - 1]\n    const dy = this.y - this.prevY[this.prevY.length - 1]\n\n    if (dy > 0) {\n      direction.push(Directions.S)\n    }\n    else if (dy < 0) {\n      direction.push(Directions.N)\n    }\n\n    if (dx > 0) {\n      direction.push(Directions.E)\n    }\n    else if (dx < 0) {\n      direction.push(Directions.W)\n    }\n\n    const directionString = direction.join('') || 'S'\n\n    this.direction = Directions[directionString as keyof typeof Directions]\n  }\n\n  protected checkIfMoving(): boolean {\n    const xUnchanged = this.prevX[this.prevX.length - 1] === this.prevX[this.prevX.length - 2]\n    const yUnchanged = this.prevY[this.prevY.length - 1] === this.prevY[this.prevY.length - 2]\n    if (xUnchanged && yUnchanged) {\n      return false\n    } else {\n      return true\n    }\n  }\n}\n","enum MapKeys {\n  Empty    = 0,\n  BoxGray  = 1,\n  BoxGreen = 2,\n  BoxBlue  = 3,\n}\n\nexport function isBox(mapKey: MapKeys) {\n  return MapKeys[mapKey].startsWith('Box')\n}\n\nexport default MapKeys\n","import Game from '@app/infrastructure/game/Game'\n\nconst game: Game = new Game()\ngame.start()\n","import SoundFX from './SoundFX'\n\nexport default class AudioLoader {\n  public static async load(loadCallback: (percentage: number) => void) {\n    await SoundFX.load(loadCallback)\n  }\n}\n","export default class Mixer {\n  private static _musicVolume   : number = 0.3\n  private static _soundFxVolume : number = 0.15\n\n  public static get musicVolume(): number {\n    return this._musicVolume\n  }\n  public static set musicVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._musicVolume = vol\n    }\n  }\n\n  public static get soundFxVolume(): number {\n    return this._soundFxVolume\n  }\n  public static set soundFxVolume(vol: number) {\n    if (vol >= 0 && vol <= 1) {\n      this._soundFxVolume = vol\n    }\n  }\n}\n","import context from './AudioContext'\n\nexport function load(URI: string): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest()\n    request.open('GET', URI, true)\n    request.responseType = 'arraybuffer'\n    request.onload = () => {\n      context.decodeAudioData(request.response, buffer => {\n        return resolve(buffer)\n      })\n    }\n    request.send()\n  })\n}\n","import Sprites from './Sprites'\n\nexport default class GraphicsLoader {\n  public static async load(setLoadedPercentage: (percentage: number) => void) {\n    Sprites.load(setLoadedPercentage)\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from './Canvas'\n\nlet lastFrameTime: number\nlet frameDeltaTime: number\n\nconst FPS_ARR: number[] = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\nlet FPS: number\n\nexport default class FrameRate {\n\n  public static restart() {\n    lastFrameTime = null\n    for (let i = 0; i < FPS_ARR.length; ++i) {\n      FPS_ARR[i] = 0\n    }\n  }\n\n  public static calculateFrameRate(): void {\n    if (!lastFrameTime) {\n      lastFrameTime = performance.now()\n      FPS = 0\n    } else {\n      const now = performance.now()\n      frameDeltaTime = (now - lastFrameTime) / 1000\n\n      FPS_ARR.unshift(1 / (frameDeltaTime))\n      FPS_ARR.pop()\n      FPS = FPS_ARR.reduce((sum, current) => sum += current, 0) / FPS_ARR.length\n\n      lastFrameTime = now\n    }\n  }\n\n  public static drawFPS() {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '8px Monospace'\n\n      context.fillText(`FPS: ${FPS && FPS.toFixed(2) || 'unknown'}`, 10, CONFIG.CANVAS_HEIGHT - 10)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\n\nexport default class GameStateMainMenu implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    this.drawLoadingDialog()\n  }\n\n  private drawLoadingDialog(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n      context.fillText(`Loading: ${+(Game.loadedPercentage * 100)}%`, CONFIG.CANVAS_WIDTH / 2 - 70, CONFIG.CANVAS_HEIGHT / 2 - 10)\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport Game from '@app/infrastructure/game/Game'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateMainMenu implements IGameState {\n  private animationCounter: number = 0\n  private animationInterval: number = 100\n  private instructionsVisible: boolean = true\n\n  public enter(): void {\n    window.addEventListener('keydown', this.handleMenuSelection)\n  }\n  public exit(): void {\n    window.removeEventListener('keydown', this.handleMenuSelection)\n  }\n\n  public update(): void {\n    this.animationCounter = (this.animationCounter + 1) % this.animationInterval\n    if (this.animationCounter >= this.animationInterval / 2) {\n      this.instructionsVisible = false\n    } else {\n      this.instructionsVisible = true\n    }\n    return\n  }\n\n  public render(): void {\n    this.drawMainMenu()\n  }\n\n  private drawMainMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n\n      context.font = '12px Monospace'\n      context.fillText('Retro 2D Top-Down Game Engine', CONFIG.CANVAS_WIDTH / 2 - 106, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      if (this.instructionsVisible) {\n        context.font = '20px Monospace'\n        context.fillText('Press any key to start', CONFIG.CANVAS_WIDTH / 2 - 132, CONFIG.CANVAS_HEIGHT / 2 - 10)\n      }\n    context.stroke()\n  }\n\n  private handleMenuSelection(): void {\n    Game.stateManager.setState(GAME_STATES.PLAYING)\n  }\n}\n","import IGameState from './IGameState'\n\nimport Game from '@app/infrastructure/game/Game'\nimport Canvas from '@app/infrastructure/Canvas'\n\nimport Keyboard from '@app/peripherals/Keyboard'\nimport Mouse from '@app/peripherals/Mouse'\nimport Gamepads from '@app/peripherals/Gamepads'\n\nimport Grid from '@app/domain/Grid'\nimport Map from '@app/domain/map/Map'\nimport Player from '@app/domain/player/Player'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePlaying implements IGameState {\n  private grid: Grid\n  private player: Player\n  private map: Map\n\n  public enter(previousState: IGameState): void {\n    if (previousState !== GAME_STATES.PAUSED) {\n      this.startNewGame()\n    }\n  }\n\n  public exit(nextState: IGameState): void {\n    if (nextState !== GAME_STATES.PAUSED) {\n      window.onblur = null\n    }\n  }\n\n  public update(): void {\n    Canvas.updateMousePosition()\n    Gamepads.update(this.player)\n    this.player.update()\n    this.map.update()\n  }\n\n  public render(): void {\n    this.map.draw()\n    this.player.draw()\n  }\n\n  private startNewGame(): void {\n    this.grid = new Grid()\n    this.player = new Player(128, 64)\n    this.map = new Map(this.grid, this.player)\n\n    window.onblur = () => {\n      Game.stateManager.setState(GAME_STATES.PAUSED)\n    }\n\n    Keyboard.init(this.player)\n    Mouse.init(this.player)\n  }\n}\n","import Game from '@app/infrastructure/game/Game'\nimport FrameRate from '@app/infrastructure/FrameRate'\nimport Player from '@app/domain/player/Player'\nimport { KEYBOARD_KEYS } from './constants/KeyCodes'\n\nexport default class Keyboard {\n  public static init(player: Player): void {\n    document.addEventListener('keydown', e => {\n      // TODO: Move Player logic to Player class\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = true\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = true\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = true\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = true\n          break\n        case KEYBOARD_KEYS.ESC:\n        case KEYBOARD_KEYS.p:\n          Game.togglePause()\n          break\n        default:\n          break\n      }\n    })\n    document.addEventListener('keyup', e => {\n      switch (e.keyCode) {\n        case KEYBOARD_KEYS.w:\n          player.moving.up = false\n          break\n        case KEYBOARD_KEYS.a:\n          player.moving.left = false\n          break\n        case KEYBOARD_KEYS.s:\n          player.moving.down = false\n          break\n        case KEYBOARD_KEYS.d:\n          player.moving.right = false\n          break\n        default:\n          break\n      }\n    })\n  }\n}\n","export const KEYBOARD_KEYS = {\n  ENTER: 13,\n  ESC: 27,\n  w: 87,\n  a: 65,\n  s: 83,\n  d: 68,\n  p: 80,\n}\n","import Player from '@app/domain/player/Player'\nimport Mouse from './Mouse'\n\nexport default class Gamepads {\n  public static update(player: Player): void {\n    const gamepads = navigator.getGamepads()\n    if (gamepads[0]) {\n      this.handleMovement(gamepads[0], player)\n      this.handleAiming(gamepads[0])\n      this.handleButtons(gamepads[0], player)\n    }\n  }\n\n  private static aimModifier: number = 10\n\n  private static handleMovement(gamepad: any, player: Player): void {\n    const movementAxisX: number = +gamepad.axes[0].toFixed(2)\n    if (movementAxisX > 0) {\n      player.moving.right = true\n    }\n    else if (movementAxisX < 0) {\n      player.moving.left = true\n    }\n    else {\n      player.moving.left  = false\n      player.moving.right = false\n    }\n\n    const movementAxisY: number = +gamepad.axes[1].toFixed(2)\n    if (movementAxisY > 0) {\n      player.moving.down = true\n    }\n    else if (movementAxisY < 0) {\n      player.moving.up = true\n    }\n    else {\n      player.moving.up   = false\n      player.moving.down = false\n    }\n  }\n\n  private static handleAiming(gamepad: any): void {\n    const aimAxisX = gamepad.axes[2]\n    const aimAxisY = gamepad.axes[3]\n    if (+aimAxisX.toFixed(2) !== 0) {\n      Mouse.x += aimAxisX * this.aimModifier\n    }\n    if (+aimAxisY.toFixed(2) !== 0) {\n      Mouse.y += aimAxisY * this.aimModifier\n    }\n  }\n\n  private static handleButtons(gamepad: any, player: Player): void {\n    const R1 = gamepad.buttons[5]\n    if (R1.pressed) {\n      player.setShooting(true)\n    }\n    else {\n      player.setShooting(false)\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\n// TODO: This class is useless?\nexport default class Grid {\n  public rows: number = CONFIG.CANVAS_HEIGHT / CONFIG.TILE_SIZE\n  public cols: number = CONFIG.CANVAS_WIDTH  / CONFIG.TILE_SIZE\n}\n\nexport interface NeighbourTiles {\n    N  : (any | null)\n    NE : (any | null)\n    E  : (any | null)\n    SE : (any | null)\n    S  : (any | null)\n    SW : (any | null)\n    W  : (any | null)\n    NW : (any | null)\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport SoundFX from '@app/audio/SoundFX'\n\nimport Game from '@app/infrastructure/game/Game'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport { generatePathNodes, drawPathNodes, findShortestPath, drawNode } from '@app/infrastructure/Pathfinding'\n\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\nimport Sprites from '@app/graphics/Sprites'\n\nexport default class ConcreteEnemy extends Enemy {\n  protected sprite: CreatureSprite = Sprites.Zerg\n  constructor(\n    x: number,\n    y: number,\n    healthPercentage: number,\n    protected pathfindingInterval: number\n  ) {\n    super(x, y, new CollisionBox(16, 16), 1, healthPercentage)\n    this.updateMapPosition()\n  }\n\n  public update(player: Player, enemies: Enemy[]): void {\n    this.updatePreviousCoordinates()\n\n    this.stuck    = this.checkIfStuck()\n    this.isMoving = this.checkIfMoving()\n\n    this.adjustCollisionWithGameObjects()\n    this.adjustCollisionWithOtherEnemies(enemies)\n    this.distanceFromPlayer = pointToPointDistance(\n      { x: player.x, y: player.y },\n      { x: this.x,   y: this.y   }\n    )\n    this.thereAreObstaclesBetweenPlayerAndThisEnemy =\n      Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(this, player)\n    this.findPathToPlayer(player)\n\n    this.move()\n    this.updateDirection()\n    this.updateTileDeltas()\n\n    if (Game.stateManager.getState() !== GAME_STATES.PAUSED) {\n      this.advanceAnimation()\n    }\n  }\n\n  public draw(player: Player): void {\n    this.drawCollisionBox(player) // Just for debugging\n    // this.drawRayToPlayer(player) // TODO: Just for debugging\n    // drawPathNodes(this.pathfindingNodes, this.collisionBox, player, this.getHealthColor()) // TODO: Just for debugging\n\n    // TODO: Just for debugging\n    this.shortestPath\n      .forEach((n, i) => {\n        drawNode(n, this.collisionBox, player, n.visited ? '#FF0000' : '#FF00FF')\n      })\n    if (this.shortestPath.length > 0) {\n      this.drawRayToPoint(this.shortestPath[this.shortestPath.length - 1], player)\n    }\n    this.sprite.draw(this, { x: player.x, y: player.y })\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playEnemyHit()\n    this.health -= damageAmount\n    if (this.health <= 0) {\n      this.die()\n    } else {\n      SoundFX.playEnemyHit()\n    }\n  }\n\n  public die() {\n    SoundFX.playEnemyDeath()\n    this.alive = false\n  }\n\n  protected advanceAnimation(): void {\n    this.animationInterval = (this.animationInterval + 0.5) % this.sprite.animationPeriods.walking\n  }\n\n  private findPathToPlayer(player: Player): void {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) { // TODO: || this.isStuck()\n      if (this.pathfindingInterval === 0) {\n        this.pathfindingNodes = generatePathNodes(\n          Math.round(Math.abs(player.row + this.row) / 2),\n          Math.round(Math.abs(player.col + this.col) / 2),\n          this.collisionBox,\n        )\n        this.shortestPath = findShortestPath(this, player, this.pathfindingNodes)\n      }\n\n      this.pathfindingInterval = (this.pathfindingInterval + 1) % this.pathfindingPeriod\n\n      if (this.shortestPath.length > 0) {\n        this.moveTowards(\n          this.shortestPath[this.shortestPath.length - 1].x,\n          this.shortestPath[this.shortestPath.length - 1].y\n        )\n      }\n    }\n    else {\n      if (this.pathfindingNodes) {\n        this.pathfindingNodes = null\n      }\n      if (this.shortestPath) {\n        this.shortestPath = []\n      }\n      this.moveTowardsPlayer(player)\n    }\n  }\n\n  private moveTowardsPlayer(player: Player): void {\n    if (this.distanceFromPlayer > this.collisionBox.width - 4) {\n      this.moveTowards(player.x, player.y)\n    }\n    else {\n      this.moving.left  = false\n      this.moving.right = false\n      this.moving.up    = false\n      this.moving.down  = false\n    }\n  }\n\n  private moveTowards(x: number, y: number): void {\n    this.moving.left  = false\n    this.moving.right = false\n    this.moving.up    = false\n    this.moving.down  = false\n    if (this.x < x) {\n      this.moving.right = true\n    }\n    else if (this.x > x) {\n      this.moving.left = true\n    }\n    if (this.y < y) {\n      this.moving.down = true\n    }\n    else if (this.y > y) {\n      this.moving.up = true\n    }\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private move(): void {\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.updateMapPosition()\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private drawCollisionBox(player: Player) {\n    context.strokeStyle = this.getHealthColor()\n    context.lineWidth = 0.2\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // optimize/cache the vertex calculations.\n      context.moveTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x + (this.x - player.x) + this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth, -0.5 + Canvas.center.y + (this.y - player.y) + this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + (this.x - player.x) - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + (this.y - player.y) - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPlayer(player: Player) {\n    if (this.thereAreObstaclesBetweenPlayerAndThisEnemy) {\n      context.strokeStyle = '#FFFF44'\n    } else {\n      context.strokeStyle = '#00F0FF'\n    }\n    context.lineWidth = 0.5\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x, Canvas.center.y)\n    context.stroke()\n  }\n\n  // TODO: Just for debugging\n  private drawRayToPoint(p: Point, player: Player) {\n    context.strokeStyle = '#FF00FF'\n    context.lineWidth = 0.2\n    context.beginPath()\n      context.moveTo(Canvas.center.x + (this.x - player.x), Canvas.center.y + (this.y - player.y))\n      context.lineTo(Canvas.center.x + (p.x - player.x), Canvas.center.y + (p.y - player.y))\n    context.stroke()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { NeighbourTiles } from '@app/domain/Grid'\nimport Point, { pointToPointDistance } from '@app/infrastructure/geometry/Point'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from './Raycaster'\n\nimport { gameObjects } from '@app/domain/map/Map'\nimport GameObject from '@app/domain/objects/GameObject'\nimport Player from '@app/domain/player/Player'\nimport Enemy from '@app/domain/enemies/Enemy'\n\n/**\n *   o      o     o      o   o     o     o\n *     ----         ----       ---- ----\n *    |    |       |    |     |    |    |\n *     ----       o ---- o     ---- ----\n *   o      o      |    |    o     o     o\n *                  ----\n *                o      o\n *\n *      o     o     o          o      o\n *        ---- ----              ----\n *       |    |    |      o   o |    |\n *      o ---- ---- o       ---- ----\n *       |    | o          |    | o   o\n *        ----              ----\n *      o      o          o      o\n */\n// TODO: cache path nodes for same collision box dimensions || don't generate path nodes every frame\nexport function generatePathNodes(startRow: number, startCol: number, cBox: CollisionBox): PathNode[] {\n  const path: PathNode[] = []\n\n  const rowOffset = 3\n  const colOffset = 2\n  let rowStart = startRow - Canvas.halfRows - rowOffset\n  let colStart = startCol - Canvas.halfCols - colOffset\n  const rowEnd = startRow + Canvas.halfRows + rowOffset\n  const colEnd = startCol + Canvas.halfCols + colOffset\n\n  if (rowStart < 0) { rowStart = 0 }\n  if (colStart < 0) { colStart = 0 }\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = colStart - 1; col < colEnd; ++col) {\n      if (!gameObjects[row] || !gameObjects[row][col]) { continue }\n      generateNodesAroundGameObject(path, gameObjects[row][col], cBox)\n    }\n  }\n\n  return path\n}\n\nfunction generateNodesAroundGameObject(path: PathNode[], o: GameObject, cBox: CollisionBox): void {\n  const neighbours: NeighbourTiles = {\n    N  : gameObjects[o.row - 1] ? gameObjects[o.row - 1][o.col    ] : null,\n    NE : gameObjects[o.row - 1] ? gameObjects[o.row - 1][o.col + 1] : null,\n    E  : gameObjects[o.row    ] ? gameObjects[o.row    ][o.col + 1] : null,\n    SE : gameObjects[o.row + 1] ? gameObjects[o.row + 1][o.col + 1] : null,\n    S  : gameObjects[o.row + 1] ? gameObjects[o.row + 1][o.col    ] : null,\n    SW : gameObjects[o.row + 1] ? gameObjects[o.row + 1][o.col - 1] : null,\n    W  : gameObjects[o.row    ] ? gameObjects[o.row    ][o.col - 1] : null,\n    NW : gameObjects[o.row - 1] ? gameObjects[o.row - 1][o.col - 1] : null,\n  }\n\n  let nodeNE = generateNodeNE(o, neighbours, cBox)\n  let nodeSE = generateNodeSE(o, neighbours, cBox)\n  let nodeSW = generateNodeSW(o, neighbours, cBox)\n  let nodeNW = generateNodeNW(o, neighbours, cBox)\n\n  if (nodeNE && (nodeNE.x < 0 || nodeNE.y < 0)) { nodeNE = null }\n  if (nodeSE && (nodeSE.x < 0 || nodeSE.y < 0)) { nodeSE = null }\n  if (nodeSW && (nodeSW.x < 0 || nodeSW.y < 0)) { nodeSW = null }\n  if (nodeNW && (nodeNW.x < 0 || nodeNW.y < 0)) { nodeNW = null }\n\n  path.forEach(node => {\n    if (nodeNE && (node.x === nodeNE.x && node.y === nodeNE.y)) { nodeNE = null }\n    if (nodeSE && (node.x === nodeSE.x && node.y === nodeSE.y)) { nodeSE = null }\n    if (nodeSW && (node.x === nodeSW.x && node.y === nodeSW.y)) { nodeSW = null }\n    if (nodeNW && (node.x === nodeNW.x && node.y === nodeNW.y)) { nodeNW = null }\n  })\n\n  if (nodeNE) { path.push(nodeNE) }\n  if (nodeSE) { path.push(nodeSE) }\n  if (nodeSW) { path.push(nodeSW) }\n  if (nodeNW) { path.push(nodeNW) }\n}\n\nfunction generateNodeNE(o: GameObject, neighbours: NeighbourTiles, cBox: CollisionBox): PathNode {\n  if (neighbours.NE) {\n    return null\n  }\n  else {\n    if (!neighbours.N && !neighbours.E) {\n      return new PathNode({\n        x: o.mapX + o.width + cBox.halfWidth,\n        y: o.mapY - cBox.halfHeight,\n      })\n    }\n    if (neighbours.N && !neighbours.E) {\n      return new PathNode({\n        x: o.mapX + o.width + cBox.halfWidth,\n        y: o.mapY,\n      })\n    }\n    if (!neighbours.N && neighbours.E) {\n      return new PathNode({\n        x: o.mapX + o.width,\n        y: o.mapY - cBox.halfHeight,\n      })\n    }\n  }\n}\nfunction generateNodeSE(o: GameObject, neighbours: NeighbourTiles, cBox: CollisionBox): PathNode {\n  if (neighbours.SE) {\n    return null\n  }\n  else {\n    if (!neighbours.S && !neighbours.E) {\n      return new PathNode({\n        x: o.mapX + o.width  + cBox.halfWidth,\n        y: o.mapY + o.height + cBox.halfHeight,\n      })\n    }\n    if (neighbours.S && !neighbours.E) {\n      return new PathNode({\n        x: o.mapX + o.width  + cBox.halfWidth,\n        y: o.mapY + o.height,\n      })\n    }\n    if (!neighbours.S && neighbours.E) {\n      return new PathNode({\n        x: o.mapX + o.width,\n        y: o.mapY + o.height + cBox.halfHeight,\n      })\n    }\n  }\n}\nfunction generateNodeSW(o: GameObject, neighbours: NeighbourTiles, cBox: CollisionBox): PathNode {\n  if (neighbours.SW) {\n    return null\n  }\n  else {\n    if (!neighbours.S && !neighbours.W) {\n      return new PathNode({\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY + o.height + cBox.halfHeight,\n      })\n    }\n    if (neighbours.S && !neighbours.W) {\n      return new PathNode({\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY + o.height,\n      })\n    }\n    if (!neighbours.S && neighbours.W) {\n      return new PathNode({\n        x: o.mapX,\n        y: o.mapY + o.height + cBox.halfHeight,\n      })\n    }\n  }\n}\nfunction generateNodeNW(o: GameObject, neighbours: NeighbourTiles, cBox: CollisionBox): PathNode {\n  if (neighbours.NW) {\n    return null\n  }\n  else {\n    if (!neighbours.N && !neighbours.W) {\n      return new PathNode({\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY - cBox.halfHeight,\n      })\n    }\n    if (neighbours.N && !neighbours.W) {\n      return new PathNode({\n        x: o.mapX - cBox.halfWidth,\n        y: o.mapY,\n      })\n    }\n    if (!neighbours.N && neighbours.W) {\n      return new PathNode({\n        x: o.mapX,\n        y: o.mapY - cBox.halfHeight,\n      })\n    }\n  }\n}\n\nexport function drawPathNodes(path: PathNode[], cBox: CollisionBox, player: Player, color: string): void {\n  if (path) {\n    path.forEach(node => drawNode(node, cBox, player, color))\n  }\n}\n\nexport function drawNode(node: PathNode, cBox: CollisionBox, player: Player, color: string): void {\n  context.strokeStyle = color\n  context.lineWidth = 0.1\n  context.beginPath()\n    // Since this is just for debugging purposes, there is no need to\n    // optimize/cache the vertex calculations.\n    context.moveTo( 0.5 + Canvas.center.x + (node.x - player.x) - cBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - cBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + cBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - cBox.halfHeight)\n    context.lineTo(-0.5 + Canvas.center.x + (node.x - player.x) + cBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + cBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - cBox.halfWidth, -0.5 + Canvas.center.y + (node.y - player.y) + cBox.halfHeight)\n    context.lineTo( 0.5 + Canvas.center.x + (node.x - player.x) - cBox.halfWidth,  0.5 + Canvas.center.y + (node.y - player.y) - cBox.halfHeight)\n  context.stroke()\n\n  context.beginPath()\n    context.arc(\n      Canvas.center.x + (node.x - player.x),\n      Canvas.center.y + (node.y - player.y),\n      1,\n      0,\n      (2 * Math.PI)\n    )\n  context.stroke()\n}\n\nexport function findShortestPath(enemy: Enemy, player: Player, pathfindingNodes: PathNode[]): PathNode[] {\n  const nodeGoal  = new PathNode(player)\n  const nodeStart = new PathNode(enemy)\n\n  pathfindingNodes.push(nodeGoal)\n\n  nodeStart.f = 0\n  nodeStart.g = nodeStart.heuristic(nodeGoal)\n\n  const nodesNotTested: PathNode[] = [ nodeStart ]\n\n  let nodeCurrent: PathNode\n\n  while (nodesNotTested.length > 0 || nodeCurrent === nodeGoal) {\n    nodesNotTested.sort((a: PathNode, b: PathNode) => a.g - b.g)\n\n    while (nodesNotTested.length > 0 && nodesNotTested[0].visited === true) {\n      nodesNotTested.shift()\n    }\n\n    if (nodesNotTested.length <= 0) {\n      break\n    }\n\n    nodeCurrent = nodesNotTested.shift()\n    nodeCurrent.visited = true\n\n    // Get neighbour nodes.\n    nodeCurrent.neighbourNodes = [ ...pathfindingNodes ]\n      .filter(node => {\n        return Raycaster.determineIfThereAreObstaclesBetweenTwoPoints(nodeCurrent, node) === false\n      })\n\n    nodeCurrent.neighbourNodes\n      .map(node => {\n        if (node.visited === false) {\n          nodesNotTested.push(node)\n        }\n\n        // Calculate local goal\n        const possiblyLowerLocalGoal = nodeCurrent.f + pointToPointDistance(nodeCurrent, node)\n\n        if (possiblyLowerLocalGoal < node.f) {\n          node.parent = nodeCurrent\n          node.f = possiblyLowerLocalGoal\n          node.g = node.f + node.heuristic(nodeGoal)\n        }\n\n        return node\n      })\n  }\n\n  const path = []\n  if (nodeGoal.parent) {\n    let n: PathNode = nodeGoal\n    while (n.parent) {\n      path.push(n)\n      n = n.parent\n    }\n  }\n  return path\n}\n\nexport class PathNode implements Point {\n  public x: number\n  public y: number\n  public row: number\n  public col: number\n  public deltas = {\n    dyTop    : 0,\n    dyBottom : 0,\n    dxLeft   : 0,\n    dxRight  : 0,\n  }\n\n  public visited: boolean = false\n  public g: number = Infinity // Global goal\n  public f: number = Infinity // Local goal\n  public parent: PathNode = null\n  public neighbourNodes: PathNode[]\n\n  constructor(coordinates: Point) {\n    this.x = coordinates.x\n    this.y = coordinates.y\n    this.updateTileDeltas()\n    this.updateMapPosition()\n  }\n\n  public heuristic(nodeGoal: PathNode): number {\n    return pointToPointDistance(this, nodeGoal)\n  }\n\n  // TODO: Compose this functionality since it's shared between enemies and player\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport Creature from '@app/domain/Creature'\nimport Player from '@app/domain/player/Player'\nimport { PathNode } from '@app/infrastructure/Pathfinding'\nimport CreatureSprite from '@app/graphics/sprites/CreatureSprite'\n\nexport default abstract class Enemy extends Creature {\n  public alive: boolean = true\n  public maxHealth: number = 100\n  public health: number\n\n  protected maxSpeedDiagonal: number\n\n  protected stuck: boolean\n\n  protected distanceFromPlayer: number\n  protected thereAreObstaclesBetweenPlayerAndThisEnemy: boolean\n  protected pathfindingInterval: number = 0\n  protected pathfindingPeriod: number = 30\n  protected pathfindingNodes: PathNode[]\n  protected shortestPath: PathNode[] = []\n\n  protected sprite: CreatureSprite\n\n  constructor(\n    public x: number,\n    public y: number,\n    public collisionBox: CollisionBox,\n    protected maxSpeed: number,\n    healthPercentage: number,\n  ) {\n    super()\n    this.initializeHealth(healthPercentage)\n\n    this.maxSpeedDiagonal = Math.round(Math.sin(45) * this.maxSpeed)\n  }\n\n  public abstract draw(player: Player): void\n  public abstract update(player: Player, enemies: Enemy[]): void\n\n  public isOnScreen(playerX: number, playerY: number): boolean {\n    const offScreenOffset = CONFIG.TILE_SIZE * 2\n    return (\n      Math.abs(this.x - playerX) < (CONFIG.CANVAS_WIDTH  / 2) + offScreenOffset &&\n      Math.abs(this.y - playerY) < (CONFIG.CANVAS_HEIGHT / 2) + offScreenOffset\n    )\n  }\n\n  public collidesWithPlayer(playerX: number, playerY: number, playerCollisionBox: CollisionBox): boolean {\n    return (\n      this.x - this.collisionBox.halfWidth  < playerX + playerCollisionBox.halfWidth  &&\n      this.x + this.collisionBox.halfWidth  > playerX - playerCollisionBox.halfWidth  &&\n      this.y - this.collisionBox.halfHeight < playerY + playerCollisionBox.halfHeight &&\n      this.y + this.collisionBox.halfHeight > playerY - playerCollisionBox.halfHeight\n    )\n  }\n\n  public abstract takeDamage(damageAmount: number): void\n  protected abstract advanceAnimation(): void\n\n  protected collidesWithEnemy(enemyX: number, enemyY: number, enemyCollisionBox: CollisionBox): boolean {\n    return (\n      this.x - this.collisionBox.halfWidth  < enemyX + enemyCollisionBox.halfWidth  &&\n      this.x + this.collisionBox.halfWidth  > enemyX - enemyCollisionBox.halfWidth  &&\n      this.y - this.collisionBox.halfHeight < enemyY + enemyCollisionBox.halfHeight &&\n      this.y + this.collisionBox.halfHeight > enemyY - enemyCollisionBox.halfHeight\n    )\n  }\n\n  protected adjustCollisionWithOtherEnemies(enemies: Enemy[]): void {\n    enemies.forEach(e => {\n      if (this !== e && this.collidesWithEnemy(e.x, e.y, e.collisionBox)) {\n        let intersectionX: number\n        let intersectionY: number\n        if (this.x < e.x) {\n          intersectionX = (this.x + this.collisionBox.halfWidth) - (e.x - e.collisionBox.halfWidth)\n        } else if (this.x > e.x) {\n          intersectionX = (e.x + e.collisionBox.halfWidth) - (this.x - this.collisionBox.halfWidth)\n        }\n        if (this.y < e.y) {\n          intersectionY = (this.y + this.collisionBox.halfHeight) - (e.y - e.collisionBox.halfHeight)\n        } else if (this.y > e.y) {\n          intersectionY = (e.y + e.collisionBox.halfHeight) - (this.y - this.collisionBox.halfHeight)\n        }\n        if (!intersectionX || intersectionX >= intersectionY) {\n          if (this.y < e.y) {\n            e.y += intersectionY\n          } else {\n            e.y -= intersectionY\n          }\n        } else if (!intersectionY || intersectionX < intersectionY) {\n          if (this.x < e.x) {\n            e.x += intersectionX\n          } else {\n            e.x -= intersectionX\n          }\n        }\n      }\n    })\n  }\n\n  protected checkIfStuck(): boolean {\n    const xIsStatic = this.prevX.every(x => x === this.prevX[0])\n    const yIsStatic = this.prevY.every(y => y === this.prevY[0])\n    if (xIsStatic && yIsStatic) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  // TODO: The color strings can be moved to a single hash map in order to optimize & localize the color searches\n  protected getHealthColor(): string {\n    if (this.health <= this.maxHealth * 0.10) {\n      return '#FF5700'\n    } else if (this.health <= this.maxHealth * 0.20) {\n      return '#FF7B00'\n    } else if (this.health <= this.maxHealth * 0.30) {\n      return '#FF9E00'\n    } else if (this.health <= this.maxHealth * 0.40) {\n      return '#FFC100'\n    } else if (this.health <= this.maxHealth * 0.50) {\n      return '#FFE400'\n    } else if (this.health <= this.maxHealth * 0.60) {\n      return '#FFF600'\n    } else if (this.health <= this.maxHealth * 0.70) {\n      return '#E5FF00'\n    } else if (this.health <= this.maxHealth * 0.80) {\n      return '#D4FF00'\n    } else if (this.health <= this.maxHealth * 0.90) {\n      return '#B0FF00'\n    } else if (this.health < this.maxHealth) {\n      return '#8DFF00'\n    } else if (this.health === this.maxHealth) {\n      return '#6AFF00'\n    }\n  }\n\n  private initializeHealth(healthPercentage: number): void {\n    if (healthPercentage < 0.0 || healthPercentage > 1.0) {\n      healthPercentage = 1.0\n    }\n    this.health = this.maxHealth * healthPercentage\n  }\n}\n","export enum Directions {\n  N  = 'N',\n  NE = 'NE',\n  E  = 'E',\n  SE = 'SE',\n  S  = 'S',\n  SW = 'SW',\n  W  = 'W',\n  NW = 'NW',\n}\n","import GameObject from './GameObject'\nimport MapKeys, { isBox } from '@app/domain/map/MapKeys'\nimport BoxFactory from '@app/domain/objects/box/BoxFactory'\n\nexport default class GameObjectFactory {\n  public static createGameObject(row: number, col: number, mapKey: MapKeys): GameObject | null {\n    if (isBox(mapKey)) {\n      return BoxFactory.createBox(row, col, mapKey)\n    }\n    else {\n      return null\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Box from '@app/domain/objects/box/Box'\nimport MapKeys from '@app/domain/map/MapKeys'\n\nexport default class BoxFactory {\n  public static createBox(row: number, col: number, mapKey: MapKeys): Box {\n    switch (mapKey) {\n      case MapKeys.BoxGray:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#4B4B4B', false)\n      case MapKeys.BoxGreen:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#27531B')\n      case MapKeys.BoxBlue:\n        return new Box(row, col, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, '#572F17')\n      default:\n        throw new Error('No such box!')\n    }\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport { context } from '@app/infrastructure/Canvas'\nimport SoundFX from '@app/audio/SoundFX'\nimport GameObject from '../GameObject'\n\nexport default class Box extends GameObject {\n  draw(): void {\n    context.strokeStyle = this.color\n    context.lineWidth = 1\n    context.beginPath()\n      // Draw box outline\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x                   , -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.lineTo( 0.5 + this.x,                     0.5 + this.y)\n\n      // Draw 'x' accross the box\n      context.moveTo( 0.5 + this.x,                     0.5 + this.y)\n      context.lineTo(-0.5 + this.x + CONFIG.TILE_SIZE, -0.5 + this.y + CONFIG.TILE_SIZE)\n      context.moveTo(-0.5 + this.x + CONFIG.TILE_SIZE,  0.5 + this.y)\n      context.lineTo( 0.5 + this.x,                    -0.5 + this.y + CONFIG.TILE_SIZE)\n    context.stroke()\n  }\n\n  public takeDamage(damageAmount: number): void {\n    SoundFX.playCrateHit()\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nexport default abstract class GameObject {\n  public x: number\n  public y: number\n  public mapX: number\n  public mapY: number\n\n  constructor(\n    public row: number,\n    public col: number,\n    public width: number,\n    public height: number,\n    public color: string,\n    public destructable: boolean = true,\n  ) {\n    this.mapX = col * CONFIG.TILE_SIZE\n    this.mapY = row * CONFIG.TILE_SIZE\n  }\n\n  public abstract draw(): void\n  public abstract takeDamage(damageAmount: number): void\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\nimport Raycaster from '@app/infrastructure/Raycaster'\nimport CollisionBox from '@app/infrastructure/CollisionBox'\nimport { angleBetweenPoints } from '@app/infrastructure/geometry/Point'\n\nimport Creature from '@app/domain/Creature'\nimport { getEnemiesOnScreen } from '@app/domain/map/Map'\nimport Crosshair from './Crosshair'\nimport Projectile from './Projectile'\n\nimport SoundFX from '@app/audio/SoundFX'\nimport Game from '@app/infrastructure/game/Game'\nimport GameStateManager from '@app/infrastructure/game/game_states/GameStateManager'\nimport GAME_STATES from '@app/infrastructure/game/game_states/GameStates'\n\nexport default class Player extends Creature {\n  public alive: boolean = true\n  public rotation: number = 0\n  public sightLineLength = 10\n  public collisionBox: CollisionBox = new CollisionBox(12, 12)\n  private maxSpeed: number = 2\n  private maxSpeedDiagonal: number = Math.round(Math.sin(45) * this.maxSpeed)\n  private shooting = false\n  private shootingCooldown = 6\n  private projectiles: Projectile[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n  )\n  {\n    super()\n    this.updateMapPosition()\n  }\n\n  public update(): void {\n    this.move()\n    this.updateTileDeltas()\n    this.shoot()\n    this.projectiles.forEach((p, i) => {\n      p.update(this.x, this.y)\n      if (p.alive === false) {\n        this.projectiles.splice(i, 1) // Remove the projectile\n      }\n    })\n  }\n\n  public shoot(): void {\n    if (this.shooting && this.shootingCooldown <= 0) {\n      const dx = (Canvas.mousePosition.x - Canvas.center.x)\n      const dy = (Canvas.mousePosition.y - Canvas.center.y)\n      let xVel = dx / ( Math.abs(dx) + Math.abs(dy) )\n      let yVel = dy / ( Math.abs(dx) + Math.abs(dy) )\n\n      // TODO: GAME FEATURE: Insert accuracy skill to reduce bullet motion randomness\n      // TODO: Fix the problem with different bullet speeds caused by randomness\n      const randomFactorX = Math.random() * 0.1 - 0.05\n      const randomFactorY = Math.random() * 0.1 - 0.05\n      xVel += randomFactorX\n      yVel += randomFactorY\n\n      this.projectiles.push(new Projectile(this.x, this.y, xVel, yVel))\n      this.shootingCooldown = 6\n\n      SoundFX.playSMG()\n    } else {\n      --this.shootingCooldown\n    }\n  }\n\n  public setShooting(isShooting: boolean): void {\n    this.shooting = isShooting\n  }\n\n  public draw(): void {\n    const theta = this.calculateTheta()\n    this.drawPlayer(theta)\n    this.drawPlayerVisionRay(theta)\n\n    // TODO: Just for testing purposes. Delete this.\n    // this.drawPlayerVisionRay(theta - 0.45)\n    // this.drawPlayerVisionRay(theta - 0.4)\n    // this.drawPlayerVisionRay(theta - 0.35)\n    // this.drawPlayerVisionRay(theta - 0.3)\n    // this.drawPlayerVisionRay(theta - 0.25)\n    // this.drawPlayerVisionRay(theta - 0.2)\n    // this.drawPlayerVisionRay(theta - 0.15)\n    // this.drawPlayerVisionRay(theta - 0.1)\n    // this.drawPlayerVisionRay(theta - 0.05)\n    // this.drawPlayerVisionRay(theta + 0.05)\n    // this.drawPlayerVisionRay(theta + 0.1)\n    // this.drawPlayerVisionRay(theta + 0.15)\n    // this.drawPlayerVisionRay(theta + 0.2)\n    // this.drawPlayerVisionRay(theta + 0.25)\n    // this.drawPlayerVisionRay(theta + 0.3)\n    // this.drawPlayerVisionRay(theta + 0.35)\n    // this.drawPlayerVisionRay(theta + 0.4)\n    // this.drawPlayerVisionRay(theta + 0.45)\n\n    Crosshair.draw()\n    this.drawProjectiles()\n  }\n\n  private move(): void {\n    if (this.moving.left) {\n      if (this.moving.up || this.moving.down) {\n        this.x -= this.maxSpeedDiagonal\n      } else {\n        this.x -= this.maxSpeed\n      }\n    }\n    if (this.moving.right) {\n      if (this.moving.up || this.moving.down) {\n        this.x += this.maxSpeedDiagonal\n      } else {\n        this.x += this.maxSpeed\n      }\n    }\n    if (this.moving.up) {\n      if (this.moving.left || this.moving.right) {\n        this.y -= this.maxSpeedDiagonal\n      } else {\n        this.y -= this.maxSpeed\n      }\n    }\n    if (this.moving.down) {\n      if (this.moving.left || this.moving.right) {\n        this.y += this.maxSpeedDiagonal\n      } else {\n        this.y += this.maxSpeed\n      }\n    }\n    this.adjustCollisionWithGameObjects()\n    this.checkForCollisionWithEnemies()\n    this.updateMapPosition()\n  }\n\n  private calculateTheta(): number {\n    const theta = angleBetweenPoints(Canvas.mousePosition, Canvas.center)\n    context.fillStyle = '#44FF44'\n    context.fillText(`θ = ${theta.toFixed(2)}`, 10, 56)\n    return theta\n  }\n\n  private drawPlayer(theta: number): void {\n    // Draw gun\n    context.beginPath()\n      context.fillStyle = '#00AA00'\n      context.font = '10px Monospace'\n\n      context.fillText(`p (${this.x}, ${this.y})`, 10, 20)\n\n      context.strokeStyle = '#523DA5'\n      context.lineWidth = 2\n      context.moveTo(Canvas.center.x, Canvas.center.y)\n      context.lineTo(Canvas.center.x + (this.sightLineLength * Math.cos(theta)), Canvas.center.y + (this.sightLineLength * Math.sin(theta)))\n    context.stroke()\n\n    this.drawCollisionBox() // Just for debugging\n  }\n\n  private drawCollisionBox() {\n    context.lineWidth = 1\n    context.beginPath()\n      // Since this is just for debugging purposes, there is no need to\n      // cache the vertex calculations.\n      context.moveTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n      context.lineTo( 0.5 + Canvas.center.x + this.collisionBox.halfWidth,  0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth,  0.5 + Canvas.center.y + this.collisionBox.halfHeight)\n      context.lineTo(-0.5 + Canvas.center.x - this.collisionBox.halfWidth, -0.5 + Canvas.center.y - this.collisionBox.halfHeight)\n    context.stroke()\n  }\n\n  private drawPlayerVisionRay(theta: number) {\n    const { hitPoint, hitObject } = Raycaster.cast(this, theta)\n    if (hitPoint) {\n      if (hitObject) {\n        Raycaster.drawRay(hitPoint, '#FF4444')\n      } else {\n        Raycaster.drawRay(hitPoint)\n      }\n    }\n  }\n\n  private drawProjectiles() {\n    this.projectiles.forEach(p => p.draw(this.x, this.y))\n  }\n\n  // TODO: Not DRY... generalize this functionality\n  private updateMapPosition(): void {\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n  }\n\n  private updateTileDeltas(): void {\n    this.deltas.dyTop = this.y % CONFIG.TILE_SIZE\n    this.deltas.dyBottom = CONFIG.TILE_SIZE - this.deltas.dyTop\n    this.deltas.dxLeft = this.x % CONFIG.TILE_SIZE\n    this.deltas.dxRight = CONFIG.TILE_SIZE - this.deltas.dxLeft\n  }\n\n  private checkForCollisionWithEnemies(): void {\n    if (getEnemiesOnScreen(this.x, this.y)\n      .filter(e => e.collidesWithPlayer(this.x, this.y, this.collisionBox))\n      .length > 0) {\n        this.die()\n      }\n  }\n\n  private die(): void {\n    this.alive = false\n  }\n}\n","import Canvas, { context } from '@app/infrastructure/Canvas'\n\nexport default class Crosshair {\n  public static draw(): void {\n    const canvasX: number = Canvas.mousePosition.x\n    const canvasY: number = Canvas.mousePosition.y\n    let offsetX\n    let offsetY\n    context.strokeStyle = '#FFFFFF'\n    context.lineWidth = 0.5\n    context.beginPath()\n      // Top\n      offsetX =  0.5\n      offsetY = -1.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = -3.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Bottom\n      offsetY = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetY = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Left\n      offsetY =  0.5\n      offsetX = -3.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = -1.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n\n      // Right\n      offsetX = 2.5\n      context.moveTo(canvasX + offsetX, canvasY + offsetY)\n      offsetX = 4.5\n      context.lineTo(canvasX + offsetX, canvasY + offsetY)\n    context.stroke()\n  }\n}","import * as CONFIG from '@app/configuration/config.json'\n\nimport Canvas, { context } from '@app/infrastructure/Canvas'\n\nimport Enemy from '@app/domain/enemies/Enemy'\nimport { gameObjects, enemies } from '@app/domain/map/Map'\n\ninterface IntermediatePoint {\n  x: number\n  y: number\n  row: number\n  col: number\n}\n\nexport default class Projectile {\n  public speed: number = 24\n  public damage: number = 10\n  public alive: boolean = true\n  public row: number\n  public col: number\n  private previousX: number\n  private previousY: number\n\n  /*\n   * Intermediate positions/points solve the bullet phasing problem\n   */\n  private numberOfIntermediatePositions: number = 3 // More intermediate points give more precision, 3 are just fine\n  private intermediatePositions: IntermediatePoint[] = []\n\n  constructor(\n    public x: number,\n    public y: number,\n    public directionX: number,\n    public directionY: number,\n  ) {\n    for (let i = 0; i < this.numberOfIntermediatePositions; ++i) {\n      this.intermediatePositions[i] = { x: null, y: null, row: null, col: null }\n    }\n  }\n\n  public update(playerX: number, playerY: number): void {\n    this.previousX = this.x\n    this.previousY = this.y\n    this.x += this.directionX * this.speed\n    this.y += this.directionY * this.speed\n    this.row = Math.floor(this.y / CONFIG.TILE_SIZE)\n    this.col = Math.floor(this.x / CONFIG.TILE_SIZE)\n\n    const nearbyEnemies = this.getNearbyEnemies()\n\n    this.calculateIntermediatePoints()\n\n    if (this.isOffScreen(playerX, playerY)) {\n      this.alive = false\n    }\n\n    this.intermediatePositions.forEach(intermediatePoint => {\n      if (this.alive) {\n        this.checkCollisionWithEnemies(nearbyEnemies, intermediatePoint)\n        this.checkCollisionWithGameObject(intermediatePoint)\n      }\n    })\n    if (this.alive) {\n      this.checkCollisionWithEnemies(nearbyEnemies)\n      this.checkCollisionWithGameObject()\n    }\n  }\n\n  public draw(playerX: number, playerY: number) {\n    if (this.x === playerX && this.y === playerY) {\n      // Don't draw the first projectile that is spawned at player position.\n      return\n    }\n    context.strokeStyle = '#8AFCFF'\n    context.lineWidth = 1\n    context.beginPath()\n    context.arc(\n      this.x + Canvas.center.x - playerX,\n      this.y + Canvas.center.y - playerY,\n      2,\n      0,\n      (2 * Math.PI)\n    )\n    context.stroke()\n  }\n  // TODO: There could be space for optimization here\n  //       Instead of finding the nearest enemies every time, maybe just take\n  //       the enemies that are visible on the screen (+ some offset)?\n  private getNearbyEnemies(): Enemy[] {\n    return [ ...enemies ].filter(e => (\n      Math.abs(e.x - this.x) <= CONFIG.TILE_SIZE &&\n      Math.abs(e.y - this.y) <= CONFIG.TILE_SIZE\n    ))\n  }\n  /**\n   *                                     (this.x, this.y)\n   *  (this.previousX, this.previousY)   /\n   *  /                                 /\n   * x-------o-------o--------o--------x\n   *         |       |        |\n   *          \\      |       /\n   *        Intermediate points\n   */\n  private calculateIntermediatePoints(): void {\n    const intermediateIntervalX = (this.x - this.previousX) / (this.numberOfIntermediatePositions + 1)\n    const intermediateIntervalY = (this.y - this.previousY) / (this.numberOfIntermediatePositions + 1)\n    for (let i = this.numberOfIntermediatePositions - 1; i >= 0; --i) {\n      this.intermediatePositions[i].x = this.x - intermediateIntervalX * (i + 1)\n      this.intermediatePositions[i].y = this.y - intermediateIntervalY * (i + 1)\n      this.intermediatePositions[i].row = Math.floor(this.intermediatePositions[i].y / CONFIG.TILE_SIZE)\n      this.intermediatePositions[i].col = Math.floor(this.intermediatePositions[i].x / CONFIG.TILE_SIZE)\n    }\n  }\n\n  private isOffScreen(playerX: number, playerY: number): boolean {\n    return (\n      this.x < playerX - Canvas.center.x - CONFIG.TILE_SIZE || this.x > playerX + Canvas.center.x + CONFIG.TILE_SIZE ||\n      this.y < playerY - Canvas.center.y - CONFIG.TILE_SIZE || this.y > playerY + Canvas.center.y + CONFIG.TILE_SIZE\n    )\n  }\n\n  private checkCollisionWithEnemies(nearbyEnemies: Enemy[], point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    nearbyEnemies.forEach(e => {\n      if (\n        point.x >= e.x - e.collisionBox.halfWidth &&\n        point.x <= e.x + e.collisionBox.halfWidth &&\n        point.y >= e.y - e.collisionBox.halfHeight &&\n        point.y <= e.y + e.collisionBox.halfHeight\n      ) {\n        this.alive = false\n        e.takeDamage(this.getDamage())\n      }\n    })\n  }\n\n  private checkCollisionWithGameObject(point?: IntermediatePoint | Projectile): void {\n    if (!point) {\n      point = this\n    }\n\n    const o = gameObjects[point.row][point.col]\n    if (o) {\n        o.takeDamage(this.getDamage())\n        this.alive = false\n        if (o.destructable) {\n          gameObjects[point.row][point.col] = null\n        }\n    }\n  }\n\n  private getDamage(): number {\n    return this.damage // TODO: Randomize this a bit\n  }\n}\n","import * as CONFIG from '@app/configuration/config.json'\n\nimport IGameState from './IGameState'\nimport { context } from '@app/infrastructure/Canvas'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStatePaused implements IGameState {\n  public enter(): void {\n    return\n  }\n  public exit(): void {\n    return\n  }\n\n  public update(): void {\n    return\n  }\n\n  public render(): void {\n    GAME_STATES.PLAYING.render()\n    this.drawPauseMenu()\n  }\n\n  private drawPauseMenu(): void {\n    context.beginPath()\n      context.fillStyle = '#FFC100'\n      context.font = '20px Monospace'\n\n      context.fillText(`Paused`, CONFIG.CANVAS_WIDTH / 2 - 36, CONFIG.CANVAS_HEIGHT / 2 - 54)\n      context.font = '12px Monospace'\n      context.fillText('  p - Resume',    CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 34)\n      context.fillText('ESC - Main Menu', CONFIG.CANVAS_WIDTH / 2 - 50, CONFIG.CANVAS_HEIGHT / 2 - 18)\n    context.stroke()\n  }\n}\n","import IGameState from './IGameState'\nimport GAME_STATES from './GameStates'\n\nexport default class GameStateManager {\n  private currentState: IGameState = GAME_STATES.LOADING\n\n  public getState(): IGameState {\n    return this.currentState\n  }\n  public setState(nextState: IGameState): IGameState {\n    this.currentState.exit(nextState)\n    const previousState = this.currentState\n    nextState.enter(previousState)\n    this.currentState = nextState\n    return this.currentState\n  }\n\n  public update(): void {\n    this.currentState.update()\n  }\n  public render(): void {\n    this.currentState.render()\n  }\n}\n","\nenum GameAssets {\n  Graphics,\n  Audio,\n}\n\nexport default GameAssets","import Canvas, { context } from '@app/infrastructure/Canvas'\nimport Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nimport CreatureSprite from './CreatureSprite'\n\nexport default class SpriteZerg extends CreatureSprite {\n  public url: string = './graphics/spritesheets/zergling.png'\n\n  public animationPeriods = {\n    walking: 8,\n  }\n\n  public draw(enemy: Enemy, playerCoordinates: Point) {\n\n    const SPRITE_LOCATIONS: { [key: string]: { col: number, flip: boolean } } = {\n      N : { col: 0, flip: false },\n      NE: { col: 2, flip: false },\n      E : { col: 4, flip: false },\n      SE: { col: 6, flip: false },\n      S : { col: 8, flip: false },\n      SW: { col: 6, flip: true  },\n      W : { col: 4, flip: true  },\n      NW: { col: 2, flip: true  },\n    }\n\n    const spriteLocation = SPRITE_LOCATIONS[enemy.direction]\n\n    const SPRITE_SIZE = 32\n    const SPRITE_OFFSETS = {\n      INITIAL: { x: 7, y: 5 },\n      STEP: { x: SPRITE_SIZE + 11, y: SPRITE_SIZE + 10 }\n    }\n    const { x, y, collisionBox: cBox } = enemy\n    const { x: px, y: py } = playerCoordinates\n\n    if (enemy.isMoving === false) {\n      enemy.animationInterval = 0\n    }\n\n    if (spriteLocation.flip) {\n      context.save()\n      context.translate(\n        Canvas.center.x + (x - px - cBox.halfWidth),\n        Canvas.center.y + (y - py - cBox.halfHeight),\n      )\n      context.scale(-1, 1)\n    }\n\n    context.drawImage(\n      this.spriteSheet,\n      SPRITE_OFFSETS.INITIAL.x + SPRITE_OFFSETS.STEP.x * spriteLocation.col,\n      SPRITE_OFFSETS.INITIAL.y + SPRITE_OFFSETS.STEP.y * Math.floor(enemy.animationInterval / 2),\n      SPRITE_SIZE,\n      SPRITE_SIZE,\n      spriteLocation.flip ? 0 - SPRITE_SIZE / 2 : Canvas.center.x + (x - px - cBox.halfWidth),\n      spriteLocation.flip ? 0                   : Canvas.center.y + (y - py - cBox.halfHeight),\n      enemy.collisionBox.width + 2,\n      enemy.collisionBox.height + 2,\n    )\n    if (spriteLocation.flip) {\n      context.restore()\n    }\n  }\n}\n","import Point from '@app/infrastructure/geometry/Point'\nimport Enemy from '@app/domain/enemies/Enemy'\n\nexport default abstract class CreatureSprite {\n  public spriteSheet: HTMLImageElement\n\n  public abstract animationPeriods: { [animation: string]: number }\n\n  protected abstract url: string\n  public abstract draw(e: Enemy, playerCoordinates: Point): void\n\n  public load(callback: () => void): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      this.spriteSheet = new Image()\n      this.spriteSheet.src = this.url\n      this.spriteSheet.onload = () => {\n        callback()\n        resolve()\n      }\n    })\n  }\n}\n"],"sourceRoot":""}